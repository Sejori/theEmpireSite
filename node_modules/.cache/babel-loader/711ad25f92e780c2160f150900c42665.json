{"ast":null,"code":"import { EventDispatcher } from './EventDispatcher.js';\nimport { Face3 } from './Face3.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Box3 } from '../math/Box3.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Color } from '../math/Color.js';\nimport { Object3D } from './Object3D.js';\nimport { MathUtils } from '../math/MathUtils.js';\nvar _geometryId = 0; // Geometry uses even numbers as Id\n\nvar _m1 = new Matrix4();\n\nvar _obj = new Object3D();\n\nvar _offset = new Vector3();\n\nfunction Geometry() {\n  Object.defineProperty(this, 'id', {\n    value: _geometryId += 2\n  });\n  this.uuid = MathUtils.generateUUID();\n  this.name = '';\n  this.type = 'Geometry';\n  this.vertices = [];\n  this.colors = [];\n  this.faces = [];\n  this.faceVertexUvs = [[]];\n  this.morphTargets = [];\n  this.morphNormals = [];\n  this.skinWeights = [];\n  this.skinIndices = [];\n  this.lineDistances = [];\n  this.boundingBox = null;\n  this.boundingSphere = null; // update flags\n\n  this.elementsNeedUpdate = false;\n  this.verticesNeedUpdate = false;\n  this.uvsNeedUpdate = false;\n  this.normalsNeedUpdate = false;\n  this.colorsNeedUpdate = false;\n  this.lineDistancesNeedUpdate = false;\n  this.groupsNeedUpdate = false;\n}\n\nGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\n  constructor: Geometry,\n  isGeometry: true,\n  applyMatrix4: function applyMatrix4(matrix) {\n    var normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\n    for (var i = 0, il = this.vertices.length; i < il; i++) {\n      var vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n\n    for (var _i = 0, _il = this.faces.length; _i < _il; _i++) {\n      var face = this.faces[_i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n\n      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  },\n  rotateX: function rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  rotateY: function rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  rotateZ: function rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  translate: function translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  scale: function scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  lookAt: function lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  },\n  fromBufferGeometry: function fromBufferGeometry(geometry) {\n    var scope = this;\n    var index = geometry.index !== null ? geometry.index : undefined;\n    var attributes = geometry.attributes;\n\n    if (attributes.position === undefined) {\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n      return this;\n    }\n\n    var position = attributes.position;\n    var normal = attributes.normal;\n    var color = attributes.color;\n    var uv = attributes.uv;\n    var uv2 = attributes.uv2;\n    if (uv2 !== undefined) this.faceVertexUvs[1] = [];\n\n    for (var i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n\n      if (color !== undefined) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n\n    function addFace(a, b, c, materialIndex) {\n      var vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      var vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n      var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n\n      if (uv !== undefined) {\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n      }\n\n      if (uv2 !== undefined) {\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n      }\n    }\n\n    var groups = geometry.groups;\n\n    if (groups.length > 0) {\n      for (var _i2 = 0; _i2 < groups.length; _i2++) {\n        var group = groups[_i2];\n        var start = group.start;\n        var count = group.count;\n\n        for (var j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== undefined) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== undefined) {\n        for (var _i3 = 0; _i3 < index.count; _i3 += 3) {\n          addFace(index.getX(_i3), index.getX(_i3 + 1), index.getX(_i3 + 2));\n        }\n      } else {\n        for (var _i4 = 0; _i4 < position.count; _i4 += 3) {\n          addFace(_i4, _i4 + 1, _i4 + 2);\n        }\n      }\n    }\n\n    this.computeFaceNormals();\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    return this;\n  },\n  center: function center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  },\n  normalize: function normalize() {\n    this.computeBoundingSphere();\n    var center = this.boundingSphere.center;\n    var radius = this.boundingSphere.radius;\n    var s = radius === 0 ? 1 : 1.0 / radius;\n    var matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  },\n  computeFaceNormals: function computeFaceNormals() {\n    var cb = new Vector3(),\n        ab = new Vector3();\n\n    for (var f = 0, fl = this.faces.length; f < fl; f++) {\n      var face = this.faces[f];\n      var vA = this.vertices[face.a];\n      var vB = this.vertices[face.b];\n      var vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  },\n  computeVertexNormals: function computeVertexNormals(areaWeighted) {\n    if (areaWeighted === undefined) areaWeighted = true;\n    var vertices = new Array(this.vertices.length);\n\n    for (var v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n      var cb = new Vector3(),\n          ab = new Vector3();\n\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\n        var face = this.faces[f];\n        var vA = this.vertices[face.a];\n        var vB = this.vertices[face.b];\n        var vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n\n      for (var _f = 0, _fl = this.faces.length; _f < _fl; _f++) {\n        var _face = this.faces[_f];\n\n        vertices[_face.a].add(_face.normal);\n\n        vertices[_face.b].add(_face.normal);\n\n        vertices[_face.c].add(_face.normal);\n      }\n    }\n\n    for (var _v = 0, _vl = this.vertices.length; _v < _vl; _v++) {\n      vertices[_v].normalize();\n    }\n\n    for (var _f2 = 0, _fl2 = this.faces.length; _f2 < _fl2; _f2++) {\n      var _face2 = this.faces[_f2];\n      var vertexNormals = _face2.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[_face2.a]);\n        vertexNormals[1].copy(vertices[_face2.b]);\n        vertexNormals[2].copy(vertices[_face2.c]);\n      } else {\n        vertexNormals[0] = vertices[_face2.a].clone();\n        vertexNormals[1] = vertices[_face2.b].clone();\n        vertexNormals[2] = vertices[_face2.c].clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  },\n  computeFlatVertexNormals: function computeFlatVertexNormals() {\n    this.computeFaceNormals();\n\n    for (var f = 0, fl = this.faces.length; f < fl; f++) {\n      var face = this.faces[f];\n      var vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  },\n  computeMorphNormals: function computeMorphNormals() {\n    // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n    for (var f = 0, fl = this.faces.length; f < fl; f++) {\n      var face = this.faces[f];\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n\n      for (var i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    } // use temp geometry to compute face and vertex normals for each morph\n\n\n    var tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n\n    for (var _i5 = 0, _il2 = this.morphTargets.length; _i5 < _il2; _i5++) {\n      // create on first access\n      if (!this.morphNormals[_i5]) {\n        this.morphNormals[_i5] = {};\n        this.morphNormals[_i5].faceNormals = [];\n        this.morphNormals[_i5].vertexNormals = [];\n        var dstNormalsFace = this.morphNormals[_i5].faceNormals;\n        var dstNormalsVertex = this.morphNormals[_i5].vertexNormals;\n\n        for (var _f3 = 0, _fl3 = this.faces.length; _f3 < _fl3; _f3++) {\n          var faceNormal = new Vector3();\n          var vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n\n      var morphNormals = this.morphNormals[_i5]; // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[_i5].vertices; // compute morph normals\n\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals(); // store morph normals\n\n      for (var _f4 = 0, _fl4 = this.faces.length; _f4 < _fl4; _f4++) {\n        var _face3 = this.faces[_f4];\n        var _faceNormal = morphNormals.faceNormals[_f4];\n        var _vertexNormals = morphNormals.vertexNormals[_f4];\n\n        _faceNormal.copy(_face3.normal);\n\n        _vertexNormals.a.copy(_face3.vertexNormals[0]);\n\n        _vertexNormals.b.copy(_face3.vertexNormals[1]);\n\n        _vertexNormals.c.copy(_face3.vertexNormals[2]);\n      }\n    } // restore original normals\n\n\n    for (var _f5 = 0, _fl5 = this.faces.length; _f5 < _fl5; _f5++) {\n      var _face4 = this.faces[_f5];\n      _face4.normal = _face4.__originalFaceNormal;\n      _face4.vertexNormals = _face4.__originalVertexNormals;\n    }\n  },\n  computeBoundingBox: function computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    this.boundingBox.setFromPoints(this.vertices);\n  },\n  computeBoundingSphere: function computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices);\n  },\n  merge: function merge(geometry, matrix, materialIndexOffset) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n      return;\n    }\n\n    var normalMatrix;\n    var vertexOffset = this.vertices.length,\n        vertices1 = this.vertices,\n        vertices2 = geometry.vertices,\n        faces1 = this.faces,\n        faces2 = geometry.faces,\n        colors1 = this.colors,\n        colors2 = geometry.colors;\n    if (materialIndexOffset === undefined) materialIndexOffset = 0;\n\n    if (matrix !== undefined) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    } // vertices\n\n\n    for (var i = 0, il = vertices2.length; i < il; i++) {\n      var vertex = vertices2[i];\n      var vertexCopy = vertex.clone();\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    } // colors\n\n\n    for (var _i6 = 0, _il3 = colors2.length; _i6 < _il3; _i6++) {\n      colors1.push(colors2[_i6].clone());\n    } // faces\n\n\n    for (var _i7 = 0, _il4 = faces2.length; _i7 < _il4; _i7++) {\n      var face = faces2[_i7];\n      var normal = void 0,\n          color = void 0;\n      var faceVertexNormals = face.vertexNormals,\n          faceVertexColors = face.vertexColors;\n      var faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n\n        faceCopy.vertexNormals.push(normal);\n      }\n\n      faceCopy.color.copy(face.color);\n\n      for (var _j = 0, _jl = faceVertexColors.length; _j < _jl; _j++) {\n        color = faceVertexColors[_j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    } // uvs\n\n\n    for (var _i8 = 0, _il5 = geometry.faceVertexUvs.length; _i8 < _il5; _i8++) {\n      var faceVertexUvs2 = geometry.faceVertexUvs[_i8];\n      if (this.faceVertexUvs[_i8] === undefined) this.faceVertexUvs[_i8] = [];\n\n      for (var _j2 = 0, _jl2 = faceVertexUvs2.length; _j2 < _jl2; _j2++) {\n        var uvs2 = faceVertexUvs2[_j2],\n            uvsCopy = [];\n\n        for (var k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n\n        this.faceVertexUvs[_i8].push(uvsCopy);\n      }\n    }\n  },\n  mergeMesh: function mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n      return;\n    }\n\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  },\n\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n  mergeVertices: function mergeVertices() {\n    var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\n    var unique = [],\n        changes = [];\n    var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\n    var precision = Math.pow(10, precisionPoints);\n\n    for (var i = 0, il = this.vertices.length; i < il; i++) {\n      var v = this.vertices[i];\n      var key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);\n\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]];\n      }\n    } // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n\n\n    var faceIndicesToRemove = [];\n\n    for (var _i9 = 0, _il6 = this.faces.length; _i9 < _il6; _i9++) {\n      var face = this.faces[_i9];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      var indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n\n      for (var n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(_i9);\n          break;\n        }\n      }\n    }\n\n    for (var _i10 = faceIndicesToRemove.length - 1; _i10 >= 0; _i10--) {\n      var idx = faceIndicesToRemove[_i10];\n      this.faces.splice(idx, 1);\n\n      for (var j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    } // Use unique set of vertices\n\n\n    var diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  },\n  setFromPoints: function setFromPoints(points) {\n    this.vertices = [];\n\n    for (var i = 0, l = points.length; i < l; i++) {\n      var point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n\n    return this;\n  },\n  sortFacesByMaterialIndex: function sortFacesByMaterialIndex() {\n    var faces = this.faces;\n    var length = faces.length; // tag faces\n\n    for (var i = 0; i < length; i++) {\n      faces[i]._id = i;\n    } // sort faces\n\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n\n    faces.sort(materialIndexSort); // sort uvs\n\n    var uvs1 = this.faceVertexUvs[0];\n    var uvs2 = this.faceVertexUvs[1];\n    var newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\n\n    for (var _i11 = 0; _i11 < length; _i11++) {\n      var id = faces[_i11]._id;\n      if (newUvs1) newUvs1.push(uvs1[id]);\n      if (newUvs2) newUvs2.push(uvs2[id]);\n    }\n\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n  },\n  toJSON: function toJSON() {\n    var data = {\n      metadata: {\n        version: 4.5,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON'\n      }\n    }; // standard Geometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n\n    if (this.parameters !== undefined) {\n      var parameters = this.parameters;\n\n      for (var key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    var vertices = [];\n\n    for (var i = 0; i < this.vertices.length; i++) {\n      var vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    var faces = [];\n    var normals = [];\n    var normalsHash = {};\n    var colors = [];\n    var colorsHash = {};\n    var uvs = [];\n    var uvsHash = {};\n\n    for (var _i12 = 0; _i12 < this.faces.length; _i12++) {\n      var face = this.faces[_i12];\n      var hasMaterial = true;\n      var hasFaceUv = false; // deprecated\n\n      var hasFaceVertexUv = this.faceVertexUvs[0][_i12] !== undefined;\n      var hasFaceNormal = face.normal.length() > 0;\n      var hasFaceVertexNormal = face.vertexNormals.length > 0;\n      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      var hasFaceVertexColor = face.vertexColors.length > 0;\n      var faceType = 0;\n      faceType = setBit(faceType, 0, 0); // isQuad\n\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n\n      if (hasFaceVertexUv) {\n        var faceVertexUvs = this.faceVertexUvs[0][_i12];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n\n      if (hasFaceVertexNormal) {\n        var vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n\n      if (hasFaceVertexColor) {\n        var vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n\n    function getNormalIndex(normal) {\n      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash];\n      }\n\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n\n    function getColorIndex(color) {\n      var hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash];\n      }\n\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n\n    function getUvIndex(uv) {\n      var hash = uv.x.toString() + uv.y.toString();\n\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash];\n      }\n\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\n    data.data.faces = faces;\n    return data;\n  },\n  clone: function clone() {\n    /*\n     // Handle primitives\n    \t const parameters = this.parameters;\n    \t if ( parameters !== undefined ) {\n    \t const values = [];\n    \t for ( const key in parameters ) {\n    \t values.push( parameters[ key ] );\n    \t }\n    \t const geometry = Object.create( this.constructor.prototype );\n     this.constructor.apply( geometry, values );\n     return geometry;\n    \t }\n    \t return new this.constructor().copy( this );\n     */\n    return new Geometry().copy(this);\n  },\n  copy: function copy(source) {\n    // reset\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // name\n\n    this.name = source.name; // vertices\n\n    var vertices = source.vertices;\n\n    for (var i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    } // colors\n\n\n    var colors = source.colors;\n\n    for (var _i13 = 0, _il7 = colors.length; _i13 < _il7; _i13++) {\n      this.colors.push(colors[_i13].clone());\n    } // faces\n\n\n    var faces = source.faces;\n\n    for (var _i14 = 0, _il8 = faces.length; _i14 < _il8; _i14++) {\n      this.faces.push(faces[_i14].clone());\n    } // face vertex uvs\n\n\n    for (var _i15 = 0, _il9 = source.faceVertexUvs.length; _i15 < _il9; _i15++) {\n      var faceVertexUvs = source.faceVertexUvs[_i15];\n\n      if (this.faceVertexUvs[_i15] === undefined) {\n        this.faceVertexUvs[_i15] = [];\n      }\n\n      for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        var uvs = faceVertexUvs[j],\n            uvsCopy = [];\n\n        for (var k = 0, kl = uvs.length; k < kl; k++) {\n          var uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n\n        this.faceVertexUvs[_i15].push(uvsCopy);\n      }\n    } // morph targets\n\n\n    var morphTargets = source.morphTargets;\n\n    for (var _i16 = 0, _il10 = morphTargets.length; _i16 < _il10; _i16++) {\n      var morphTarget = {};\n      morphTarget.name = morphTargets[_i16].name; // vertices\n\n      if (morphTargets[_i16].vertices !== undefined) {\n        morphTarget.vertices = [];\n\n        for (var _j3 = 0, _jl3 = morphTargets[_i16].vertices.length; _j3 < _jl3; _j3++) {\n          morphTarget.vertices.push(morphTargets[_i16].vertices[_j3].clone());\n        }\n      } // normals\n\n\n      if (morphTargets[_i16].normals !== undefined) {\n        morphTarget.normals = [];\n\n        for (var _j4 = 0, _jl4 = morphTargets[_i16].normals.length; _j4 < _jl4; _j4++) {\n          morphTarget.normals.push(morphTargets[_i16].normals[_j4].clone());\n        }\n      }\n\n      this.morphTargets.push(morphTarget);\n    } // morph normals\n\n\n    var morphNormals = source.morphNormals;\n\n    for (var _i17 = 0, _il11 = morphNormals.length; _i17 < _il11; _i17++) {\n      var morphNormal = {}; // vertex normals\n\n      if (morphNormals[_i17].vertexNormals !== undefined) {\n        morphNormal.vertexNormals = [];\n\n        for (var _j5 = 0, _jl5 = morphNormals[_i17].vertexNormals.length; _j5 < _jl5; _j5++) {\n          var srcVertexNormal = morphNormals[_i17].vertexNormals[_j5];\n          var destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      } // face normals\n\n\n      if (morphNormals[_i17].faceNormals !== undefined) {\n        morphNormal.faceNormals = [];\n\n        for (var _j6 = 0, _jl6 = morphNormals[_i17].faceNormals.length; _j6 < _jl6; _j6++) {\n          morphNormal.faceNormals.push(morphNormals[_i17].faceNormals[_j6].clone());\n        }\n      }\n\n      this.morphNormals.push(morphNormal);\n    } // skin weights\n\n\n    var skinWeights = source.skinWeights;\n\n    for (var _i18 = 0, _il12 = skinWeights.length; _i18 < _il12; _i18++) {\n      this.skinWeights.push(skinWeights[_i18].clone());\n    } // skin indices\n\n\n    var skinIndices = source.skinIndices;\n\n    for (var _i19 = 0, _il13 = skinIndices.length; _i19 < _il13; _i19++) {\n      this.skinIndices.push(skinIndices[_i19].clone());\n    } // line distances\n\n\n    var lineDistances = source.lineDistances;\n\n    for (var _i20 = 0, _il14 = lineDistances.length; _i20 < _il14; _i20++) {\n      this.lineDistances.push(lineDistances[_i20]);\n    } // bounding box\n\n\n    var boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    var boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // update flags\n\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n});\nexport { Geometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/core/Geometry.js"],"names":["EventDispatcher","Face3","Matrix3","Sphere","Box3","Vector3","Matrix4","Vector2","Color","Object3D","MathUtils","_geometryId","_m1","_obj","_offset","Geometry","Object","defineProperty","value","uuid","generateUUID","name","type","vertices","colors","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","prototype","assign","create","constructor","isGeometry","applyMatrix4","matrix","normalMatrix","getNormalMatrix","i","il","length","vertex","face","normal","applyMatrix3","normalize","j","jl","vertexNormals","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","fromBufferGeometry","geometry","scope","index","undefined","attributes","position","console","error","color","uv","uv2","count","push","fromBufferAttribute","addFace","a","b","c","materialIndex","vertexColors","clone","groups","group","start","getX","computeFaceNormals","center","getCenter","negate","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","copy","computeVertexNormals","areaWeighted","Array","v","vl","add","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","setFromPoints","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvs2","uvsCopy","k","kl","mergeMesh","mesh","isMesh","matrixAutoUpdate","mergeVertices","verticesMap","unique","changes","precisionPoints","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","sortFacesByMaterialIndex","_id","materialIndexSort","sort","uvs1","newUvs1","newUvs2","id","toJSON","data","metadata","version","generator","parameters","normals","normalsHash","colorsHash","uvs","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","enabled","hash","toString","getHex","source","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","dispose","dispatchEvent"],"mappings":"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","sourcesContent":["import { EventDispatcher } from './EventDispatcher.js';\nimport { Face3 } from './Face3.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Box3 } from '../math/Box3.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Color } from '../math/Color.js';\nimport { Object3D } from './Object3D.js';\nimport { MathUtils } from '../math/MathUtils.js';\n\nlet _geometryId = 0; // Geometry uses even numbers as Id\nconst _m1 = new Matrix4();\nconst _obj = new Object3D();\nconst _offset = new Vector3();\n\nfunction Geometry() {\n\n\tObject.defineProperty( this, 'id', { value: _geometryId += 2 } );\n\n\tthis.uuid = MathUtils.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Geometry';\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.faces = [];\n\tthis.faceVertexUvs = [[]];\n\n\tthis.morphTargets = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.elementsNeedUpdate = false;\n\tthis.verticesNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n}\n\nGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Geometry,\n\n\tisGeometry: true,\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( let i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( let j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.verticesNeedUpdate = true;\n\t\tthis.normalsNeedUpdate = true;\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function ( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t},\n\n\tfromBufferGeometry: function ( geometry ) {\n\n\t\tconst scope = this;\n\n\t\tconst index = geometry.index !== null ? geometry.index : undefined;\n\t\tconst attributes = geometry.attributes;\n\n\t\tif ( attributes.position === undefined ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst position = attributes.position;\n\t\tconst normal = attributes.normal;\n\t\tconst color = attributes.color;\n\t\tconst uv = attributes.uv;\n\t\tconst uv2 = attributes.uv2;\n\n\t\tif ( uv2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\tscope.vertices.push( new Vector3().fromBufferAttribute( position, i ) );\n\n\t\t\tif ( color !== undefined ) {\n\n\t\t\t\tscope.colors.push( new Color().fromBufferAttribute( color, i ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\tconst vertexColors = ( color === undefined ) ? [] : [\n\t\t\t\tscope.colors[ a ].clone(),\n\t\t\t\tscope.colors[ b ].clone(),\n\t\t\t\tscope.colors[ c ].clone()\n\t\t\t];\n\n\t\t\tconst vertexNormals = ( normal === undefined ) ? [] : [\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, a ),\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, b ),\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, c )\n\t\t\t];\n\n\t\t\tconst face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\tscope.faces.push( face );\n\n\t\t\tif ( uv !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, a ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, b ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, c )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( uv2 !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, a ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, b ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, c )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst groups = geometry.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tconst start = group.start;\n\t\t\t\tconst count = group.count;\n\n\t\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\t\taddFace( index.getX( j ), index.getX( j + 1 ), index.getX( j + 2 ), group.materialIndex );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\taddFace( j, j + 1, j + 2, group.materialIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < index.count; i += 3 ) {\n\n\t\t\t\t\taddFace( index.getX( i ), index.getX( i + 1 ), index.getX( i + 2 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i += 3 ) {\n\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeFaceNormals();\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\tthis.computeBoundingSphere();\n\n\t\tconst center = this.boundingSphere.center;\n\t\tconst radius = this.boundingSphere.radius;\n\n\t\tconst s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\tconst matrix = new Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * center.x,\n\t\t\t0, s, 0, - s * center.y,\n\t\t\t0, 0, s, - s * center.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vA = this.vertices[ face.a ];\n\t\t\tconst vB = this.vertices[ face.b ];\n\t\t\tconst vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\tconst vertices = new Array( this.vertices.length );\n\n\t\tfor ( let v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tconst vA = this.vertices[ face.a ];\n\t\t\t\tconst vB = this.vertices[ face.b ];\n\t\t\t\tconst vC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeFlatVertexNormals: function () {\n\n\t\tthis.computeFaceNormals();\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( let i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tconst tmpGeo = new Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( let i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tconst dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tconst dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tconst faceNormal = new Vector3();\n\t\t\t\t\tconst vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tconst faceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tconst vertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\tif ( ! ( geometry && geometry.isGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet normalMatrix;\n\t\tconst vertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tcolors1 = this.colors,\n\t\t\tcolors2 = geometry.colors;\n\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\tif ( matrix !== undefined ) {\n\n\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( let i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tconst vertex = vertices2[ i ];\n\n\t\t\tconst vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// colors\n\n\t\tfor ( let i = 0, il = colors2.length; i < il; i ++ ) {\n\n\t\t\tcolors1.push( colors2[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( let i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tconst face = faces2[ i ];\n\t\t\tlet normal, color;\n\t\t\tconst faceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tconst faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( let j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( let i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tconst faceVertexUvs2 = geometry.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) this.faceVertexUvs[ i ] = [];\n\n\t\t\tfor ( let j = 0, jl = faceVertexUvs2.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uvs2 = faceVertexUvs2[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( let k = 0, kl = uvs2.length; k < kl; k ++ ) {\n\n\t\t\t\t\tuvsCopy.push( uvs2[ k ].clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tmergeMesh: function ( mesh ) {\n\n\t\tif ( ! ( mesh && mesh.isMesh ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( mesh.matrixAutoUpdate ) mesh.updateMatrix();\n\n\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tconst verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\tconst unique = [], changes = [];\n\n\t\tconst precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\tconst precision = Math.pow( 10, precisionPoints );\n\n\t\tfor ( let i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tconst v = this.vertices[ i ];\n\t\t\tconst key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tconst faceIndicesToRemove = [];\n\n\t\tfor ( let i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tconst indices = [ face.a, face.b, face.c ];\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tconst idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( let j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tconst diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.vertices = [];\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst point = points[ i ];\n\t\t\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsortFacesByMaterialIndex: function () {\n\n\t\tconst faces = this.faces;\n\t\tconst length = faces.length;\n\n\t\t// tag faces\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tfaces[ i ]._id = i;\n\n\t\t}\n\n\t\t// sort faces\n\n\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t}\n\n\t\tfaces.sort( materialIndexSort );\n\n\t\t// sort uvs\n\n\t\tconst uvs1 = this.faceVertexUvs[ 0 ];\n\t\tconst uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\tlet newUvs1, newUvs2;\n\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst id = faces[ i ]._id;\n\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t}\n\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Geometry',\n\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Geometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tconst vertices = [];\n\n\t\tfor ( let i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tconst faces = [];\n\t\tconst normals = [];\n\t\tconst normalsHash = {};\n\t\tconst colors = [];\n\t\tconst colorsHash = {};\n\t\tconst uvs = [];\n\t\tconst uvsHash = {};\n\n\t\tfor ( let i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tconst hasMaterial = true;\n\t\t\tconst hasFaceUv = false; // deprecated\n\t\t\tconst hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\tconst hasFaceNormal = face.normal.length() > 0;\n\t\t\tconst hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\tconst hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\tconst hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\tlet faceType = 0;\n\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\tfaces.push( faceType );\n\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\tfaces.push( face.materialIndex );\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tconst faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tconst vertexColors = face.vertexColors;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t}\n\n\t\tfunction getNormalIndex( normal ) {\n\n\t\t\tconst hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\treturn normalsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getColorIndex( color ) {\n\n\t\t\tconst hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\tcolors.push( color.getHex() );\n\n\t\t\treturn colorsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getUvIndex( uv ) {\n\n\t\t\tconst hash = uv.x.toString() + uv.y.toString();\n\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\treturn uvsHash[ hash ];\n\n\t\t}\n\n\t\tdata.data = {};\n\n\t\tdata.data.vertices = vertices;\n\t\tdata.data.normals = normals;\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\tdata.data.faces = faces;\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t const parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t const values = [];\n\n\t\t for ( const key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new Geometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\t// reset\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [[]];\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\t\tthis.lineDistances = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// vertices\n\n\t\tconst vertices = source.vertices;\n\n\t\tfor ( let i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\t// colors\n\n\t\tconst colors = source.colors;\n\n\t\tfor ( let i = 0, il = colors.length; i < il; i ++ ) {\n\n\t\t\tthis.colors.push( colors[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tconst faces = source.faces;\n\n\t\tfor ( let i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\t// face vertex uvs\n\n\t\tfor ( let i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tconst faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( let k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\tconst uv = uvs[ k ];\n\n\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tconst morphTargets = source.morphTargets;\n\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = {};\n\t\t\tmorphTarget.name = morphTargets[ i ].name;\n\n\t\t\t// vertices\n\n\t\t\tif ( morphTargets[ i ].vertices !== undefined ) {\n\n\t\t\t\tmorphTarget.vertices = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( morphTargets[ i ].normals !== undefined ) {\n\n\t\t\t\tmorphTarget.normals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.push( morphTarget );\n\n\t\t}\n\n\t\t// morph normals\n\n\t\tconst morphNormals = source.morphNormals;\n\n\t\tfor ( let i = 0, il = morphNormals.length; i < il; i ++ ) {\n\n\t\t\tconst morphNormal = {};\n\n\t\t\t// vertex normals\n\n\t\t\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.vertexNormals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\n\t\t\t\t\tconst destVertexNormal = {};\n\n\t\t\t\t\tdestVertexNormal.a = srcVertexNormal.a.clone();\n\t\t\t\t\tdestVertexNormal.b = srcVertexNormal.b.clone();\n\t\t\t\t\tdestVertexNormal.c = srcVertexNormal.c.clone();\n\n\t\t\t\t\tmorphNormal.vertexNormals.push( destVertexNormal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// face normals\n\n\t\t\tif ( morphNormals[ i ].faceNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.faceNormals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphNormals.push( morphNormal );\n\n\t\t}\n\n\t\t// skin weights\n\n\t\tconst skinWeights = source.skinWeights;\n\n\t\tfor ( let i = 0, il = skinWeights.length; i < il; i ++ ) {\n\n\t\t\tthis.skinWeights.push( skinWeights[ i ].clone() );\n\n\t\t}\n\n\t\t// skin indices\n\n\t\tconst skinIndices = source.skinIndices;\n\n\t\tfor ( let i = 0, il = skinIndices.length; i < il; i ++ ) {\n\n\t\t\tthis.skinIndices.push( skinIndices[ i ].clone() );\n\n\t\t}\n\n\t\t// line distances\n\n\t\tconst lineDistances = source.lineDistances;\n\n\t\tfor ( let i = 0, il = lineDistances.length; i < il; i ++ ) {\n\n\t\t\tthis.lineDistances.push( lineDistances[ i ] );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\n\t\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\n\t\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\n\t\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\n\t\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n\t\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n\nexport { Geometry };\n"]},"metadata":{},"sourceType":"module"}