{"ast":null,"code":"import { Mesh } from '../objects/Mesh.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { SphereBufferGeometry } from '../geometries/SphereBufferGeometry.js';\n\nclass PointLightHelper extends Mesh {\n  constructor(light, sphereSize, color) {\n    var geometry = new SphereBufferGeometry(sphereSize, 4, 2);\n    var material = new MeshBasicMaterial({\n      wireframe: true,\n      fog: false,\n      toneMapped: false\n    });\n    super(geometry, material);\n    this.light = light;\n    this.light.updateMatrixWorld();\n    this.color = color;\n    this.type = 'PointLightHelper';\n    this.matrix = this.light.matrixWorld;\n    this.matrixAutoUpdate = false;\n    this.update();\n    /*\n    // TODO: delete this comment?\n    const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );\n    const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n    this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n    this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n    const d = light.distance;\n    if ( d === 0.0 ) {\n    \tthis.lightDistance.visible = false;\n    } else {\n    \tthis.lightDistance.scale.set( d, d, d );\n    }\n    this.add( this.lightDistance );\n    */\n  }\n\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n\n  update() {\n    if (this.color !== undefined) {\n      this.material.color.set(this.color);\n    } else {\n      this.material.color.copy(this.light.color);\n    }\n    /*\n    const d = this.light.distance;\n    \tif ( d === 0.0 ) {\n    \t\tthis.lightDistance.visible = false;\n    \t} else {\n    \t\tthis.lightDistance.visible = true;\n    \tthis.lightDistance.scale.set( d, d, d );\n    \t}\n    */\n\n  }\n\n}\n\nexport { PointLightHelper };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/helpers/PointLightHelper.js"],"names":["Mesh","MeshBasicMaterial","SphereBufferGeometry","PointLightHelper","constructor","light","sphereSize","color","geometry","material","wireframe","fog","toneMapped","updateMatrixWorld","type","matrix","matrixWorld","matrixAutoUpdate","update","dispose","undefined","set","copy"],"mappings":"AAAA,SAASA,IAAT,QAAqB,oBAArB;AACA,SAASC,iBAAT,QAAkC,mCAAlC;AACA,SAASC,oBAAT,QAAqC,uCAArC;;AAEA,MAAMC,gBAAN,SAA+BH,IAA/B,CAAoC;AAEnCI,EAAAA,WAAW,CAAEC,KAAF,EAASC,UAAT,EAAqBC,KAArB,EAA6B;AAEvC,QAAMC,QAAQ,GAAG,IAAIN,oBAAJ,CAA0BI,UAA1B,EAAsC,CAAtC,EAAyC,CAAzC,CAAjB;AACA,QAAMG,QAAQ,GAAG,IAAIR,iBAAJ,CAAuB;AAAES,MAAAA,SAAS,EAAE,IAAb;AAAmBC,MAAAA,GAAG,EAAE,KAAxB;AAA+BC,MAAAA,UAAU,EAAE;AAA3C,KAAvB,CAAjB;AAEA,UAAOJ,QAAP,EAAiBC,QAAjB;AAEA,SAAKJ,KAAL,GAAaA,KAAb;AACA,SAAKA,KAAL,CAAWQ,iBAAX;AAEA,SAAKN,KAAL,GAAaA,KAAb;AAEA,SAAKO,IAAL,GAAY,kBAAZ;AAEA,SAAKC,MAAL,GAAc,KAAKV,KAAL,CAAWW,WAAzB;AACA,SAAKC,gBAAL,GAAwB,KAAxB;AAEA,SAAKC,MAAL;AAGA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUE;;AAEDC,EAAAA,OAAO,GAAG;AAET,SAAKX,QAAL,CAAcW,OAAd;AACA,SAAKV,QAAL,CAAcU,OAAd;AAEA;;AAEDD,EAAAA,MAAM,GAAG;AAER,QAAK,KAAKX,KAAL,KAAea,SAApB,EAAgC;AAE/B,WAAKX,QAAL,CAAcF,KAAd,CAAoBc,GAApB,CAAyB,KAAKd,KAA9B;AAEA,KAJD,MAIO;AAEN,WAAKE,QAAL,CAAcF,KAAd,CAAoBe,IAApB,CAA0B,KAAKjB,KAAL,CAAWE,KAArC;AAEA;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAOE;;AAjFkC;;AAsFpC,SAASJ,gBAAT","sourcesContent":["import { Mesh } from '../objects/Mesh.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { SphereBufferGeometry } from '../geometries/SphereBufferGeometry.js';\n\nclass PointLightHelper extends Mesh {\n\n\tconstructor( light, sphereSize, color ) {\n\n\t\tconst geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\n\t\tconst material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'PointLightHelper';\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\n\t\t/*\n\t// TODO: delete this comment?\n\tconst distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );\n\tconst distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tconst d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\t/*\n\t\tconst d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t}\n\n}\n\n\nexport { PointLightHelper };\n"]},"metadata":{},"sourceType":"module"}