{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\n\nclass ShapeBufferGeometry extends BufferGeometry {\n  constructor(shapes, curveSegments) {\n    super();\n    this.type = 'ShapeBufferGeometry';\n    this.parameters = {\n      shapes: shapes,\n      curveSegments: curveSegments\n    };\n    curveSegments = curveSegments || 12; // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helper variables\n\n    var groupStart = 0;\n    var groupCount = 0; // allow single and array values for \"shapes\" parameter\n\n    if (Array.isArray(shapes) === false) {\n      addShape(shapes);\n    } else {\n      for (var i = 0; i < shapes.length; i++) {\n        addShape(shapes[i]);\n        this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support\n\n        groupStart += groupCount;\n        groupCount = 0;\n      }\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions\n\n    function addShape(shape) {\n      var indexOffset = vertices.length / 3;\n      var points = shape.extractPoints(curveSegments);\n      var shapeVertices = points.shape;\n      var shapeHoles = points.holes; // check direction of vertices\n\n      if (ShapeUtils.isClockWise(shapeVertices) === false) {\n        shapeVertices = shapeVertices.reverse();\n      }\n\n      for (var _i = 0, l = shapeHoles.length; _i < l; _i++) {\n        var shapeHole = shapeHoles[_i];\n\n        if (ShapeUtils.isClockWise(shapeHole) === true) {\n          shapeHoles[_i] = shapeHole.reverse();\n        }\n      }\n\n      var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array\n\n      for (var _i2 = 0, _l = shapeHoles.length; _i2 < _l; _i2++) {\n        var _shapeHole = shapeHoles[_i2];\n        shapeVertices = shapeVertices.concat(_shapeHole);\n      } // vertices, normals, uvs\n\n\n      for (var _i3 = 0, _l2 = shapeVertices.length; _i3 < _l2; _i3++) {\n        var vertex = shapeVertices[_i3];\n        vertices.push(vertex.x, vertex.y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(vertex.x, vertex.y); // world uvs\n      } // incides\n\n\n      for (var _i4 = 0, _l3 = faces.length; _i4 < _l3; _i4++) {\n        var face = faces[_i4];\n        var a = face[0] + indexOffset;\n        var b = face[1] + indexOffset;\n        var c = face[2] + indexOffset;\n        indices.push(a, b, c);\n        groupCount += 3;\n      }\n    }\n  }\n\n  toJSON() {\n    var data = BufferGeometry.prototype.toJSON.call(this);\n    var shapes = this.parameters.shapes;\n    return toJSON(shapes, data);\n  }\n\n}\n\nfunction toJSON(shapes, data) {\n  data.shapes = [];\n\n  if (Array.isArray(shapes)) {\n    for (var i = 0, l = shapes.length; i < l; i++) {\n      var shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n\n  return data;\n}\n\nexport { ShapeBufferGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/ShapeBufferGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","ShapeUtils","ShapeBufferGeometry","constructor","shapes","curveSegments","type","parameters","indices","vertices","normals","uvs","groupStart","groupCount","Array","isArray","addShape","i","length","addGroup","setIndex","setAttribute","shape","indexOffset","points","extractPoints","shapeVertices","shapeHoles","holes","isClockWise","reverse","l","shapeHole","faces","triangulateShape","concat","vertex","push","x","y","face","a","b","c","toJSON","data","prototype","call","uuid"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\n\nclass ShapeBufferGeometry extends BufferGeometry {\n\n\tconstructor( shapes, curveSegments ) {\n\n\t\tsuper();\n\t\tthis.type = 'ShapeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\tcurveSegments: curveSegments\n\t\t};\n\n\t\tcurveSegments = curveSegments || 12;\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet groupStart = 0;\n\t\tlet groupCount = 0;\n\n\t\t// allow single and array values for \"shapes\" parameter\n\n\t\tif ( Array.isArray( shapes ) === false ) {\n\n\t\t\taddShape( shapes );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\taddShape( shapes[ i ] );\n\n\t\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t\tgroupCount = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t// helper functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst indexOffset = vertices.length / 3;\n\t\t\tconst points = shape.extractPoints( curveSegments );\n\n\t\t\tlet shapeVertices = points.shape;\n\t\t\tconst shapeHoles = points.holes;\n\n\t\t\t// check direction of vertices\n\n\t\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n\t\t\t\tshapeVertices = shapeVertices.reverse();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n\t\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n\t\t\t// join vertices of inner and outer paths to a single array\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\t\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\n\t\t\t}\n\n\t\t\t// vertices, normals, uvs\n\n\t\t\tfor ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n\t\t\t\tconst vertex = shapeVertices[ i ];\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\t\tnormals.push( 0, 0, 1 );\n\t\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\n\t\t\t}\n\n\t\t\t// incides\n\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\tconst a = face[ 0 ] + indexOffset;\n\t\t\t\tconst b = face[ 1 ] + indexOffset;\n\t\t\t\tconst c = face[ 2 ] + indexOffset;\n\n\t\t\t\tindices.push( a, b, c );\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = BufferGeometry.prototype.toJSON.call( this );\n\n\t\tconst shapes = this.parameters.shapes;\n\n\t\treturn toJSON( shapes, data );\n\n\t}\n\n}\n\nfunction toJSON( shapes, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\treturn data;\n\n}\n\nexport { ShapeBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}