{"ast":null,"code":"import { Matrix4 } from '../math/Matrix4.js';\n\nvar _offsetMatrix = new Matrix4();\n\nvar _identityMatrix = new Matrix4();\n\nfunction Skeleton(bones, boneInverses) {\n  // copy the bone array\n  bones = bones || [];\n  this.bones = bones.slice(0);\n  this.boneMatrices = new Float32Array(this.bones.length * 16);\n  this.frame = -1; // use the supplied bone inverses or calculate the inverses\n\n  if (boneInverses === undefined) {\n    this.calculateInverses();\n  } else {\n    if (this.bones.length === boneInverses.length) {\n      this.boneInverses = boneInverses.slice(0);\n    } else {\n      console.warn('THREE.Skeleton boneInverses is the wrong length.');\n      this.boneInverses = [];\n\n      for (var i = 0, il = this.bones.length; i < il; i++) {\n        this.boneInverses.push(new Matrix4());\n      }\n    }\n  }\n}\n\nObject.assign(Skeleton.prototype, {\n  calculateInverses: function calculateInverses() {\n    this.boneInverses = [];\n\n    for (var i = 0, il = this.bones.length; i < il; i++) {\n      var inverse = new Matrix4();\n\n      if (this.bones[i]) {\n        inverse.getInverse(this.bones[i].matrixWorld);\n      }\n\n      this.boneInverses.push(inverse);\n    }\n  },\n  pose: function pose() {\n    // recover the bind-time world matrices\n    for (var i = 0, il = this.bones.length; i < il; i++) {\n      var bone = this.bones[i];\n\n      if (bone) {\n        bone.matrixWorld.getInverse(this.boneInverses[i]);\n      }\n    } // compute the local matrices, positions, rotations and scales\n\n\n    for (var _i = 0, _il = this.bones.length; _i < _il; _i++) {\n      var _bone = this.bones[_i];\n\n      if (_bone) {\n        if (_bone.parent && _bone.parent.isBone) {\n          _bone.matrix.getInverse(_bone.parent.matrixWorld);\n\n          _bone.matrix.multiply(_bone.matrixWorld);\n        } else {\n          _bone.matrix.copy(_bone.matrixWorld);\n        }\n\n        _bone.matrix.decompose(_bone.position, _bone.quaternion, _bone.scale);\n      }\n    }\n  },\n  update: function update() {\n    var bones = this.bones;\n    var boneInverses = this.boneInverses;\n    var boneMatrices = this.boneMatrices;\n    var boneTexture = this.boneTexture; // flatten bone matrices to array\n\n    for (var i = 0, il = bones.length; i < il; i++) {\n      // compute the offset between the current and the original transform\n      var matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;\n\n      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);\n\n      _offsetMatrix.toArray(boneMatrices, i * 16);\n    }\n\n    if (boneTexture !== undefined) {\n      boneTexture.needsUpdate = true;\n    }\n  },\n  clone: function clone() {\n    return new Skeleton(this.bones, this.boneInverses);\n  },\n  getBoneByName: function getBoneByName(name) {\n    for (var i = 0, il = this.bones.length; i < il; i++) {\n      var bone = this.bones[i];\n\n      if (bone.name === name) {\n        return bone;\n      }\n    }\n\n    return undefined;\n  },\n  dispose: function dispose() {\n    if (this.boneTexture) {\n      this.boneTexture.dispose();\n      this.boneTexture = undefined;\n    }\n  }\n});\nexport { Skeleton };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/objects/Skeleton.js"],"names":["Matrix4","_offsetMatrix","_identityMatrix","Skeleton","bones","boneInverses","slice","boneMatrices","Float32Array","length","frame","undefined","calculateInverses","console","warn","i","il","push","Object","assign","prototype","inverse","getInverse","matrixWorld","pose","bone","parent","isBone","matrix","multiply","copy","decompose","position","quaternion","scale","update","boneTexture","multiplyMatrices","toArray","needsUpdate","clone","getBoneByName","name","dispose"],"mappings":"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","sourcesContent":["import { Matrix4 } from '../math/Matrix4.js';\n\nconst _offsetMatrix = new Matrix4();\nconst _identityMatrix = new Matrix4();\n\nfunction Skeleton( bones, boneInverses ) {\n\n\t// copy the bone array\n\n\tbones = bones || [];\n\n\tthis.bones = bones.slice( 0 );\n\tthis.boneMatrices = new Float32Array( this.bones.length * 16 );\n\n\tthis.frame = - 1;\n\n\t// use the supplied bone inverses or calculate the inverses\n\n\tif ( boneInverses === undefined ) {\n\n\t\tthis.calculateInverses();\n\n\t} else {\n\n\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Skeleton boneInverses is the wrong length.' );\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nObject.assign( Skeleton.prototype, {\n\n\tcalculateInverses: function () {\n\n\t\tthis.boneInverses = [];\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst inverse = new Matrix4();\n\n\t\t\tif ( this.bones[ i ] ) {\n\n\t\t\t\tinverse.getInverse( this.bones[ i ].matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t},\n\n\tpose: function () {\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdate: function () {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\t\tconst boneMatrices = this.boneMatrices;\n\t\tconst boneTexture = this.boneTexture;\n\n\t\t// flatten bone matrices to array\n\n\t\tfor ( let i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t// compute the offset between the current and the original transform\n\n\t\t\tconst matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;\n\n\t\t\t_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t_offsetMatrix.toArray( boneMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( boneTexture !== undefined ) {\n\n\t\t\tboneTexture.needsUpdate = true;\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new Skeleton( this.bones, this.boneInverses );\n\n\t},\n\n\tgetBoneByName: function ( name ) {\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone.name === name ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tdispose: function ( ) {\n\n\t\tif ( this.boneTexture ) {\n\n\t\t\tthis.boneTexture.dispose();\n\n\t\t\tthis.boneTexture = undefined;\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { Skeleton };\n"]},"metadata":{},"sourceType":"module"}