{"ast":null,"code":"/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\nimport { Geometry } from '../core/Geometry.js';\nimport { ExtrudeBufferGeometry } from './ExtrudeBufferGeometry.js';\n\nclass ExtrudeGeometry extends Geometry {\n  constructor(shapes, options) {\n    super();\n    this.type = 'ExtrudeGeometry';\n    this.parameters = {\n      shapes: shapes,\n      options: options\n    };\n    this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));\n    this.mergeVertices();\n  }\n\n  toJSON() {\n    var data = super.toJSON();\n    var shapes = this.parameters.shapes;\n    var options = this.parameters.options;\n    return toJSON(shapes, options, data);\n  }\n\n}\n\nfunction toJSON(shapes, options, data) {\n  data.shapes = [];\n\n  if (Array.isArray(shapes)) {\n    for (var i = 0, l = shapes.length; i < l; i++) {\n      var shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n\n  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();\n  return data;\n}\n\nexport { ExtrudeGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/ExtrudeGeometry.js"],"names":["Geometry","ExtrudeBufferGeometry","ExtrudeGeometry","constructor","shapes","options","type","parameters","fromBufferGeometry","mergeVertices","toJSON","data","Array","isArray","i","l","length","shape","push","uuid","extrudePath","undefined"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,QAAT,QAAyB,qBAAzB;AACA,SAASC,qBAAT,QAAsC,4BAAtC;;AAEA,MAAMC,eAAN,SAA8BF,QAA9B,CAAuC;AAEtCG,EAAAA,WAAW,CAAEC,MAAF,EAAUC,OAAV,EAAoB;AAE9B;AAEA,SAAKC,IAAL,GAAY,iBAAZ;AAEA,SAAKC,UAAL,GAAkB;AACjBH,MAAAA,MAAM,EAAEA,MADS;AAEjBC,MAAAA,OAAO,EAAEA;AAFQ,KAAlB;AAKA,SAAKG,kBAAL,CAAyB,IAAIP,qBAAJ,CAA2BG,MAA3B,EAAmCC,OAAnC,CAAzB;AACA,SAAKI,aAAL;AAEA;;AAEDC,EAAAA,MAAM,GAAG;AAER,QAAMC,IAAI,GAAG,MAAMD,MAAN,EAAb;AAEA,QAAMN,MAAM,GAAG,KAAKG,UAAL,CAAgBH,MAA/B;AACA,QAAMC,OAAO,GAAG,KAAKE,UAAL,CAAgBF,OAAhC;AAEA,WAAOK,MAAM,CAAEN,MAAF,EAAUC,OAAV,EAAmBM,IAAnB,CAAb;AAEA;;AA3BqC;;AA+BvC,SAASD,MAAT,CAAiBN,MAAjB,EAAyBC,OAAzB,EAAkCM,IAAlC,EAAyC;AAExCA,EAAAA,IAAI,CAACP,MAAL,GAAc,EAAd;;AAEA,MAAKQ,KAAK,CAACC,OAAN,CAAeT,MAAf,CAAL,EAA+B;AAE9B,SAAM,IAAIU,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGX,MAAM,CAACY,MAA5B,EAAoCF,CAAC,GAAGC,CAAxC,EAA2CD,CAAC,EAA5C,EAAkD;AAEjD,UAAMG,KAAK,GAAGb,MAAM,CAAEU,CAAF,CAApB;AAEAH,MAAAA,IAAI,CAACP,MAAL,CAAYc,IAAZ,CAAkBD,KAAK,CAACE,IAAxB;AAEA;AAED,GAVD,MAUO;AAENR,IAAAA,IAAI,CAACP,MAAL,CAAYc,IAAZ,CAAkBd,MAAM,CAACe,IAAzB;AAEA;;AAED,MAAKd,OAAO,CAACe,WAAR,KAAwBC,SAA7B,EAAyCV,IAAI,CAACN,OAAL,CAAae,WAAb,GAA2Bf,OAAO,CAACe,WAAR,CAAoBV,MAApB,EAA3B;AAEzC,SAAOC,IAAP;AAEA;;AAED,SAAST,eAAT","sourcesContent":["/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\nimport { Geometry } from '../core/Geometry.js';\nimport { ExtrudeBufferGeometry } from './ExtrudeBufferGeometry.js';\n\nclass ExtrudeGeometry extends Geometry {\n\n\tconstructor( shapes, options ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\toptions: options\n\t\t};\n\n\t\tthis.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\t\tconst options = this.parameters.options;\n\n\t\treturn toJSON( shapes, options, data );\n\n\t}\n\n}\n\nfunction toJSON( shapes, options, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\nexport { ExtrudeGeometry };\n"]},"metadata":{},"sourceType":"module"}