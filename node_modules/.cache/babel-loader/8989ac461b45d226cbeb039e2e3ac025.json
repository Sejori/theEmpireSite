{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass PolyhedronBufferGeometry extends BufferGeometry {\n  constructor(vertices, indices, radius, detail) {\n    super();\n    this.type = 'PolyhedronBufferGeometry';\n    this.parameters = {\n      vertices: vertices,\n      indices: indices,\n      radius: radius,\n      detail: detail\n    };\n    radius = radius || 1;\n    detail = detail || 0; // default buffer data\n\n    var vertexBuffer = [];\n    var uvBuffer = []; // the subdivision creates the vertex buffer data\n\n    subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius\n\n    applyRadius(radius); // finally, create the uv data\n\n    generateUVs(); // build non-indexed geometry\n\n    this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));\n\n    if (detail === 0) {\n      this.computeVertexNormals(); // flat normals\n    } else {\n      this.normalizeNormals(); // smooth normals\n    } // helper functions\n\n\n    function subdivide(detail) {\n      var a = new Vector3();\n      var b = new Vector3();\n      var c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value\n\n      for (var i = 0; i < indices.length; i += 3) {\n        // get the vertices of the face\n        getVertexByIndex(indices[i + 0], a);\n        getVertexByIndex(indices[i + 1], b);\n        getVertexByIndex(indices[i + 2], c); // perform subdivision\n\n        subdivideFace(a, b, c, detail);\n      }\n    }\n\n    function subdivideFace(a, b, c, detail) {\n      var cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision\n\n      var v = []; // construct all of the vertices for this subdivision\n\n      for (var i = 0; i <= cols; i++) {\n        v[i] = [];\n        var aj = a.clone().lerp(c, i / cols);\n        var bj = b.clone().lerp(c, i / cols);\n        var rows = cols - i;\n\n        for (var j = 0; j <= rows; j++) {\n          if (j === 0 && i === cols) {\n            v[i][j] = aj;\n          } else {\n            v[i][j] = aj.clone().lerp(bj, j / rows);\n          }\n        }\n      } // construct all of the faces\n\n\n      for (var _i = 0; _i < cols; _i++) {\n        for (var _j = 0; _j < 2 * (cols - _i) - 1; _j++) {\n          var k = Math.floor(_j / 2);\n\n          if (_j % 2 === 0) {\n            pushVertex(v[_i][k + 1]);\n            pushVertex(v[_i + 1][k]);\n            pushVertex(v[_i][k]);\n          } else {\n            pushVertex(v[_i][k + 1]);\n            pushVertex(v[_i + 1][k + 1]);\n            pushVertex(v[_i + 1][k]);\n          }\n        }\n      }\n    }\n\n    function applyRadius(radius) {\n      var vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex\n\n      for (var i = 0; i < vertexBuffer.length; i += 3) {\n        vertex.x = vertexBuffer[i + 0];\n        vertex.y = vertexBuffer[i + 1];\n        vertex.z = vertexBuffer[i + 2];\n        vertex.normalize().multiplyScalar(radius);\n        vertexBuffer[i + 0] = vertex.x;\n        vertexBuffer[i + 1] = vertex.y;\n        vertexBuffer[i + 2] = vertex.z;\n      }\n    }\n\n    function generateUVs() {\n      var vertex = new Vector3();\n\n      for (var i = 0; i < vertexBuffer.length; i += 3) {\n        vertex.x = vertexBuffer[i + 0];\n        vertex.y = vertexBuffer[i + 1];\n        vertex.z = vertexBuffer[i + 2];\n        var u = azimuth(vertex) / 2 / Math.PI + 0.5;\n        var v = inclination(vertex) / Math.PI + 0.5;\n        uvBuffer.push(u, 1 - v);\n      }\n\n      correctUVs();\n      correctSeam();\n    }\n\n    function correctSeam() {\n      // handle case when face straddles the seam, see #3269\n      for (var i = 0; i < uvBuffer.length; i += 6) {\n        // uv data of a single face\n        var x0 = uvBuffer[i + 0];\n        var x1 = uvBuffer[i + 2];\n        var x2 = uvBuffer[i + 4];\n        var max = Math.max(x0, x1, x2);\n        var min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary\n\n        if (max > 0.9 && min < 0.1) {\n          if (x0 < 0.2) uvBuffer[i + 0] += 1;\n          if (x1 < 0.2) uvBuffer[i + 2] += 1;\n          if (x2 < 0.2) uvBuffer[i + 4] += 1;\n        }\n      }\n    }\n\n    function pushVertex(vertex) {\n      vertexBuffer.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    function getVertexByIndex(index, vertex) {\n      var stride = index * 3;\n      vertex.x = vertices[stride + 0];\n      vertex.y = vertices[stride + 1];\n      vertex.z = vertices[stride + 2];\n    }\n\n    function correctUVs() {\n      var a = new Vector3();\n      var b = new Vector3();\n      var c = new Vector3();\n      var centroid = new Vector3();\n      var uvA = new Vector2();\n      var uvB = new Vector2();\n      var uvC = new Vector2();\n\n      for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {\n        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);\n        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);\n        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);\n        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);\n        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);\n        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);\n        centroid.copy(a).add(b).add(c).divideScalar(3);\n        var azi = azimuth(centroid);\n        correctUV(uvA, j + 0, a, azi);\n        correctUV(uvB, j + 2, b, azi);\n        correctUV(uvC, j + 4, c, azi);\n      }\n    }\n\n    function correctUV(uv, stride, vector, azimuth) {\n      if (azimuth < 0 && uv.x === 1) {\n        uvBuffer[stride] = uv.x - 1;\n      }\n\n      if (vector.x === 0 && vector.z === 0) {\n        uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;\n      }\n    } // Angle around the Y axis, counter-clockwise when looking from above.\n\n\n    function azimuth(vector) {\n      return Math.atan2(vector.z, -vector.x);\n    } // Angle above the XZ plane.\n\n\n    function inclination(vector) {\n      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n    }\n  }\n\n}\n\nexport { PolyhedronBufferGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/PolyhedronBufferGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","Vector2","PolyhedronBufferGeometry","constructor","vertices","indices","radius","detail","type","parameters","vertexBuffer","uvBuffer","subdivide","applyRadius","generateUVs","setAttribute","slice","computeVertexNormals","normalizeNormals","a","b","c","i","length","getVertexByIndex","subdivideFace","cols","v","aj","clone","lerp","bj","rows","j","k","Math","floor","pushVertex","vertex","x","y","z","normalize","multiplyScalar","u","azimuth","PI","inclination","push","correctUVs","correctSeam","x0","x1","x2","max","min","index","stride","centroid","uvA","uvB","uvC","set","copy","add","divideScalar","azi","correctUV","uv","vector","atan2","sqrt"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass PolyhedronBufferGeometry extends BufferGeometry {\n\n\tconstructor( vertices, indices, radius, detail ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PolyhedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\tradius = radius || 1;\n\t\tdetail = detail || 0;\n\n\t\t// default buffer data\n\n\t\tconst vertexBuffer = [];\n\t\tconst uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tapplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\t\tif ( detail === 0 ) {\n\n\t\t\tthis.computeVertexNormals(); // flat normals\n\n\t\t} else {\n\n\t\t\tthis.normalizeNormals(); // smooth normals\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\n\t\t\tfor ( let i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tconst cols = detail + 1;\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tconst v = [];\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( let i = 0; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tconst aj = a.clone().lerp( c, i / cols );\n\t\t\t\tconst bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tconst rows = cols - i;\n\n\t\t\t\tfor ( let j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( let i = 0; i < cols; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tconst k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction applyRadius( radius ) {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tconst u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tconst v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( let i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tconst x0 = uvBuffer[ i + 0 ];\n\t\t\t\tconst x1 = uvBuffer[ i + 2 ];\n\t\t\t\tconst x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tconst max = Math.max( x0, x1, x2 );\n\t\t\t\tconst min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tconst stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\tconst centroid = new Vector3();\n\n\t\t\tconst uvA = new Vector2();\n\t\t\tconst uvB = new Vector2();\n\t\t\tconst uvC = new Vector2();\n\n\t\t\tfor ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tconst azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n}\n\nexport { PolyhedronBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}