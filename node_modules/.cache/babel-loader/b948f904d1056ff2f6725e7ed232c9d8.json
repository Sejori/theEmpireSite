{"ast":null,"code":"import { InterpolateLinear, InterpolateSmooth, InterpolateDiscrete } from '../constants.js';\nimport { CubicInterpolant } from '../math/interpolants/CubicInterpolant.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { DiscreteInterpolant } from '../math/interpolants/DiscreteInterpolant.js';\nimport { AnimationUtils } from './AnimationUtils.js';\n\nfunction KeyframeTrack(name, times, values, interpolation) {\n  if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');\n  if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);\n  this.name = name;\n  this.times = AnimationUtils.convertArray(times, this.TimeBufferType);\n  this.values = AnimationUtils.convertArray(values, this.ValueBufferType);\n  this.setInterpolation(interpolation || this.DefaultInterpolation);\n} // Static methods\n\n\nObject.assign(KeyframeTrack, {\n  // Serialization (in static context, because of constructor invocation\n  // and automatic invocation of .toJSON):\n  toJSON: function toJSON(track) {\n    var trackType = track.constructor;\n    var json; // derived classes can define a static toJSON method\n\n    if (trackType.toJSON !== undefined) {\n      json = trackType.toJSON(track);\n    } else {\n      // by default, we assume the data can be serialized as-is\n      json = {\n        'name': track.name,\n        'times': AnimationUtils.convertArray(track.times, Array),\n        'values': AnimationUtils.convertArray(track.values, Array)\n      };\n      var interpolation = track.getInterpolation();\n\n      if (interpolation !== track.DefaultInterpolation) {\n        json.interpolation = interpolation;\n      }\n    }\n\n    json.type = track.ValueTypeName; // mandatory\n\n    return json;\n  }\n});\nObject.assign(KeyframeTrack.prototype, {\n  constructor: KeyframeTrack,\n  TimeBufferType: Float32Array,\n  ValueBufferType: Float32Array,\n  DefaultInterpolation: InterpolateLinear,\n  InterpolantFactoryMethodDiscrete: function InterpolantFactoryMethodDiscrete(result) {\n    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);\n  },\n  InterpolantFactoryMethodLinear: function InterpolantFactoryMethodLinear(result) {\n    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);\n  },\n  InterpolantFactoryMethodSmooth: function InterpolantFactoryMethodSmooth(result) {\n    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);\n  },\n  setInterpolation: function setInterpolation(interpolation) {\n    var factoryMethod;\n\n    switch (interpolation) {\n      case InterpolateDiscrete:\n        factoryMethod = this.InterpolantFactoryMethodDiscrete;\n        break;\n\n      case InterpolateLinear:\n        factoryMethod = this.InterpolantFactoryMethodLinear;\n        break;\n\n      case InterpolateSmooth:\n        factoryMethod = this.InterpolantFactoryMethodSmooth;\n        break;\n    }\n\n    if (factoryMethod === undefined) {\n      var message = \"unsupported interpolation for \" + this.ValueTypeName + \" keyframe track named \" + this.name;\n\n      if (this.createInterpolant === undefined) {\n        // fall back to default, unless the default itself is messed up\n        if (interpolation !== this.DefaultInterpolation) {\n          this.setInterpolation(this.DefaultInterpolation);\n        } else {\n          throw new Error(message); // fatal, in this case\n        }\n      }\n\n      console.warn('THREE.KeyframeTrack:', message);\n      return this;\n    }\n\n    this.createInterpolant = factoryMethod;\n    return this;\n  },\n  getInterpolation: function getInterpolation() {\n    switch (this.createInterpolant) {\n      case this.InterpolantFactoryMethodDiscrete:\n        return InterpolateDiscrete;\n\n      case this.InterpolantFactoryMethodLinear:\n        return InterpolateLinear;\n\n      case this.InterpolantFactoryMethodSmooth:\n        return InterpolateSmooth;\n    }\n  },\n  getValueSize: function getValueSize() {\n    return this.values.length / this.times.length;\n  },\n  // move all keyframes either forwards or backwards in time\n  shift: function shift(timeOffset) {\n    if (timeOffset !== 0.0) {\n      var times = this.times;\n\n      for (var i = 0, n = times.length; i !== n; ++i) {\n        times[i] += timeOffset;\n      }\n    }\n\n    return this;\n  },\n  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n  scale: function scale(timeScale) {\n    if (timeScale !== 1.0) {\n      var times = this.times;\n\n      for (var i = 0, n = times.length; i !== n; ++i) {\n        times[i] *= timeScale;\n      }\n    }\n\n    return this;\n  },\n  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n  trim: function trim(startTime, endTime) {\n    var times = this.times,\n        nKeys = times.length;\n    var from = 0,\n        to = nKeys - 1;\n\n    while (from !== nKeys && times[from] < startTime) {\n      ++from;\n    }\n\n    while (to !== -1 && times[to] > endTime) {\n      --to;\n    }\n\n    ++to; // inclusive -> exclusive bound\n\n    if (from !== 0 || to !== nKeys) {\n      // empty tracks are forbidden, so keep at least one keyframe\n      if (from >= to) {\n        to = Math.max(to, 1);\n        from = to - 1;\n      }\n\n      var stride = this.getValueSize();\n      this.times = AnimationUtils.arraySlice(times, from, to);\n      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);\n    }\n\n    return this;\n  },\n  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n  validate: function validate() {\n    var valid = true;\n    var valueSize = this.getValueSize();\n\n    if (valueSize - Math.floor(valueSize) !== 0) {\n      console.error('THREE.KeyframeTrack: Invalid value size in track.', this);\n      valid = false;\n    }\n\n    var times = this.times,\n        values = this.values,\n        nKeys = times.length;\n\n    if (nKeys === 0) {\n      console.error('THREE.KeyframeTrack: Track is empty.', this);\n      valid = false;\n    }\n\n    var prevTime = null;\n\n    for (var i = 0; i !== nKeys; i++) {\n      var currTime = times[i];\n\n      if (typeof currTime === 'number' && isNaN(currTime)) {\n        console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);\n        valid = false;\n        break;\n      }\n\n      if (prevTime !== null && prevTime > currTime) {\n        console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);\n        valid = false;\n        break;\n      }\n\n      prevTime = currTime;\n    }\n\n    if (values !== undefined) {\n      if (AnimationUtils.isTypedArray(values)) {\n        for (var _i = 0, n = values.length; _i !== n; ++_i) {\n          var value = values[_i];\n\n          if (isNaN(value)) {\n            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, _i, value);\n            valid = false;\n            break;\n          }\n        }\n      }\n    }\n\n    return valid;\n  },\n  // removes equivalent sequential keys as common in morph target sequences\n  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n  optimize: function optimize() {\n    // times or values may be shared with other tracks, so overwriting is unsafe\n    var times = AnimationUtils.arraySlice(this.times),\n        values = AnimationUtils.arraySlice(this.values),\n        stride = this.getValueSize(),\n        smoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n        lastIndex = times.length - 1;\n    var writeIndex = 1;\n\n    for (var i = 1; i < lastIndex; ++i) {\n      var keep = false;\n      var time = times[i];\n      var timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time\n\n      if (time !== timeNext && (i !== 1 || time !== time[0])) {\n        if (!smoothInterpolation) {\n          // remove unnecessary keyframes same as their neighbors\n          var offset = i * stride,\n              offsetP = offset - stride,\n              offsetN = offset + stride;\n\n          for (var j = 0; j !== stride; ++j) {\n            var value = values[offset + j];\n\n            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {\n              keep = true;\n              break;\n            }\n          }\n        } else {\n          keep = true;\n        }\n      } // in-place compaction\n\n\n      if (keep) {\n        if (i !== writeIndex) {\n          times[writeIndex] = times[i];\n          var readOffset = i * stride,\n              writeOffset = writeIndex * stride;\n\n          for (var _j = 0; _j !== stride; ++_j) {\n            values[writeOffset + _j] = values[readOffset + _j];\n          }\n        }\n\n        ++writeIndex;\n      }\n    } // flush last keyframe (compaction looks ahead)\n\n\n    if (lastIndex > 0) {\n      times[writeIndex] = times[lastIndex];\n\n      for (var _readOffset = lastIndex * stride, _writeOffset = writeIndex * stride, _j2 = 0; _j2 !== stride; ++_j2) {\n        values[_writeOffset + _j2] = values[_readOffset + _j2];\n      }\n\n      ++writeIndex;\n    }\n\n    if (writeIndex !== times.length) {\n      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);\n      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);\n    } else {\n      this.times = times;\n      this.values = values;\n    }\n\n    return this;\n  },\n  clone: function clone() {\n    var times = AnimationUtils.arraySlice(this.times, 0);\n    var values = AnimationUtils.arraySlice(this.values, 0);\n    var TypedKeyframeTrack = this.constructor;\n    var track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.\n\n    track.createInterpolant = this.createInterpolant;\n    return track;\n  }\n});\nexport { KeyframeTrack };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/animation/KeyframeTrack.js"],"names":["InterpolateLinear","InterpolateSmooth","InterpolateDiscrete","CubicInterpolant","LinearInterpolant","DiscreteInterpolant","AnimationUtils","KeyframeTrack","name","times","values","interpolation","undefined","Error","length","convertArray","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","Object","assign","toJSON","track","trackType","constructor","json","Array","getInterpolation","type","ValueTypeName","prototype","Float32Array","InterpolantFactoryMethodDiscrete","result","getValueSize","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","message","createInterpolant","console","warn","shift","timeOffset","i","n","scale","timeScale","trim","startTime","endTime","nKeys","from","to","Math","max","stride","arraySlice","validate","valid","valueSize","floor","error","prevTime","currTime","isNaN","isTypedArray","value","optimize","smoothInterpolation","lastIndex","writeIndex","keep","time","timeNext","offset","offsetP","offsetN","j","readOffset","writeOffset","clone","TypedKeyframeTrack"],"mappings":"AAAA,SACCA,iBADD,EAECC,iBAFD,EAGCC,mBAHD,QAIO,iBAJP;AAKA,SAASC,gBAAT,QAAiC,0CAAjC;AACA,SAASC,iBAAT,QAAkC,2CAAlC;AACA,SAASC,mBAAT,QAAoC,6CAApC;AACA,SAASC,cAAT,QAA+B,qBAA/B;;AAEA,SAASC,aAAT,CAAwBC,IAAxB,EAA8BC,KAA9B,EAAqCC,MAArC,EAA6CC,aAA7C,EAA6D;AAE5D,MAAKH,IAAI,KAAKI,SAAd,EAA0B,MAAM,IAAIC,KAAJ,CAAW,8CAAX,CAAN;AAC1B,MAAKJ,KAAK,KAAKG,SAAV,IAAuBH,KAAK,CAACK,MAAN,KAAiB,CAA7C,EAAiD,MAAM,IAAID,KAAJ,CAAW,sDAAsDL,IAAjE,CAAN;AAEjD,OAAKA,IAAL,GAAYA,IAAZ;AAEA,OAAKC,KAAL,GAAaH,cAAc,CAACS,YAAf,CAA6BN,KAA7B,EAAoC,KAAKO,cAAzC,CAAb;AACA,OAAKN,MAAL,GAAcJ,cAAc,CAACS,YAAf,CAA6BL,MAA7B,EAAqC,KAAKO,eAA1C,CAAd;AAEA,OAAKC,gBAAL,CAAuBP,aAAa,IAAI,KAAKQ,oBAA7C;AAEA,C,CAED;;;AAEAC,MAAM,CAACC,MAAP,CAAed,aAAf,EAA8B;AAE7B;AACA;AAEAe,EAAAA,MAAM,EAAE,gBAAWC,KAAX,EAAmB;AAE1B,QAAMC,SAAS,GAAGD,KAAK,CAACE,WAAxB;AAEA,QAAIC,IAAJ,CAJ0B,CAM1B;;AACA,QAAKF,SAAS,CAACF,MAAV,KAAqBV,SAA1B,EAAsC;AAErCc,MAAAA,IAAI,GAAGF,SAAS,CAACF,MAAV,CAAkBC,KAAlB,CAAP;AAEA,KAJD,MAIO;AAEN;AACAG,MAAAA,IAAI,GAAG;AAEN,gBAAQH,KAAK,CAACf,IAFR;AAGN,iBAASF,cAAc,CAACS,YAAf,CAA6BQ,KAAK,CAACd,KAAnC,EAA0CkB,KAA1C,CAHH;AAIN,kBAAUrB,cAAc,CAACS,YAAf,CAA6BQ,KAAK,CAACb,MAAnC,EAA2CiB,KAA3C;AAJJ,OAAP;AAQA,UAAMhB,aAAa,GAAGY,KAAK,CAACK,gBAAN,EAAtB;;AAEA,UAAKjB,aAAa,KAAKY,KAAK,CAACJ,oBAA7B,EAAoD;AAEnDO,QAAAA,IAAI,CAACf,aAAL,GAAqBA,aAArB;AAEA;AAED;;AAEDe,IAAAA,IAAI,CAACG,IAAL,GAAYN,KAAK,CAACO,aAAlB,CAhC0B,CAgCO;;AAEjC,WAAOJ,IAAP;AAEA;AAzC4B,CAA9B;AA6CAN,MAAM,CAACC,MAAP,CAAed,aAAa,CAACwB,SAA7B,EAAwC;AAEvCN,EAAAA,WAAW,EAAElB,aAF0B;AAIvCS,EAAAA,cAAc,EAAEgB,YAJuB;AAMvCf,EAAAA,eAAe,EAAEe,YANsB;AAQvCb,EAAAA,oBAAoB,EAAEnB,iBARiB;AAUvCiC,EAAAA,gCAAgC,EAAE,0CAAWC,MAAX,EAAoB;AAErD,WAAO,IAAI7B,mBAAJ,CAAyB,KAAKI,KAA9B,EAAqC,KAAKC,MAA1C,EAAkD,KAAKyB,YAAL,EAAlD,EAAuED,MAAvE,CAAP;AAEA,GAdsC;AAgBvCE,EAAAA,8BAA8B,EAAE,wCAAWF,MAAX,EAAoB;AAEnD,WAAO,IAAI9B,iBAAJ,CAAuB,KAAKK,KAA5B,EAAmC,KAAKC,MAAxC,EAAgD,KAAKyB,YAAL,EAAhD,EAAqED,MAArE,CAAP;AAEA,GApBsC;AAsBvCG,EAAAA,8BAA8B,EAAE,wCAAWH,MAAX,EAAoB;AAEnD,WAAO,IAAI/B,gBAAJ,CAAsB,KAAKM,KAA3B,EAAkC,KAAKC,MAAvC,EAA+C,KAAKyB,YAAL,EAA/C,EAAoED,MAApE,CAAP;AAEA,GA1BsC;AA4BvChB,EAAAA,gBAAgB,EAAE,0BAAWP,aAAX,EAA2B;AAE5C,QAAI2B,aAAJ;;AAEA,YAAS3B,aAAT;AAEC,WAAKT,mBAAL;AAECoC,QAAAA,aAAa,GAAG,KAAKL,gCAArB;AAEA;;AAED,WAAKjC,iBAAL;AAECsC,QAAAA,aAAa,GAAG,KAAKF,8BAArB;AAEA;;AAED,WAAKnC,iBAAL;AAECqC,QAAAA,aAAa,GAAG,KAAKD,8BAArB;AAEA;AAlBF;;AAsBA,QAAKC,aAAa,KAAK1B,SAAvB,EAAmC;AAElC,UAAM2B,OAAO,GAAG,mCACf,KAAKT,aADU,GACM,wBADN,GACiC,KAAKtB,IADtD;;AAGA,UAAK,KAAKgC,iBAAL,KAA2B5B,SAAhC,EAA4C;AAE3C;AACA,YAAKD,aAAa,KAAK,KAAKQ,oBAA5B,EAAmD;AAElD,eAAKD,gBAAL,CAAuB,KAAKC,oBAA5B;AAEA,SAJD,MAIO;AAEN,gBAAM,IAAIN,KAAJ,CAAW0B,OAAX,CAAN,CAFM,CAEsB;AAE5B;AAED;;AAEDE,MAAAA,OAAO,CAACC,IAAR,CAAc,sBAAd,EAAsCH,OAAtC;AACA,aAAO,IAAP;AAEA;;AAED,SAAKC,iBAAL,GAAyBF,aAAzB;AAEA,WAAO,IAAP;AAEA,GAnFsC;AAqFvCV,EAAAA,gBAAgB,EAAE,4BAAY;AAE7B,YAAS,KAAKY,iBAAd;AAEC,WAAK,KAAKP,gCAAV;AAEC,eAAO/B,mBAAP;;AAED,WAAK,KAAKkC,8BAAV;AAEC,eAAOpC,iBAAP;;AAED,WAAK,KAAKqC,8BAAV;AAEC,eAAOpC,iBAAP;AAZF;AAgBA,GAvGsC;AAyGvCkC,EAAAA,YAAY,EAAE,wBAAY;AAEzB,WAAO,KAAKzB,MAAL,CAAYI,MAAZ,GAAqB,KAAKL,KAAL,CAAWK,MAAvC;AAEA,GA7GsC;AA+GvC;AACA6B,EAAAA,KAAK,EAAE,eAAWC,UAAX,EAAwB;AAE9B,QAAKA,UAAU,KAAK,GAApB,EAA0B;AAEzB,UAAMnC,KAAK,GAAG,KAAKA,KAAnB;;AAEA,WAAM,IAAIoC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGrC,KAAK,CAACK,MAA3B,EAAmC+B,CAAC,KAAKC,CAAzC,EAA4C,EAAGD,CAA/C,EAAmD;AAElDpC,QAAAA,KAAK,CAAEoC,CAAF,CAAL,IAAcD,UAAd;AAEA;AAED;;AAED,WAAO,IAAP;AAEA,GAhIsC;AAkIvC;AACAG,EAAAA,KAAK,EAAE,eAAWC,SAAX,EAAuB;AAE7B,QAAKA,SAAS,KAAK,GAAnB,EAAyB;AAExB,UAAMvC,KAAK,GAAG,KAAKA,KAAnB;;AAEA,WAAM,IAAIoC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGrC,KAAK,CAACK,MAA3B,EAAmC+B,CAAC,KAAKC,CAAzC,EAA4C,EAAGD,CAA/C,EAAmD;AAElDpC,QAAAA,KAAK,CAAEoC,CAAF,CAAL,IAAcG,SAAd;AAEA;AAED;;AAED,WAAO,IAAP;AAEA,GAnJsC;AAqJvC;AACA;AACAC,EAAAA,IAAI,EAAE,cAAWC,SAAX,EAAsBC,OAAtB,EAAgC;AAErC,QAAM1C,KAAK,GAAG,KAAKA,KAAnB;AAAA,QACC2C,KAAK,GAAG3C,KAAK,CAACK,MADf;AAGA,QAAIuC,IAAI,GAAG,CAAX;AAAA,QACCC,EAAE,GAAGF,KAAK,GAAG,CADd;;AAGA,WAAQC,IAAI,KAAKD,KAAT,IAAkB3C,KAAK,CAAE4C,IAAF,CAAL,GAAgBH,SAA1C,EAAsD;AAErD,QAAGG,IAAH;AAEA;;AAED,WAAQC,EAAE,KAAK,CAAE,CAAT,IAAc7C,KAAK,CAAE6C,EAAF,CAAL,GAAcH,OAApC,EAA8C;AAE7C,QAAGG,EAAH;AAEA;;AAED,MAAGA,EAAH,CApBqC,CAoB9B;;AAEP,QAAKD,IAAI,KAAK,CAAT,IAAcC,EAAE,KAAKF,KAA1B,EAAkC;AAEjC;AACA,UAAKC,IAAI,IAAIC,EAAb,EAAkB;AAEjBA,QAAAA,EAAE,GAAGC,IAAI,CAACC,GAAL,CAAUF,EAAV,EAAc,CAAd,CAAL;AACAD,QAAAA,IAAI,GAAGC,EAAE,GAAG,CAAZ;AAEA;;AAED,UAAMG,MAAM,GAAG,KAAKtB,YAAL,EAAf;AACA,WAAK1B,KAAL,GAAaH,cAAc,CAACoD,UAAf,CAA2BjD,KAA3B,EAAkC4C,IAAlC,EAAwCC,EAAxC,CAAb;AACA,WAAK5C,MAAL,GAAcJ,cAAc,CAACoD,UAAf,CAA2B,KAAKhD,MAAhC,EAAwC2C,IAAI,GAAGI,MAA/C,EAAuDH,EAAE,GAAGG,MAA5D,CAAd;AAEA;;AAED,WAAO,IAAP;AAEA,GA/LsC;AAiMvC;AACAE,EAAAA,QAAQ,EAAE,oBAAY;AAErB,QAAIC,KAAK,GAAG,IAAZ;AAEA,QAAMC,SAAS,GAAG,KAAK1B,YAAL,EAAlB;;AACA,QAAK0B,SAAS,GAAGN,IAAI,CAACO,KAAL,CAAYD,SAAZ,CAAZ,KAAwC,CAA7C,EAAiD;AAEhDpB,MAAAA,OAAO,CAACsB,KAAR,CAAe,mDAAf,EAAoE,IAApE;AACAH,MAAAA,KAAK,GAAG,KAAR;AAEA;;AAED,QAAMnD,KAAK,GAAG,KAAKA,KAAnB;AAAA,QACCC,MAAM,GAAG,KAAKA,MADf;AAAA,QAGC0C,KAAK,GAAG3C,KAAK,CAACK,MAHf;;AAKA,QAAKsC,KAAK,KAAK,CAAf,EAAmB;AAElBX,MAAAA,OAAO,CAACsB,KAAR,CAAe,sCAAf,EAAuD,IAAvD;AACAH,MAAAA,KAAK,GAAG,KAAR;AAEA;;AAED,QAAII,QAAQ,GAAG,IAAf;;AAEA,SAAM,IAAInB,CAAC,GAAG,CAAd,EAAiBA,CAAC,KAAKO,KAAvB,EAA8BP,CAAC,EAA/B,EAAqC;AAEpC,UAAMoB,QAAQ,GAAGxD,KAAK,CAAEoC,CAAF,CAAtB;;AAEA,UAAK,OAAOoB,QAAP,KAAoB,QAApB,IAAgCC,KAAK,CAAED,QAAF,CAA1C,EAAyD;AAExDxB,QAAAA,OAAO,CAACsB,KAAR,CAAe,kDAAf,EAAmE,IAAnE,EAAyElB,CAAzE,EAA4EoB,QAA5E;AACAL,QAAAA,KAAK,GAAG,KAAR;AACA;AAEA;;AAED,UAAKI,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,GAAGC,QAArC,EAAgD;AAE/CxB,QAAAA,OAAO,CAACsB,KAAR,CAAe,yCAAf,EAA0D,IAA1D,EAAgElB,CAAhE,EAAmEoB,QAAnE,EAA6ED,QAA7E;AACAJ,QAAAA,KAAK,GAAG,KAAR;AACA;AAEA;;AAEDI,MAAAA,QAAQ,GAAGC,QAAX;AAEA;;AAED,QAAKvD,MAAM,KAAKE,SAAhB,EAA4B;AAE3B,UAAKN,cAAc,CAAC6D,YAAf,CAA6BzD,MAA7B,CAAL,EAA6C;AAE5C,aAAM,IAAImC,EAAC,GAAG,CAAR,EAAWC,CAAC,GAAGpC,MAAM,CAACI,MAA5B,EAAoC+B,EAAC,KAAKC,CAA1C,EAA6C,EAAGD,EAAhD,EAAoD;AAEnD,cAAMuB,KAAK,GAAG1D,MAAM,CAAEmC,EAAF,CAApB;;AAEA,cAAKqB,KAAK,CAAEE,KAAF,CAAV,EAAsB;AAErB3B,YAAAA,OAAO,CAACsB,KAAR,CAAe,mDAAf,EAAoE,IAApE,EAA0ElB,EAA1E,EAA6EuB,KAA7E;AACAR,YAAAA,KAAK,GAAG,KAAR;AACA;AAEA;AAED;AAED;AAED;;AAED,WAAOA,KAAP;AAEA,GA5QsC;AA8QvC;AACA;AACAS,EAAAA,QAAQ,EAAE,oBAAY;AAErB;AACA,QAAM5D,KAAK,GAAGH,cAAc,CAACoD,UAAf,CAA2B,KAAKjD,KAAhC,CAAd;AAAA,QACCC,MAAM,GAAGJ,cAAc,CAACoD,UAAf,CAA2B,KAAKhD,MAAhC,CADV;AAAA,QAEC+C,MAAM,GAAG,KAAKtB,YAAL,EAFV;AAAA,QAICmC,mBAAmB,GAAG,KAAK1C,gBAAL,OAA4B3B,iBAJnD;AAAA,QAMCsE,SAAS,GAAG9D,KAAK,CAACK,MAAN,GAAe,CAN5B;AAQA,QAAI0D,UAAU,GAAG,CAAjB;;AAEA,SAAM,IAAI3B,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG0B,SAArB,EAAgC,EAAG1B,CAAnC,EAAuC;AAEtC,UAAI4B,IAAI,GAAG,KAAX;AAEA,UAAMC,IAAI,GAAGjE,KAAK,CAAEoC,CAAF,CAAlB;AACA,UAAM8B,QAAQ,GAAGlE,KAAK,CAAEoC,CAAC,GAAG,CAAN,CAAtB,CALsC,CAOtC;;AAEA,UAAK6B,IAAI,KAAKC,QAAT,KAAuB9B,CAAC,KAAK,CAAN,IAAW6B,IAAI,KAAKA,IAAI,CAAE,CAAF,CAA/C,CAAL,EAA8D;AAE7D,YAAK,CAAEJ,mBAAP,EAA6B;AAE5B;AAEA,cAAMM,MAAM,GAAG/B,CAAC,GAAGY,MAAnB;AAAA,cACCoB,OAAO,GAAGD,MAAM,GAAGnB,MADpB;AAAA,cAECqB,OAAO,GAAGF,MAAM,GAAGnB,MAFpB;;AAIA,eAAM,IAAIsB,CAAC,GAAG,CAAd,EAAiBA,CAAC,KAAKtB,MAAvB,EAA+B,EAAGsB,CAAlC,EAAsC;AAErC,gBAAMX,KAAK,GAAG1D,MAAM,CAAEkE,MAAM,GAAGG,CAAX,CAApB;;AAEA,gBAAKX,KAAK,KAAK1D,MAAM,CAAEmE,OAAO,GAAGE,CAAZ,CAAhB,IACJX,KAAK,KAAK1D,MAAM,CAAEoE,OAAO,GAAGC,CAAZ,CADjB,EACmC;AAElCN,cAAAA,IAAI,GAAG,IAAP;AACA;AAEA;AAED;AAED,SAtBD,MAsBO;AAENA,UAAAA,IAAI,GAAG,IAAP;AAEA;AAED,OAvCqC,CAyCtC;;;AAEA,UAAKA,IAAL,EAAY;AAEX,YAAK5B,CAAC,KAAK2B,UAAX,EAAwB;AAEvB/D,UAAAA,KAAK,CAAE+D,UAAF,CAAL,GAAsB/D,KAAK,CAAEoC,CAAF,CAA3B;AAEA,cAAMmC,UAAU,GAAGnC,CAAC,GAAGY,MAAvB;AAAA,cACCwB,WAAW,GAAGT,UAAU,GAAGf,MAD5B;;AAGA,eAAM,IAAIsB,EAAC,GAAG,CAAd,EAAiBA,EAAC,KAAKtB,MAAvB,EAA+B,EAAGsB,EAAlC,EAAsC;AAErCrE,YAAAA,MAAM,CAAEuE,WAAW,GAAGF,EAAhB,CAAN,GAA4BrE,MAAM,CAAEsE,UAAU,GAAGD,EAAf,CAAlC;AAEA;AAED;;AAED,UAAGP,UAAH;AAEA;AAED,KA7EoB,CA+ErB;;;AAEA,QAAKD,SAAS,GAAG,CAAjB,EAAqB;AAEpB9D,MAAAA,KAAK,CAAE+D,UAAF,CAAL,GAAsB/D,KAAK,CAAE8D,SAAF,CAA3B;;AAEA,WAAM,IAAIS,WAAU,GAAGT,SAAS,GAAGd,MAA7B,EAAqCwB,YAAW,GAAGT,UAAU,GAAGf,MAAhE,EAAwEsB,GAAC,GAAG,CAAlF,EAAqFA,GAAC,KAAKtB,MAA3F,EAAmG,EAAGsB,GAAtG,EAA0G;AAEzGrE,QAAAA,MAAM,CAAEuE,YAAW,GAAGF,GAAhB,CAAN,GAA4BrE,MAAM,CAAEsE,WAAU,GAAGD,GAAf,CAAlC;AAEA;;AAED,QAAGP,UAAH;AAEA;;AAED,QAAKA,UAAU,KAAK/D,KAAK,CAACK,MAA1B,EAAmC;AAElC,WAAKL,KAAL,GAAaH,cAAc,CAACoD,UAAf,CAA2BjD,KAA3B,EAAkC,CAAlC,EAAqC+D,UAArC,CAAb;AACA,WAAK9D,MAAL,GAAcJ,cAAc,CAACoD,UAAf,CAA2BhD,MAA3B,EAAmC,CAAnC,EAAsC8D,UAAU,GAAGf,MAAnD,CAAd;AAEA,KALD,MAKO;AAEN,WAAKhD,KAAL,GAAaA,KAAb;AACA,WAAKC,MAAL,GAAcA,MAAd;AAEA;;AAED,WAAO,IAAP;AAEA,GA7XsC;AA+XvCwE,EAAAA,KAAK,EAAE,iBAAY;AAElB,QAAMzE,KAAK,GAAGH,cAAc,CAACoD,UAAf,CAA2B,KAAKjD,KAAhC,EAAuC,CAAvC,CAAd;AACA,QAAMC,MAAM,GAAGJ,cAAc,CAACoD,UAAf,CAA2B,KAAKhD,MAAhC,EAAwC,CAAxC,CAAf;AAEA,QAAMyE,kBAAkB,GAAG,KAAK1D,WAAhC;AACA,QAAMF,KAAK,GAAG,IAAI4D,kBAAJ,CAAwB,KAAK3E,IAA7B,EAAmCC,KAAnC,EAA0CC,MAA1C,CAAd,CANkB,CAQlB;;AACAa,IAAAA,KAAK,CAACiB,iBAAN,GAA0B,KAAKA,iBAA/B;AAEA,WAAOjB,KAAP;AAEA;AA5YsC,CAAxC;AAgZA,SAAShB,aAAT","sourcesContent":["import {\n\tInterpolateLinear,\n\tInterpolateSmooth,\n\tInterpolateDiscrete\n} from '../constants.js';\nimport { CubicInterpolant } from '../math/interpolants/CubicInterpolant.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { DiscreteInterpolant } from '../math/interpolants/DiscreteInterpolant.js';\nimport { AnimationUtils } from './AnimationUtils.js';\n\nfunction KeyframeTrack( name, times, values, interpolation ) {\n\n\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\tthis.name = name;\n\n\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n}\n\n// Static methods\n\nObject.assign( KeyframeTrack, {\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\ttoJSON: function ( track ) {\n\n\t\tconst trackType = track.constructor;\n\n\t\tlet json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n} );\n\nObject.assign( KeyframeTrack.prototype, {\n\n\tconstructor: KeyframeTrack,\n\n\tTimeBufferType: Float32Array,\n\n\tValueBufferType: Float32Array,\n\n\tDefaultInterpolation: InterpolateLinear,\n\n\tInterpolantFactoryMethodDiscrete: function ( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodLinear: function ( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: function ( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tsetInterpolation: function ( interpolation ) {\n\n\t\tlet factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tconst message = \"unsupported interpolation for \" +\n\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t},\n\n\tgetInterpolation: function () {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t},\n\n\tgetValueSize: function () {\n\n\t\treturn this.values.length / this.times.length;\n\n\t},\n\n\t// move all keyframes either forwards or backwards in time\n\tshift: function ( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale: function ( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim: function ( startTime, endTime ) {\n\n\t\tconst times = this.times,\n\t\t\tnKeys = times.length;\n\n\t\tlet from = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) {\n\n\t\t\t\tto = Math.max( to, 1 );\n\t\t\t\tfrom = to - 1;\n\n\t\t\t}\n\n\t\t\tconst stride = this.getValueSize();\n\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\n\t\t\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate: function () {\n\n\t\tlet valid = true;\n\n\t\tconst valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tconst times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tlet prevTime = null;\n\n\t\tfor ( let i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tconst currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( let i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tconst value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize: function () {\n\n\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\tconst times = AnimationUtils.arraySlice( this.times ),\n\t\t\tvalues = AnimationUtils.arraySlice( this.values ),\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\tlastIndex = times.length - 1;\n\n\t\tlet writeIndex = 1;\n\n\t\tfor ( let i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tlet keep = false;\n\n\t\t\tconst time = times[ i ];\n\t\t\tconst timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tconst value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t} else {\n\n\t\t\tthis.times = times;\n\t\t\tthis.values = values;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\tconst times = AnimationUtils.arraySlice( this.times, 0 );\n\t\tconst values = AnimationUtils.arraySlice( this.values, 0 );\n\n\t\tconst TypedKeyframeTrack = this.constructor;\n\t\tconst track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n} );\n\nexport { KeyframeTrack };\n"]},"metadata":{},"sourceType":"module"}