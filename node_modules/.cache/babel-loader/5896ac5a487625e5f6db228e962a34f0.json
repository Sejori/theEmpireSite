{"ast":null,"code":"import { Quaternion } from '../math/Quaternion.js';\nimport { AdditiveAnimationBlendMode } from '../constants.js';\nvar AnimationUtils = {\n  // same as Array.prototype.slice, but also works on typed arrays\n  arraySlice: function arraySlice(array, from, to) {\n    if (AnimationUtils.isTypedArray(array)) {\n      // in ios9 array.subarray(from, undefined) will return empty array\n      // but array.subarray(from) or array.subarray(from, len) is correct\n      return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));\n    }\n\n    return array.slice(from, to);\n  },\n  // converts an array to a specific type\n  convertArray: function convertArray(array, type, forceClone) {\n    if (!array || // let 'undefined' and 'null' pass\n    !forceClone && array.constructor === type) return array;\n\n    if (typeof type.BYTES_PER_ELEMENT === 'number') {\n      return new type(array); // create typed array\n    }\n\n    return Array.prototype.slice.call(array); // create Array\n  },\n  isTypedArray: function isTypedArray(object) {\n    return ArrayBuffer.isView(object) && !(object instanceof DataView);\n  },\n  // returns an array by which times and values can be sorted\n  getKeyframeOrder: function getKeyframeOrder(times) {\n    function compareTime(i, j) {\n      return times[i] - times[j];\n    }\n\n    var n = times.length;\n    var result = new Array(n);\n\n    for (var i = 0; i !== n; ++i) {\n      result[i] = i;\n    }\n\n    result.sort(compareTime);\n    return result;\n  },\n  // uses the array previously returned by 'getKeyframeOrder' to sort data\n  sortedArray: function sortedArray(values, stride, order) {\n    var nValues = values.length;\n    var result = new values.constructor(nValues);\n\n    for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {\n      var srcOffset = order[i] * stride;\n\n      for (var j = 0; j !== stride; ++j) {\n        result[dstOffset++] = values[srcOffset + j];\n      }\n    }\n\n    return result;\n  },\n  // function for parsing AOS keyframe formats\n  flattenJSON: function flattenJSON(jsonKeys, times, values, valuePropertyName) {\n    var i = 1,\n        key = jsonKeys[0];\n\n    while (key !== undefined && key[valuePropertyName] === undefined) {\n      key = jsonKeys[i++];\n    }\n\n    if (key === undefined) return; // no data\n\n    var value = key[valuePropertyName];\n    if (value === undefined) return; // no data\n\n    if (Array.isArray(value)) {\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          values.push.apply(values, value); // push all elements\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    } else if (value.toArray !== undefined) {\n      // ...assume THREE.Math-ish\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          value.toArray(values, values.length);\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    } else {\n      // otherwise push as-is\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          values.push(value);\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    }\n  },\n  subclip: function subclip(sourceClip, name, startFrame, endFrame, fps) {\n    fps = fps || 30;\n    var clip = sourceClip.clone();\n    clip.name = name;\n    var tracks = [];\n\n    for (var i = 0; i < clip.tracks.length; ++i) {\n      var track = clip.tracks[i];\n      var valueSize = track.getValueSize();\n      var times = [];\n      var values = [];\n\n      for (var j = 0; j < track.times.length; ++j) {\n        var frame = track.times[j] * fps;\n        if (frame < startFrame || frame >= endFrame) continue;\n        times.push(track.times[j]);\n\n        for (var k = 0; k < valueSize; ++k) {\n          values.push(track.values[j * valueSize + k]);\n        }\n      }\n\n      if (times.length === 0) continue;\n      track.times = AnimationUtils.convertArray(times, track.times.constructor);\n      track.values = AnimationUtils.convertArray(values, track.values.constructor);\n      tracks.push(track);\n    }\n\n    clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip\n\n    var minStartTime = Infinity;\n\n    for (var _i = 0; _i < clip.tracks.length; ++_i) {\n      if (minStartTime > clip.tracks[_i].times[0]) {\n        minStartTime = clip.tracks[_i].times[0];\n      }\n    } // shift all tracks such that clip begins at t=0\n\n\n    for (var _i2 = 0; _i2 < clip.tracks.length; ++_i2) {\n      clip.tracks[_i2].shift(-1 * minStartTime);\n    }\n\n    clip.resetDuration();\n    return clip;\n  },\n  makeClipAdditive: function makeClipAdditive(targetClip, referenceFrame, referenceClip, fps) {\n    if (referenceFrame === undefined) referenceFrame = 0;\n    if (referenceClip === undefined) referenceClip = targetClip;\n    if (fps === undefined || fps <= 0) fps = 30;\n    var numTracks = referenceClip.tracks.length;\n    var referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame\n\n    var _loop = function _loop(i) {\n      var referenceTrack = referenceClip.tracks[i];\n      var referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric\n\n      if (referenceTrackType === 'bool' || referenceTrackType === 'string') return \"continue\"; // Find the track in the target clip whose name and type matches the reference track\n\n      var targetTrack = targetClip.tracks.find(function (track) {\n        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;\n      });\n      if (targetTrack === undefined) return \"continue\";\n      var referenceOffset = 0;\n      var referenceValueSize = referenceTrack.getValueSize();\n\n      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        referenceOffset = referenceValueSize / 3;\n      }\n\n      var targetOffset = 0;\n      var targetValueSize = targetTrack.getValueSize();\n\n      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        targetOffset = targetValueSize / 3;\n      }\n\n      var lastIndex = referenceTrack.times.length - 1;\n      var referenceValue = void 0; // Find the value to subtract out of the track\n\n      if (referenceTime <= referenceTrack.times[0]) {\n        // Reference frame is earlier than the first keyframe, so just use the first keyframe\n        var startIndex = referenceOffset;\n        var endIndex = referenceValueSize - referenceOffset;\n        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n      } else if (referenceTime >= referenceTrack.times[lastIndex]) {\n        // Reference frame is after the last keyframe, so just use the last keyframe\n        var _startIndex = lastIndex * referenceValueSize + referenceOffset;\n\n        var _endIndex = _startIndex + referenceValueSize - referenceOffset;\n\n        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, _startIndex, _endIndex);\n      } else {\n        // Interpolate to the reference value\n        var interpolant = referenceTrack.createInterpolant();\n        var _startIndex2 = referenceOffset;\n\n        var _endIndex2 = referenceValueSize - referenceOffset;\n\n        interpolant.evaluate(referenceTime);\n        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, _startIndex2, _endIndex2);\n      } // Conjugate the quaternion\n\n\n      if (referenceTrackType === 'quaternion') {\n        var referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();\n        referenceQuat.toArray(referenceValue);\n      } // Subtract the reference value from all of the track values\n\n\n      var numTimes = targetTrack.times.length;\n\n      for (var j = 0; j < numTimes; ++j) {\n        var valueStart = j * targetValueSize + targetOffset;\n\n        if (referenceTrackType === 'quaternion') {\n          // Multiply the conjugate for quaternion track types\n          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);\n        } else {\n          var valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types\n\n          for (var k = 0; k < valueEnd; ++k) {\n            targetTrack.values[valueStart + k] -= referenceValue[k];\n          }\n        }\n      }\n    };\n\n    for (var i = 0; i < numTracks; ++i) {\n      var _ret = _loop(i);\n\n      if (_ret === \"continue\") continue;\n    }\n\n    targetClip.blendMode = AdditiveAnimationBlendMode;\n    return targetClip;\n  }\n};\nexport { AnimationUtils };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/animation/AnimationUtils.js"],"names":["Quaternion","AdditiveAnimationBlendMode","AnimationUtils","arraySlice","array","from","to","isTypedArray","constructor","subarray","undefined","length","slice","convertArray","type","forceClone","BYTES_PER_ELEMENT","Array","prototype","call","object","ArrayBuffer","isView","DataView","getKeyframeOrder","times","compareTime","i","j","n","result","sort","sortedArray","values","stride","order","nValues","dstOffset","srcOffset","flattenJSON","jsonKeys","valuePropertyName","key","value","isArray","push","time","apply","toArray","subclip","sourceClip","name","startFrame","endFrame","fps","clip","clone","tracks","track","valueSize","getValueSize","frame","k","minStartTime","Infinity","shift","resetDuration","makeClipAdditive","targetClip","referenceFrame","referenceClip","numTracks","referenceTime","referenceTrack","referenceTrackType","ValueTypeName","targetTrack","find","referenceOffset","referenceValueSize","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","targetOffset","targetValueSize","lastIndex","referenceValue","startIndex","endIndex","interpolant","evaluate","resultBuffer","referenceQuat","fromArray","normalize","conjugate","numTimes","valueStart","multiplyQuaternionsFlat","valueEnd","blendMode"],"mappings":"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","sourcesContent":["import { Quaternion } from '../math/Quaternion.js';\nimport { AdditiveAnimationBlendMode } from '../constants.js';\n\nconst AnimationUtils = {\n\n\t// same as Array.prototype.slice, but also works on typed arrays\n\tarraySlice: function ( array, from, to ) {\n\n\t\tif ( AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\t// in ios9 array.subarray(from, undefined) will return empty array\n\t\t\t// but array.subarray(from) or array.subarray(from, len) is correct\n\t\t\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\n\n\t\t}\n\n\t\treturn array.slice( from, to );\n\n\t},\n\n\t// converts an array to a specific type\n\tconvertArray: function ( array, type, forceClone ) {\n\n\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\treturn new type( array ); // create typed array\n\n\t\t}\n\n\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t},\n\n\tisTypedArray: function ( object ) {\n\n\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t! ( object instanceof DataView );\n\n\t},\n\n\t// returns an array by which times and values can be sorted\n\tgetKeyframeOrder: function ( times ) {\n\n\t\tfunction compareTime( i, j ) {\n\n\t\t\treturn times[ i ] - times[ j ];\n\n\t\t}\n\n\t\tconst n = times.length;\n\t\tconst result = new Array( n );\n\t\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\tresult.sort( compareTime );\n\n\t\treturn result;\n\n\t},\n\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\tsortedArray: function ( values, stride, order ) {\n\n\t\tconst nValues = values.length;\n\t\tconst result = new values.constructor( nValues );\n\n\t\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\tconst srcOffset = order[ i ] * stride;\n\n\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// function for parsing AOS keyframe formats\n\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\n\n\t\tlet i = 1, key = jsonKeys[ 0 ];\n\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t}\n\n\t\tif ( key === undefined ) return; // no data\n\n\t\tlet value = key[ valuePropertyName ];\n\t\tif ( value === undefined ) return; // no data\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else if ( value.toArray !== undefined ) {\n\n\t\t\t// ...assume THREE.Math-ish\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else {\n\n\t\t\t// otherwise push as-is\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t}\n\n\t},\n\n\tsubclip: function ( sourceClip, name, startFrame, endFrame, fps ) {\n\n\t\tfps = fps || 30;\n\n\t\tconst clip = sourceClip.clone();\n\n\t\tclip.name = name;\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\t\tconst track = clip.tracks[ i ];\n\t\t\tconst valueSize = track.getValueSize();\n\n\t\t\tconst times = [];\n\t\t\tconst values = [];\n\n\t\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\n\n\t\t\t\tconst frame = track.times[ j ] * fps;\n\n\t\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\n\n\t\t\t\ttimes.push( track.times[ j ] );\n\n\t\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( times.length === 0 ) continue;\n\n\t\t\ttrack.times = AnimationUtils.convertArray( times, track.times.constructor );\n\t\t\ttrack.values = AnimationUtils.convertArray( values, track.values.constructor );\n\n\t\t\ttracks.push( track );\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\t// find minimum .times value across all tracks in the trimmed clip\n\n\t\tlet minStartTime = Infinity;\n\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\n\n\t\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// shift all tracks such that clip begins at t=0\n\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\n\n\t\t}\n\n\t\tclip.resetDuration();\n\n\t\treturn clip;\n\n\t},\n\n\tmakeClipAdditive: function ( targetClip, referenceFrame, referenceClip, fps ) {\n\n\t\tif ( referenceFrame === undefined ) referenceFrame = 0;\n\t\tif ( referenceClip === undefined ) referenceClip = targetClip;\n\t\tif ( fps === undefined || fps <= 0 ) fps = 30;\n\n\t\tconst numTracks = referenceClip.tracks.length;\n\t\tconst referenceTime = referenceFrame / fps;\n\n\t\t// Make each track's values relative to the values at the reference frame\n\t\tfor ( let i = 0; i < numTracks; ++ i ) {\n\n\t\t\tconst referenceTrack = referenceClip.tracks[ i ];\n\t\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\n\n\t\t\t// Skip this track if it's non-numeric\n\t\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\n\n\t\t\t// Find the track in the target clip whose name and type matches the reference track\n\t\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\n\n\t\t\t\treturn track.name === referenceTrack.name\n\t\t\t\t\t&& track.ValueTypeName === referenceTrackType;\n\n\t\t\t} );\n\n\t\t\tif ( targetTrack === undefined ) continue;\n\n\t\t\tlet referenceOffset = 0;\n\t\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\t\tif ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\treferenceOffset = referenceValueSize / 3;\n\n\t\t\t}\n\n\t\t\tlet targetOffset = 0;\n\t\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\t\tif ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\ttargetOffset = targetValueSize / 3;\n\n\t\t\t}\n\n\t\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\t\tlet referenceValue;\n\n\t\t\t// Find the value to subtract out of the track\n\t\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\n\n\t\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\t\tconst startIndex = referenceOffset;\n\t\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\t\treferenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );\n\n\t\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\n\n\t\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\t\treferenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );\n\n\t\t\t} else {\n\n\t\t\t\t// Interpolate to the reference value\n\t\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\t\tconst startIndex = referenceOffset;\n\t\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\t\tinterpolant.evaluate( referenceTime );\n\t\t\t\treferenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );\n\n\t\t\t}\n\n\t\t\t// Conjugate the quaternion\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\tconst referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();\n\t\t\t\treferenceQuat.toArray( referenceValue );\n\n\t\t\t}\n\n\t\t\t// Subtract the reference value from all of the track values\n\n\t\t\tconst numTimes = targetTrack.times.length;\n\t\t\tfor ( let j = 0; j < numTimes; ++ j ) {\n\n\t\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\t\tQuaternion.multiplyQuaternionsFlat(\n\t\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\t\tvalueStart,\n\t\t\t\t\t\treferenceValue,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\t\tvalueStart\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2;\n\n\t\t\t\t\t// Subtract each value for all other numeric track types\n\t\t\t\t\tfor ( let k = 0; k < valueEnd; ++ k ) {\n\n\t\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\n\t\treturn targetClip;\n\n\t}\n\n};\n\nexport { AnimationUtils };\n"]},"metadata":{},"sourceType":"module"}