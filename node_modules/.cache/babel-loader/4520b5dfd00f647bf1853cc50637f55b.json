{"ast":null,"code":"import { MathUtils } from '../../math/MathUtils.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nfunction Curve() {\n  this.type = 'Curve';\n  this.arcLengthDivisions = 200;\n}\n\nObject.assign(Curve.prototype, {\n  // Virtual base class method to overwrite and implement in subclasses\n  //\t- t [0 .. 1]\n  getPoint: function getPoint()\n  /* t, optionalTarget */\n  {\n    console.warn('THREE.Curve: .getPoint() not implemented.');\n    return null;\n  },\n  // Get point at relative position in curve according to arc length\n  // - u [0 .. 1]\n  getPointAt: function getPointAt(u, optionalTarget) {\n    var t = this.getUtoTmapping(u);\n    return this.getPoint(t, optionalTarget);\n  },\n  // Get sequence of points using getPoint( t )\n  getPoints: function getPoints(divisions) {\n    if (divisions === undefined) divisions = 5;\n    var points = [];\n\n    for (var d = 0; d <= divisions; d++) {\n      points.push(this.getPoint(d / divisions));\n    }\n\n    return points;\n  },\n  // Get sequence of points using getPointAt( u )\n  getSpacedPoints: function getSpacedPoints(divisions) {\n    if (divisions === undefined) divisions = 5;\n    var points = [];\n\n    for (var d = 0; d <= divisions; d++) {\n      points.push(this.getPointAt(d / divisions));\n    }\n\n    return points;\n  },\n  // Get total curve arc length\n  getLength: function getLength() {\n    var lengths = this.getLengths();\n    return lengths[lengths.length - 1];\n  },\n  // Get list of cumulative segment lengths\n  getLengths: function getLengths(divisions) {\n    if (divisions === undefined) divisions = this.arcLengthDivisions;\n\n    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n      return this.cacheArcLengths;\n    }\n\n    this.needsUpdate = false;\n    var cache = [];\n    var current,\n        last = this.getPoint(0);\n    var sum = 0;\n    cache.push(0);\n\n    for (var p = 1; p <= divisions; p++) {\n      current = this.getPoint(p / divisions);\n      sum += current.distanceTo(last);\n      cache.push(sum);\n      last = current;\n    }\n\n    this.cacheArcLengths = cache;\n    return cache; // { sums: cache, sum: sum }; Sum is in the last element.\n  },\n  updateArcLengths: function updateArcLengths() {\n    this.needsUpdate = true;\n    this.getLengths();\n  },\n  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n  getUtoTmapping: function getUtoTmapping(u, distance) {\n    var arcLengths = this.getLengths();\n    var i = 0;\n    var il = arcLengths.length;\n    var targetArcLength; // The targeted u distance value to get\n\n    if (distance) {\n      targetArcLength = distance;\n    } else {\n      targetArcLength = u * arcLengths[il - 1];\n    } // binary search for the index with largest value smaller than target u distance\n\n\n    var low = 0,\n        high = il - 1,\n        comparison;\n\n    while (low <= high) {\n      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n      comparison = arcLengths[i] - targetArcLength;\n\n      if (comparison < 0) {\n        low = i + 1;\n      } else if (comparison > 0) {\n        high = i - 1;\n      } else {\n        high = i;\n        break; // DONE\n      }\n    }\n\n    i = high;\n\n    if (arcLengths[i] === targetArcLength) {\n      return i / (il - 1);\n    } // we could get finer grain at lengths, or use simple interpolation between two points\n\n\n    var lengthBefore = arcLengths[i];\n    var lengthAfter = arcLengths[i + 1];\n    var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points\n\n    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t\n\n    var t = (i + segmentFraction) / (il - 1);\n    return t;\n  },\n  // Returns a unit vector tangent at t\n  // In case any sub curve does not implement its tangent derivation,\n  // 2 points a small delta apart will be used to find its gradient\n  // which seems to give a reasonable approximation\n  getTangent: function getTangent(t, optionalTarget) {\n    var delta = 0.0001;\n    var t1 = t - delta;\n    var t2 = t + delta; // Capping in case of danger\n\n    if (t1 < 0) t1 = 0;\n    if (t2 > 1) t2 = 1;\n    var pt1 = this.getPoint(t1);\n    var pt2 = this.getPoint(t2);\n    var tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());\n    tangent.copy(pt2).sub(pt1).normalize();\n    return tangent;\n  },\n  getTangentAt: function getTangentAt(u, optionalTarget) {\n    var t = this.getUtoTmapping(u);\n    return this.getTangent(t, optionalTarget);\n  },\n  computeFrenetFrames: function computeFrenetFrames(segments, closed) {\n    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n    var normal = new Vector3();\n    var tangents = [];\n    var normals = [];\n    var binormals = [];\n    var vec = new Vector3();\n    var mat = new Matrix4(); // compute the tangent vectors for each segment on the curve\n\n    for (var i = 0; i <= segments; i++) {\n      var u = i / segments;\n      tangents[i] = this.getTangentAt(u, new Vector3());\n      tangents[i].normalize();\n    } // select an initial normal vector perpendicular to the first tangent vector,\n    // and in the direction of the minimum tangent xyz component\n\n\n    normals[0] = new Vector3();\n    binormals[0] = new Vector3();\n    var min = Number.MAX_VALUE;\n    var tx = Math.abs(tangents[0].x);\n    var ty = Math.abs(tangents[0].y);\n    var tz = Math.abs(tangents[0].z);\n\n    if (tx <= min) {\n      min = tx;\n      normal.set(1, 0, 0);\n    }\n\n    if (ty <= min) {\n      min = ty;\n      normal.set(0, 1, 0);\n    }\n\n    if (tz <= min) {\n      normal.set(0, 0, 1);\n    }\n\n    vec.crossVectors(tangents[0], normal).normalize();\n    normals[0].crossVectors(tangents[0], vec);\n    binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n    for (var _i = 1; _i <= segments; _i++) {\n      normals[_i] = normals[_i - 1].clone();\n      binormals[_i] = binormals[_i - 1].clone();\n      vec.crossVectors(tangents[_i - 1], tangents[_i]);\n\n      if (vec.length() > Number.EPSILON) {\n        vec.normalize();\n        var theta = Math.acos(MathUtils.clamp(tangents[_i - 1].dot(tangents[_i]), -1, 1)); // clamp for floating pt errors\n\n        normals[_i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n      }\n\n      binormals[_i].crossVectors(tangents[_i], normals[_i]);\n    } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\n    if (closed === true) {\n      var _theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));\n\n      _theta /= segments;\n\n      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\n        _theta = -_theta;\n      }\n\n      for (var _i2 = 1; _i2 <= segments; _i2++) {\n        // twist a little...\n        normals[_i2].applyMatrix4(mat.makeRotationAxis(tangents[_i2], _theta * _i2));\n\n        binormals[_i2].crossVectors(tangents[_i2], normals[_i2]);\n      }\n    }\n\n    return {\n      tangents: tangents,\n      normals: normals,\n      binormals: binormals\n    };\n  },\n  clone: function clone() {\n    return new this.constructor().copy(this);\n  },\n  copy: function copy(source) {\n    this.arcLengthDivisions = source.arcLengthDivisions;\n    return this;\n  },\n  toJSON: function toJSON() {\n    var data = {\n      metadata: {\n        version: 4.5,\n        type: 'Curve',\n        generator: 'Curve.toJSON'\n      }\n    };\n    data.arcLengthDivisions = this.arcLengthDivisions;\n    data.type = this.type;\n    return data;\n  },\n  fromJSON: function fromJSON(json) {\n    this.arcLengthDivisions = json.arcLengthDivisions;\n    return this;\n  }\n});\nexport { Curve };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/extras/core/Curve.js"],"names":["MathUtils","Vector2","Vector3","Matrix4","Curve","type","arcLengthDivisions","Object","assign","prototype","getPoint","console","warn","getPointAt","u","optionalTarget","t","getUtoTmapping","getPoints","divisions","undefined","points","d","push","getSpacedPoints","getLength","lengths","getLengths","length","cacheArcLengths","needsUpdate","cache","current","last","sum","p","distanceTo","updateArcLengths","distance","arcLengths","i","il","targetArcLength","low","high","comparison","Math","floor","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","delta","t1","t2","pt1","pt2","tangent","isVector2","copy","sub","normalize","getTangentAt","computeFrenetFrames","segments","closed","normal","tangents","normals","binormals","vec","mat","min","Number","MAX_VALUE","tx","abs","x","ty","y","tz","z","set","crossVectors","clone","EPSILON","theta","acos","clamp","dot","applyMatrix4","makeRotationAxis","constructor","source","toJSON","data","metadata","version","generator","fromJSON","json"],"mappings":"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","sourcesContent":["import { MathUtils } from '../../math/MathUtils.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\n\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nfunction Curve() {\n\n\tthis.type = 'Curve';\n\n\tthis.arcLengthDivisions = 200;\n\n}\n\nObject.assign( Curve.prototype, {\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint: function ( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\treturn null;\n\n\t},\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt: function ( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t},\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = 5;\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = 5;\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\t// Get total curve arc length\n\n\tgetLength: function () {\n\n\t\tconst lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t},\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = this.arcLengthDivisions;\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tconst cache = [];\n\t\tlet current, last = this.getPoint( 0 );\n\t\tlet sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( let p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t},\n\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping: function ( u, distance ) {\n\n\t\tconst arcLengths = this.getLengths();\n\n\t\tlet i = 0;\n\t\tconst il = arcLengths.length;\n\n\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tlet low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tconst lengthBefore = arcLengths[ i ];\n\t\tconst lengthAfter = arcLengths[ i + 1 ];\n\n\t\tconst segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tconst segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tconst t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t},\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent: function ( t, optionalTarget ) {\n\n\t\tconst delta = 0.0001;\n\t\tlet t1 = t - delta;\n\t\tlet t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tconst pt1 = this.getPoint( t1 );\n\t\tconst pt2 = this.getPoint( t2 );\n\n\t\tconst tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );\n\n\t\ttangent.copy( pt2 ).sub( pt1 ).normalize();\n\n\t\treturn tangent;\n\n\t},\n\n\tgetTangentAt: function ( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t, optionalTarget );\n\n\t},\n\n\tcomputeFrenetFrames: function ( segments, closed ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tconst normal = new Vector3();\n\n\t\tconst tangents = [];\n\t\tconst normals = [];\n\t\tconst binormals = [];\n\n\t\tconst vec = new Vector3();\n\t\tconst mat = new Matrix4();\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst u = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u, new Vector3() );\n\t\t\ttangents[ i ].normalize();\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tlet min = Number.MAX_VALUE;\n\t\tconst tx = Math.abs( tangents[ 0 ].x );\n\t\tconst ty = Math.abs( tangents[ 0 ].y );\n\t\tconst tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\tconst theta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\tlet theta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t},\n\n\tfromJSON: function ( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n\nexport { Curve };\n"]},"metadata":{},"sourceType":"module"}