{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass CylinderBufferGeometry extends BufferGeometry {\n  constructor(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {\n    super();\n    this.type = 'CylinderBufferGeometry';\n    this.parameters = {\n      radiusTop: radiusTop,\n      radiusBottom: radiusBottom,\n      height: height,\n      radialSegments: radialSegments,\n      heightSegments: heightSegments,\n      openEnded: openEnded,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    var scope = this;\n    radiusTop = radiusTop !== undefined ? radiusTop : 1;\n    radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\n    height = height || 1;\n    radialSegments = Math.floor(radialSegments) || 8;\n    heightSegments = Math.floor(heightSegments) || 1;\n    openEnded = openEnded !== undefined ? openEnded : false;\n    thetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2; // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helper variables\n\n    var index = 0;\n    var indexArray = [];\n    var halfHeight = height / 2;\n    var groupStart = 0; // generate geometry\n\n    generateTorso();\n\n    if (openEnded === false) {\n      if (radiusTop > 0) generateCap(true);\n      if (radiusBottom > 0) generateCap(false);\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    function generateTorso() {\n      var normal = new Vector3();\n      var vertex = new Vector3();\n      var groupCount = 0; // this will be used to calculate the normal\n\n      var slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs\n\n      for (var y = 0; y <= heightSegments; y++) {\n        var indexRow = [];\n        var v = y / heightSegments; // calculate the radius of the current row\n\n        var radius = v * (radiusBottom - radiusTop) + radiusTop;\n\n        for (var x = 0; x <= radialSegments; x++) {\n          var u = x / radialSegments;\n          var theta = u * thetaLength + thetaStart;\n          var sinTheta = Math.sin(theta);\n          var cosTheta = Math.cos(theta); // vertex\n\n          vertex.x = radius * sinTheta;\n          vertex.y = -v * height + halfHeight;\n          vertex.z = radius * cosTheta;\n          vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n          normal.set(sinTheta, slope, cosTheta).normalize();\n          normals.push(normal.x, normal.y, normal.z); // uv\n\n          uvs.push(u, 1 - v); // save index of vertex in respective row\n\n          indexRow.push(index++);\n        } // now save vertices of the row in our index array\n\n\n        indexArray.push(indexRow);\n      } // generate indices\n\n\n      for (var _x = 0; _x < radialSegments; _x++) {\n        for (var _y = 0; _y < heightSegments; _y++) {\n          // we use the index array to access the correct indices\n          var a = indexArray[_y][_x];\n          var b = indexArray[_y + 1][_x];\n          var c = indexArray[_y + 1][_x + 1];\n          var d = indexArray[_y][_x + 1]; // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d); // update group counter\n\n          groupCount += 6;\n        }\n      } // add a group to the geometry. this will ensure multi material support\n\n\n      scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups\n\n      groupStart += groupCount;\n    }\n\n    function generateCap(top) {\n      // save the index of the first center vertex\n      var centerIndexStart = index;\n      var uv = new Vector2();\n      var vertex = new Vector3();\n      var groupCount = 0;\n      var radius = top === true ? radiusTop : radiusBottom;\n      var sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.\n      // because the geometry needs one set of uvs per face,\n      // we must generate a center vertex per face/segment\n\n      for (var x = 1; x <= radialSegments; x++) {\n        // vertex\n        vertices.push(0, halfHeight * sign, 0); // normal\n\n        normals.push(0, sign, 0); // uv\n\n        uvs.push(0.5, 0.5); // increase index\n\n        index++;\n      } // save the index of the last center vertex\n\n\n      var centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs\n\n      for (var _x2 = 0; _x2 <= radialSegments; _x2++) {\n        var u = _x2 / radialSegments;\n        var theta = u * thetaLength + thetaStart;\n        var cosTheta = Math.cos(theta);\n        var sinTheta = Math.sin(theta); // vertex\n\n        vertex.x = radius * sinTheta;\n        vertex.y = halfHeight * sign;\n        vertex.z = radius * cosTheta;\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n        normals.push(0, sign, 0); // uv\n\n        uv.x = cosTheta * 0.5 + 0.5;\n        uv.y = sinTheta * 0.5 * sign + 0.5;\n        uvs.push(uv.x, uv.y); // increase index\n\n        index++;\n      } // generate indices\n\n\n      for (var _x3 = 0; _x3 < radialSegments; _x3++) {\n        var c = centerIndexStart + _x3;\n        var i = centerIndexEnd + _x3;\n\n        if (top === true) {\n          // face top\n          indices.push(i, i + 1, c);\n        } else {\n          // face bottom\n          indices.push(i + 1, i, c);\n        }\n\n        groupCount += 3;\n      } // add a group to the geometry. this will ensure multi material support\n\n\n      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups\n\n      groupStart += groupCount;\n    }\n  }\n\n}\n\nexport { CylinderBufferGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/CylinderBufferGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","Vector2","CylinderBufferGeometry","constructor","radiusTop","radiusBottom","height","radialSegments","heightSegments","openEnded","thetaStart","thetaLength","type","parameters","scope","undefined","Math","floor","PI","indices","vertices","normals","uvs","index","indexArray","halfHeight","groupStart","generateTorso","generateCap","setIndex","setAttribute","normal","vertex","groupCount","slope","y","indexRow","v","radius","x","u","theta","sinTheta","sin","cosTheta","cos","z","push","set","normalize","a","b","c","d","addGroup","top","centerIndexStart","uv","sign","centerIndexEnd","i"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass CylinderBufferGeometry extends BufferGeometry {\n\n\tconstructor( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\t\tsuper();\n\t\tthis.type = 'CylinderBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tconst scope = this;\n\n\t\tradiusTop = radiusTop !== undefined ? radiusTop : 1;\n\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\n\t\theight = height || 1;\n\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\n\t\topenEnded = openEnded !== undefined ? openEnded : false;\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet index = 0;\n\t\tconst indexArray = [];\n\t\tconst halfHeight = height / 2;\n\t\tlet groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction generateTorso() {\n\n\t\t\tconst normal = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tconst slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tconst indexRow = [];\n\n\t\t\t\tconst v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\n\t\t\t\tconst radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tconst u = x / radialSegments;\n\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tconst sinTheta = Math.sin( theta );\n\t\t\t\t\tconst cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\n\t\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\t\tconst a = indexArray[ y ][ x ];\n\t\t\t\t\tconst b = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tconst c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tconst d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// update group counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\t// save the index of the first center vertex\n\t\t\tconst centerIndexStart = index;\n\n\t\t\tconst uv = new Vector2();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tconst sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( let x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tconst centerIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tconst u = x / radialSegments;\n\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\tconst cosTheta = Math.cos( theta );\n\t\t\t\tconst sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tconst c = centerIndexStart + x;\n\t\t\t\tconst i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\n\t\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\n\t\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t\t}\n\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { CylinderBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}