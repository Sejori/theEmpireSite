{"ast":null,"code":"import { BufferAttribute } from '../core/BufferAttribute.js';\nimport { Mesh } from './Mesh.js';\nimport { Matrix4 } from '../math/Matrix4.js';\n\nvar _instanceLocalMatrix = new Matrix4();\n\nvar _instanceWorldMatrix = new Matrix4();\n\nvar _instanceIntersects = [];\n\nvar _mesh = new Mesh();\n\nfunction InstancedMesh(geometry, material, count) {\n  Mesh.call(this, geometry, material);\n  this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);\n  this.instanceColor = null;\n  this.count = count;\n  this.frustumCulled = false;\n}\n\nInstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: InstancedMesh,\n  isInstancedMesh: true,\n  copy: function copy(source) {\n    Mesh.prototype.copy.call(this, source);\n    this.instanceMatrix.copy(source.instanceMatrix);\n    this.count = source.count;\n    return this;\n  },\n  setColorAt: function setColorAt(index, color) {\n    if (this.instanceColor === null) {\n      this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);\n    }\n\n    color.toArray(this.instanceColor.array, index * 3);\n  },\n  getMatrixAt: function getMatrixAt(index, matrix) {\n    matrix.fromArray(this.instanceMatrix.array, index * 16);\n  },\n  raycast: function raycast(raycaster, intersects) {\n    var matrixWorld = this.matrixWorld;\n    var raycastTimes = this.count;\n    _mesh.geometry = this.geometry;\n    _mesh.material = this.material;\n    if (_mesh.material === undefined) return;\n\n    for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {\n      // calculate the world matrix for each instance\n      this.getMatrixAt(instanceId, _instanceLocalMatrix);\n\n      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance\n\n\n      _mesh.matrixWorld = _instanceWorldMatrix;\n\n      _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast\n\n\n      for (var i = 0, l = _instanceIntersects.length; i < l; i++) {\n        var intersect = _instanceIntersects[i];\n        intersect.instanceId = instanceId;\n        intersect.object = this;\n        intersects.push(intersect);\n      }\n\n      _instanceIntersects.length = 0;\n    }\n  },\n  setMatrixAt: function setMatrixAt(index, matrix) {\n    matrix.toArray(this.instanceMatrix.array, index * 16);\n  },\n  updateMorphTargets: function updateMorphTargets() {}\n});\nexport { InstancedMesh };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/objects/InstancedMesh.js"],"names":["BufferAttribute","Mesh","Matrix4","_instanceLocalMatrix","_instanceWorldMatrix","_instanceIntersects","_mesh","InstancedMesh","geometry","material","count","call","instanceMatrix","Float32Array","instanceColor","frustumCulled","prototype","Object","assign","create","constructor","isInstancedMesh","copy","source","setColorAt","index","color","toArray","array","getMatrixAt","matrix","fromArray","raycast","raycaster","intersects","matrixWorld","raycastTimes","undefined","instanceId","multiplyMatrices","i","l","length","intersect","object","push","setMatrixAt","updateMorphTargets"],"mappings":"AAAA,SAASA,eAAT,QAAgC,4BAAhC;AACA,SAASC,IAAT,QAAqB,WAArB;AACA,SAASC,OAAT,QAAwB,oBAAxB;;AAEA,IAAMC,oBAAoB,GAAG,IAAID,OAAJ,EAA7B;;AACA,IAAME,oBAAoB,GAAG,IAAIF,OAAJ,EAA7B;;AAEA,IAAMG,mBAAmB,GAAG,EAA5B;;AAEA,IAAMC,KAAK,GAAG,IAAIL,IAAJ,EAAd;;AAEA,SAASM,aAAT,CAAwBC,QAAxB,EAAkCC,QAAlC,EAA4CC,KAA5C,EAAoD;AAEnDT,EAAAA,IAAI,CAACU,IAAL,CAAW,IAAX,EAAiBH,QAAjB,EAA2BC,QAA3B;AAEA,OAAKG,cAAL,GAAsB,IAAIZ,eAAJ,CAAqB,IAAIa,YAAJ,CAAkBH,KAAK,GAAG,EAA1B,CAArB,EAAqD,EAArD,CAAtB;AACA,OAAKI,aAAL,GAAqB,IAArB;AAEA,OAAKJ,KAAL,GAAaA,KAAb;AAEA,OAAKK,aAAL,GAAqB,KAArB;AAEA;;AAEDR,aAAa,CAACS,SAAd,GAA0BC,MAAM,CAACC,MAAP,CAAeD,MAAM,CAACE,MAAP,CAAelB,IAAI,CAACe,SAApB,CAAf,EAAgD;AAEzEI,EAAAA,WAAW,EAAEb,aAF4D;AAIzEc,EAAAA,eAAe,EAAE,IAJwD;AAMzEC,EAAAA,IAAI,EAAE,cAAWC,MAAX,EAAoB;AAEzBtB,IAAAA,IAAI,CAACe,SAAL,CAAeM,IAAf,CAAoBX,IAApB,CAA0B,IAA1B,EAAgCY,MAAhC;AAEA,SAAKX,cAAL,CAAoBU,IAApB,CAA0BC,MAAM,CAACX,cAAjC;AACA,SAAKF,KAAL,GAAaa,MAAM,CAACb,KAApB;AAEA,WAAO,IAAP;AAEA,GAfwE;AAiBzEc,EAAAA,UAAU,EAAE,oBAAWC,KAAX,EAAkBC,KAAlB,EAA0B;AAErC,QAAK,KAAKZ,aAAL,KAAuB,IAA5B,EAAmC;AAElC,WAAKA,aAAL,GAAqB,IAAId,eAAJ,CAAqB,IAAIa,YAAJ,CAAkB,KAAKH,KAAL,GAAa,CAA/B,CAArB,EAAyD,CAAzD,CAArB;AAEA;;AAEDgB,IAAAA,KAAK,CAACC,OAAN,CAAe,KAAKb,aAAL,CAAmBc,KAAlC,EAAyCH,KAAK,GAAG,CAAjD;AAEA,GA3BwE;AA6BzEI,EAAAA,WAAW,EAAE,qBAAWJ,KAAX,EAAkBK,MAAlB,EAA2B;AAEvCA,IAAAA,MAAM,CAACC,SAAP,CAAkB,KAAKnB,cAAL,CAAoBgB,KAAtC,EAA6CH,KAAK,GAAG,EAArD;AAEA,GAjCwE;AAmCzEO,EAAAA,OAAO,EAAE,iBAAWC,SAAX,EAAsBC,UAAtB,EAAmC;AAE3C,QAAMC,WAAW,GAAG,KAAKA,WAAzB;AACA,QAAMC,YAAY,GAAG,KAAK1B,KAA1B;AAEAJ,IAAAA,KAAK,CAACE,QAAN,GAAiB,KAAKA,QAAtB;AACAF,IAAAA,KAAK,CAACG,QAAN,GAAiB,KAAKA,QAAtB;AAEA,QAAKH,KAAK,CAACG,QAAN,KAAmB4B,SAAxB,EAAoC;;AAEpC,SAAM,IAAIC,UAAU,GAAG,CAAvB,EAA0BA,UAAU,GAAGF,YAAvC,EAAqDE,UAAU,EAA/D,EAAqE;AAEpE;AAEA,WAAKT,WAAL,CAAkBS,UAAlB,EAA8BnC,oBAA9B;;AAEAC,MAAAA,oBAAoB,CAACmC,gBAArB,CAAuCJ,WAAvC,EAAoDhC,oBAApD,EANoE,CAQpE;;;AAEAG,MAAAA,KAAK,CAAC6B,WAAN,GAAoB/B,oBAApB;;AAEAE,MAAAA,KAAK,CAAC0B,OAAN,CAAeC,SAAf,EAA0B5B,mBAA1B,EAZoE,CAcpE;;;AAEA,WAAM,IAAImC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGpC,mBAAmB,CAACqC,MAAzC,EAAiDF,CAAC,GAAGC,CAArD,EAAwDD,CAAC,EAAzD,EAA+D;AAE9D,YAAMG,SAAS,GAAGtC,mBAAmB,CAAEmC,CAAF,CAArC;AACAG,QAAAA,SAAS,CAACL,UAAV,GAAuBA,UAAvB;AACAK,QAAAA,SAAS,CAACC,MAAV,GAAmB,IAAnB;AACAV,QAAAA,UAAU,CAACW,IAAX,CAAiBF,SAAjB;AAEA;;AAEDtC,MAAAA,mBAAmB,CAACqC,MAApB,GAA6B,CAA7B;AAEA;AAED,GA1EwE;AA4EzEI,EAAAA,WAAW,EAAE,qBAAWrB,KAAX,EAAkBK,MAAlB,EAA2B;AAEvCA,IAAAA,MAAM,CAACH,OAAP,CAAgB,KAAKf,cAAL,CAAoBgB,KAApC,EAA2CH,KAAK,GAAG,EAAnD;AAEA,GAhFwE;AAkFzEsB,EAAAA,kBAAkB,EAAE,8BAAY,CAE/B;AApFwE,CAAhD,CAA1B;AAwFA,SAASxC,aAAT","sourcesContent":["import { BufferAttribute } from '../core/BufferAttribute.js';\nimport { Mesh } from './Mesh.js';\nimport { Matrix4 } from '../math/Matrix4.js';\n\nconst _instanceLocalMatrix = new Matrix4();\nconst _instanceWorldMatrix = new Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _mesh = new Mesh();\n\nfunction InstancedMesh( geometry, material, count ) {\n\n\tMesh.call( this, geometry, material );\n\n\tthis.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );\n\tthis.instanceColor = null;\n\n\tthis.count = count;\n\n\tthis.frustumCulled = false;\n\n}\n\nInstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\tconstructor: InstancedMesh,\n\n\tisInstancedMesh: true,\n\n\tcopy: function ( source ) {\n\n\t\tMesh.prototype.copy.call( this, source );\n\n\t\tthis.instanceMatrix.copy( source.instanceMatrix );\n\t\tthis.count = source.count;\n\n\t\treturn this;\n\n\t},\n\n\tsetColorAt: function ( index, color ) {\n\n\t\tif ( this.instanceColor === null ) {\n\n\t\t\tthis.instanceColor = new BufferAttribute( new Float32Array( this.count * 3 ), 3 );\n\n\t\t}\n\n\t\tcolor.toArray( this.instanceColor.array, index * 3 );\n\n\t},\n\n\tgetMatrixAt: function ( index, matrix ) {\n\n\t\tmatrix.fromArray( this.instanceMatrix.array, index * 16 );\n\n\t},\n\n\traycast: function ( raycaster, intersects ) {\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst raycastTimes = this.count;\n\n\t\t_mesh.geometry = this.geometry;\n\t\t_mesh.material = this.material;\n\n\t\tif ( _mesh.material === undefined ) return;\n\n\t\tfor ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {\n\n\t\t\t// calculate the world matrix for each instance\n\n\t\t\tthis.getMatrixAt( instanceId, _instanceLocalMatrix );\n\n\t\t\t_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );\n\n\t\t\t// the mesh represents this single instance\n\n\t\t\t_mesh.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t_mesh.raycast( raycaster, _instanceIntersects );\n\n\t\t\t// process the result of raycast\n\n\t\t\tfor ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {\n\n\t\t\t\tconst intersect = _instanceIntersects[ i ];\n\t\t\t\tintersect.instanceId = instanceId;\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_instanceIntersects.length = 0;\n\n\t\t}\n\n\t},\n\n\tsetMatrixAt: function ( index, matrix ) {\n\n\t\tmatrix.toArray( this.instanceMatrix.array, index * 16 );\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t}\n\n} );\n\nexport { InstancedMesh };\n"]},"metadata":{},"sourceType":"module"}