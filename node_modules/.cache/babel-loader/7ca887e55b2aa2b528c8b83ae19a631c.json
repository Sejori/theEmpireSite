{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n\nclass PlaneBufferGeometry extends BufferGeometry {\n  constructor(width, height, widthSegments, heightSegments) {\n    super();\n    this.type = 'PlaneBufferGeometry';\n    this.parameters = {\n      width: width,\n      height: height,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments\n    };\n    width = width || 1;\n    height = height || 1;\n    var width_half = width / 2;\n    var height_half = height / 2;\n    var gridX = Math.floor(widthSegments) || 1;\n    var gridY = Math.floor(heightSegments) || 1;\n    var gridX1 = gridX + 1;\n    var gridY1 = gridY + 1;\n    var segment_width = width / gridX;\n    var segment_height = height / gridY; // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // generate vertices, normals and uvs\n\n    for (var iy = 0; iy < gridY1; iy++) {\n      var y = iy * segment_height - height_half;\n\n      for (var ix = 0; ix < gridX1; ix++) {\n        var x = ix * segment_width - width_half;\n        vertices.push(x, -y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(ix / gridX);\n        uvs.push(1 - iy / gridY);\n      }\n    } // indices\n\n\n    for (var _iy = 0; _iy < gridY; _iy++) {\n      for (var _ix = 0; _ix < gridX; _ix++) {\n        var a = _ix + gridX1 * _iy;\n        var b = _ix + gridX1 * (_iy + 1);\n        var c = _ix + 1 + gridX1 * (_iy + 1);\n        var d = _ix + 1 + gridX1 * _iy; // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n\n}\n\nexport { PlaneBufferGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/PlaneBufferGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","PlaneBufferGeometry","constructor","width","height","widthSegments","heightSegments","type","parameters","width_half","height_half","gridX","Math","floor","gridY","gridX1","gridY1","segment_width","segment_height","indices","vertices","normals","uvs","iy","y","ix","x","push","a","b","c","d","setIndex","setAttribute"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n\nclass PlaneBufferGeometry extends BufferGeometry {\n\n\tconstructor( width, height, widthSegments, heightSegments ) {\n\n\t\tsuper();\n\t\tthis.type = 'PlaneBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\twidth = width || 1;\n\t\theight = height || 1;\n\n\t\tconst width_half = width / 2;\n\t\tconst height_half = height / 2;\n\n\t\tconst gridX = Math.floor( widthSegments ) || 1;\n\t\tconst gridY = Math.floor( heightSegments ) || 1;\n\n\t\tconst gridX1 = gridX + 1;\n\t\tconst gridY1 = gridY + 1;\n\n\t\tconst segment_width = width / gridX;\n\t\tconst segment_height = height / gridY;\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tconst y = iy * segment_height - height_half;\n\n\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tconst x = ix * segment_width - width_half;\n\n\t\t\t\tvertices.push( x, - y, 0 );\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tconst a = ix + gridX1 * iy;\n\t\t\t\tconst b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tconst c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tconst d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n}\n\n\nexport { PlaneBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}