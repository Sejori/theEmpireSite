{"ast":null,"code":"import { Mesh } from './Mesh.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector4 } from '../math/Vector4.js';\n\nfunction SkinnedMesh(geometry, material) {\n  if (geometry && geometry.isGeometry) {\n    console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n  }\n\n  Mesh.call(this, geometry, material);\n  this.type = 'SkinnedMesh';\n  this.bindMode = 'attached';\n  this.bindMatrix = new Matrix4();\n  this.bindMatrixInverse = new Matrix4();\n}\n\nSkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: SkinnedMesh,\n  isSkinnedMesh: true,\n  copy: function copy(source) {\n    Mesh.prototype.copy.call(this, source);\n    this.bindMode = source.bindMode;\n    this.bindMatrix.copy(source.bindMatrix);\n    this.bindMatrixInverse.copy(source.bindMatrixInverse);\n    this.skeleton = source.skeleton;\n    return this;\n  },\n  bind: function bind(skeleton, bindMatrix) {\n    this.skeleton = skeleton;\n\n    if (bindMatrix === undefined) {\n      this.updateMatrixWorld(true);\n      this.skeleton.calculateInverses();\n      bindMatrix = this.matrixWorld;\n    }\n\n    this.bindMatrix.copy(bindMatrix);\n    this.bindMatrixInverse.getInverse(bindMatrix);\n  },\n  pose: function pose() {\n    this.skeleton.pose();\n  },\n  normalizeSkinWeights: function normalizeSkinWeights() {\n    var vector = new Vector4();\n    var skinWeight = this.geometry.attributes.skinWeight;\n\n    for (var i = 0, l = skinWeight.count; i < l; i++) {\n      vector.x = skinWeight.getX(i);\n      vector.y = skinWeight.getY(i);\n      vector.z = skinWeight.getZ(i);\n      vector.w = skinWeight.getW(i);\n      var scale = 1.0 / vector.manhattanLength();\n\n      if (scale !== Infinity) {\n        vector.multiplyScalar(scale);\n      } else {\n        vector.set(1, 0, 0, 0); // do something reasonable\n      }\n\n      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);\n    }\n  },\n  updateMatrixWorld: function updateMatrixWorld(force) {\n    Mesh.prototype.updateMatrixWorld.call(this, force);\n\n    if (this.bindMode === 'attached') {\n      this.bindMatrixInverse.getInverse(this.matrixWorld);\n    } else if (this.bindMode === 'detached') {\n      this.bindMatrixInverse.getInverse(this.bindMatrix);\n    } else {\n      console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);\n    }\n  },\n  boneTransform: function () {\n    var basePosition = new Vector3();\n    var skinIndex = new Vector4();\n    var skinWeight = new Vector4();\n    var vector = new Vector3();\n    var matrix = new Matrix4();\n    return function (index, target) {\n      var skeleton = this.skeleton;\n      var geometry = this.geometry;\n      skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n      skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n      basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);\n      target.set(0, 0, 0);\n\n      for (var i = 0; i < 4; i++) {\n        var weight = skinWeight.getComponent(i);\n\n        if (weight !== 0) {\n          var boneIndex = skinIndex.getComponent(i);\n          matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);\n          target.addScaledVector(vector.copy(basePosition).applyMatrix4(matrix), weight);\n        }\n      }\n\n      return target.applyMatrix4(this.bindMatrixInverse);\n    };\n  }()\n});\nexport { SkinnedMesh };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/objects/SkinnedMesh.js"],"names":["Mesh","Matrix4","Vector3","Vector4","SkinnedMesh","geometry","material","isGeometry","console","error","call","type","bindMode","bindMatrix","bindMatrixInverse","prototype","Object","assign","create","constructor","isSkinnedMesh","copy","source","skeleton","bind","undefined","updateMatrixWorld","calculateInverses","matrixWorld","getInverse","pose","normalizeSkinWeights","vector","skinWeight","attributes","i","l","count","x","getX","y","getY","z","getZ","w","getW","scale","manhattanLength","Infinity","multiplyScalar","set","setXYZW","force","warn","boneTransform","basePosition","skinIndex","matrix","index","target","fromBufferAttribute","position","applyMatrix4","weight","getComponent","boneIndex","multiplyMatrices","bones","boneInverses","addScaledVector"],"mappings":"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","sourcesContent":["import { Mesh } from './Mesh.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector4 } from '../math/Vector4.js';\n\nfunction SkinnedMesh( geometry, material ) {\n\n\tif ( geometry && geometry.isGeometry ) {\n\n\t\tconsole.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t}\n\n\tMesh.call( this, geometry, material );\n\n\tthis.type = 'SkinnedMesh';\n\n\tthis.bindMode = 'attached';\n\tthis.bindMatrix = new Matrix4();\n\tthis.bindMatrixInverse = new Matrix4();\n\n}\n\nSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n\tconstructor: SkinnedMesh,\n\n\tisSkinnedMesh: true,\n\n\tcopy: function ( source ) {\n\n\t\tMesh.prototype.copy.call( this, source );\n\n\t\tthis.bindMode = source.bindMode;\n\t\tthis.bindMatrix.copy( source.bindMatrix );\n\t\tthis.bindMatrixInverse.copy( source.bindMatrixInverse );\n\n\t\tthis.skeleton = source.skeleton;\n\n\t\treturn this;\n\n\t},\n\n\tbind: function ( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t},\n\n\tpose: function () {\n\n\t\tthis.skeleton.pose();\n\n\t},\n\n\tnormalizeSkinWeights: function () {\n\n\t\tconst vector = new Vector4();\n\n\t\tconst skinWeight = this.geometry.attributes.skinWeight;\n\n\t\tfor ( let i = 0, l = skinWeight.count; i < l; i ++ ) {\n\n\t\t\tvector.x = skinWeight.getX( i );\n\t\t\tvector.y = skinWeight.getY( i );\n\t\t\tvector.z = skinWeight.getZ( i );\n\t\t\tvector.w = skinWeight.getW( i );\n\n\t\t\tconst scale = 1.0 / vector.manhattanLength();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tvector.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tvector.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t}\n\n\t\t\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\n\n\t\t}\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tMesh.prototype.updateMatrixWorld.call( this, force );\n\n\t\tif ( this.bindMode === 'attached' ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t} else if ( this.bindMode === 'detached' ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t},\n\n\tboneTransform: ( function () {\n\n\t\tconst basePosition = new Vector3();\n\n\t\tconst skinIndex = new Vector4();\n\t\tconst skinWeight = new Vector4();\n\n\t\tconst vector = new Vector3();\n\t\tconst matrix = new Matrix4();\n\n\t\treturn function ( index, target ) {\n\n\t\t\tconst skeleton = this.skeleton;\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tskinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t\t\tskinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t\t\tbasePosition.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );\n\n\t\t\ttarget.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst weight = skinWeight.getComponent( i );\n\n\t\t\t\tif ( weight !== 0 ) {\n\n\t\t\t\t\tconst boneIndex = skinIndex.getComponent( i );\n\n\t\t\t\t\tmatrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );\n\n\t\t\t\t\ttarget.addScaledVector( vector.copy( basePosition ).applyMatrix4( matrix ), weight );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn target.applyMatrix4( this.bindMatrixInverse );\n\n\t\t};\n\n\t}() )\n\n} );\n\n\nexport { SkinnedMesh };\n"]},"metadata":{},"sourceType":"module"}