{"ast":null,"code":"import { Line } from './Line.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n\nvar _start = new Vector3();\n\nvar _end = new Vector3();\n\nfunction LineSegments(geometry, material) {\n  Line.call(this, geometry, material);\n  this.type = 'LineSegments';\n}\n\nLineSegments.prototype = Object.assign(Object.create(Line.prototype), {\n  constructor: LineSegments,\n  isLineSegments: true,\n  computeLineDistances: function computeLineDistances() {\n    var geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      // we assume non-indexed geometry\n      if (geometry.index === null) {\n        var positionAttribute = geometry.attributes.position;\n        var lineDistances = [];\n\n        for (var i = 0, l = positionAttribute.count; i < l; i += 2) {\n          _start.fromBufferAttribute(positionAttribute, i);\n\n          _end.fromBufferAttribute(positionAttribute, i + 1);\n\n          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];\n          lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);\n        }\n\n        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n      } else {\n        console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n      }\n    } else if (geometry.isGeometry) {\n      var vertices = geometry.vertices;\n      var _lineDistances = geometry.lineDistances;\n\n      for (var _i = 0, _l = vertices.length; _i < _l; _i += 2) {\n        _start.copy(vertices[_i]);\n\n        _end.copy(vertices[_i + 1]);\n\n        _lineDistances[_i] = _i === 0 ? 0 : _lineDistances[_i - 1];\n        _lineDistances[_i + 1] = _lineDistances[_i] + _start.distanceTo(_end);\n      }\n    }\n\n    return this;\n  }\n});\nexport { LineSegments };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/objects/LineSegments.js"],"names":["Line","Vector3","Float32BufferAttribute","_start","_end","LineSegments","geometry","material","call","type","prototype","Object","assign","create","constructor","isLineSegments","computeLineDistances","isBufferGeometry","index","positionAttribute","attributes","position","lineDistances","i","l","count","fromBufferAttribute","distanceTo","setAttribute","console","warn","isGeometry","vertices","length","copy"],"mappings":"AAAA,SAASA,IAAT,QAAqB,WAArB;AACA,SAASC,OAAT,QAAwB,oBAAxB;AACA,SAASC,sBAAT,QAAuC,4BAAvC;;AAEA,IAAMC,MAAM,GAAG,IAAIF,OAAJ,EAAf;;AACA,IAAMG,IAAI,GAAG,IAAIH,OAAJ,EAAb;;AAEA,SAASI,YAAT,CAAuBC,QAAvB,EAAiCC,QAAjC,EAA4C;AAE3CP,EAAAA,IAAI,CAACQ,IAAL,CAAW,IAAX,EAAiBF,QAAjB,EAA2BC,QAA3B;AAEA,OAAKE,IAAL,GAAY,cAAZ;AAEA;;AAEDJ,YAAY,CAACK,SAAb,GAAyBC,MAAM,CAACC,MAAP,CAAeD,MAAM,CAACE,MAAP,CAAeb,IAAI,CAACU,SAApB,CAAf,EAAgD;AAExEI,EAAAA,WAAW,EAAET,YAF2D;AAIxEU,EAAAA,cAAc,EAAE,IAJwD;AAMxEC,EAAAA,oBAAoB,EAAE,gCAAY;AAEjC,QAAMV,QAAQ,GAAG,KAAKA,QAAtB;;AAEA,QAAKA,QAAQ,CAACW,gBAAd,EAAiC;AAEhC;AAEA,UAAKX,QAAQ,CAACY,KAAT,KAAmB,IAAxB,EAA+B;AAE9B,YAAMC,iBAAiB,GAAGb,QAAQ,CAACc,UAAT,CAAoBC,QAA9C;AACA,YAAMC,aAAa,GAAG,EAAtB;;AAEA,aAAM,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGL,iBAAiB,CAACM,KAAvC,EAA8CF,CAAC,GAAGC,CAAlD,EAAqDD,CAAC,IAAI,CAA1D,EAA8D;AAE7DpB,UAAAA,MAAM,CAACuB,mBAAP,CAA4BP,iBAA5B,EAA+CI,CAA/C;;AACAnB,UAAAA,IAAI,CAACsB,mBAAL,CAA0BP,iBAA1B,EAA6CI,CAAC,GAAG,CAAjD;;AAEAD,UAAAA,aAAa,CAAEC,CAAF,CAAb,GAAuBA,CAAC,KAAK,CAAR,GAAc,CAAd,GAAkBD,aAAa,CAAEC,CAAC,GAAG,CAAN,CAApD;AACAD,UAAAA,aAAa,CAAEC,CAAC,GAAG,CAAN,CAAb,GAAyBD,aAAa,CAAEC,CAAF,CAAb,GAAqBpB,MAAM,CAACwB,UAAP,CAAmBvB,IAAnB,CAA9C;AAEA;;AAEDE,QAAAA,QAAQ,CAACsB,YAAT,CAAuB,cAAvB,EAAuC,IAAI1B,sBAAJ,CAA4BoB,aAA5B,EAA2C,CAA3C,CAAvC;AAEA,OAjBD,MAiBO;AAENO,QAAAA,OAAO,CAACC,IAAR,CAAc,uGAAd;AAEA;AAED,KA3BD,MA2BO,IAAKxB,QAAQ,CAACyB,UAAd,EAA2B;AAEjC,UAAMC,QAAQ,GAAG1B,QAAQ,CAAC0B,QAA1B;AACA,UAAMV,cAAa,GAAGhB,QAAQ,CAACgB,aAA/B;;AAEA,WAAM,IAAIC,EAAC,GAAG,CAAR,EAAWC,EAAC,GAAGQ,QAAQ,CAACC,MAA9B,EAAsCV,EAAC,GAAGC,EAA1C,EAA6CD,EAAC,IAAI,CAAlD,EAAsD;AAErDpB,QAAAA,MAAM,CAAC+B,IAAP,CAAaF,QAAQ,CAAET,EAAF,CAArB;;AACAnB,QAAAA,IAAI,CAAC8B,IAAL,CAAWF,QAAQ,CAAET,EAAC,GAAG,CAAN,CAAnB;;AAEAD,QAAAA,cAAa,CAAEC,EAAF,CAAb,GAAuBA,EAAC,KAAK,CAAR,GAAc,CAAd,GAAkBD,cAAa,CAAEC,EAAC,GAAG,CAAN,CAApD;AACAD,QAAAA,cAAa,CAAEC,EAAC,GAAG,CAAN,CAAb,GAAyBD,cAAa,CAAEC,EAAF,CAAb,GAAqBpB,MAAM,CAACwB,UAAP,CAAmBvB,IAAnB,CAA9C;AAEA;AAED;;AAED,WAAO,IAAP;AAEA;AAxDuE,CAAhD,CAAzB;AA6DA,SAASC,YAAT","sourcesContent":["import { Line } from './Line.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nfunction LineSegments( geometry, material ) {\n\n\tLine.call( this, geometry, material );\n\n\tthis.type = 'LineSegments';\n\n}\n\nLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\n\tconstructor: LineSegments,\n\n\tisLineSegments: true,\n\n\tcomputeLineDistances: function () {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t// we assume non-indexed geometry\n\n\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\t\tconst lineDistances = [];\n\n\t\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {\n\n\t\t\t\t\t_start.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\t_end.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tconst vertices = geometry.vertices;\n\t\t\tconst lineDistances = geometry.lineDistances;\n\n\t\t\tfor ( let i = 0, l = vertices.length; i < l; i += 2 ) {\n\n\t\t\t\t_start.copy( vertices[ i ] );\n\t\t\t\t_end.copy( vertices[ i + 1 ] );\n\n\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n\nexport { LineSegments };\n"]},"metadata":{},"sourceType":"module"}