{"ast":null,"code":"import { WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding, LoopPingPong, LoopOnce, LoopRepeat, NormalAnimationBlendMode, AdditiveAnimationBlendMode } from '../constants.js';\n\nclass AnimationAction {\n  constructor(mixer, clip, localRoot, blendMode) {\n    this._mixer = mixer;\n    this._clip = clip;\n    this._localRoot = localRoot || null;\n    this.blendMode = blendMode || clip.blendMode;\n    var tracks = clip.tracks,\n        nTracks = tracks.length,\n        interpolants = new Array(nTracks);\n    var interpolantSettings = {\n      endingStart: ZeroCurvatureEnding,\n      endingEnd: ZeroCurvatureEnding\n    };\n\n    for (var i = 0; i !== nTracks; ++i) {\n      var interpolant = tracks[i].createInterpolant(null);\n      interpolants[i] = interpolant;\n      interpolant.settings = interpolantSettings;\n    }\n\n    this._interpolantSettings = interpolantSettings;\n    this._interpolants = interpolants; // bound by the mixer\n    // inside: PropertyMixer (managed by the mixer)\n\n    this._propertyBindings = new Array(nTracks);\n    this._cacheIndex = null; // for the memory manager\n\n    this._byClipCacheIndex = null; // for the memory manager\n\n    this._timeScaleInterpolant = null;\n    this._weightInterpolant = null;\n    this.loop = LoopRepeat;\n    this._loopCount = -1; // global mixer time when the action is to be started\n    // it's set back to 'null' upon start of the action\n\n    this._startTime = null; // scaled local time of the action\n    // gets clamped or wrapped to 0..clip.duration according to loop\n\n    this.time = 0;\n    this.timeScale = 1;\n    this._effectiveTimeScale = 1;\n    this.weight = 1;\n    this._effectiveWeight = 1;\n    this.repetitions = Infinity; // no. of repetitions when looping\n\n    this.paused = false; // true -> zero effective time scale\n\n    this.enabled = true; // false -> zero effective weight\n\n    this.clampWhenFinished = false; // keep feeding the last frame?\n\n    this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate\n\n    this.zeroSlopeAtEnd = true; // clips for start, loop and end\n  } // State & Scheduling\n\n\n  play() {\n    this._mixer._activateAction(this);\n\n    return this;\n  }\n\n  stop() {\n    this._mixer._deactivateAction(this);\n\n    return this.reset();\n  }\n\n  reset() {\n    this.paused = false;\n    this.enabled = true;\n    this.time = 0; // restart clip\n\n    this._loopCount = -1; // forget previous loops\n\n    this._startTime = null; // forget scheduling\n\n    return this.stopFading().stopWarping();\n  }\n\n  isRunning() {\n    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);\n  } // return true when play has been called\n\n\n  isScheduled() {\n    return this._mixer._isActiveAction(this);\n  }\n\n  startAt(time) {\n    this._startTime = time;\n    return this;\n  }\n\n  setLoop(mode, repetitions) {\n    this.loop = mode;\n    this.repetitions = repetitions;\n    return this;\n  } // Weight\n  // set the weight stopping any scheduled fading\n  // although .enabled = false yields an effective weight of zero, this\n  // method does *not* change .enabled, because it would be confusing\n\n\n  setEffectiveWeight(weight) {\n    this.weight = weight; // note: same logic as when updated at runtime\n\n    this._effectiveWeight = this.enabled ? weight : 0;\n    return this.stopFading();\n  } // return the weight considering fading and .enabled\n\n\n  getEffectiveWeight() {\n    return this._effectiveWeight;\n  }\n\n  fadeIn(duration) {\n    return this._scheduleFading(duration, 0, 1);\n  }\n\n  fadeOut(duration) {\n    return this._scheduleFading(duration, 1, 0);\n  }\n\n  crossFadeFrom(fadeOutAction, duration, warp) {\n    fadeOutAction.fadeOut(duration);\n    this.fadeIn(duration);\n\n    if (warp) {\n      var fadeInDuration = this._clip.duration,\n          fadeOutDuration = fadeOutAction._clip.duration,\n          startEndRatio = fadeOutDuration / fadeInDuration,\n          endStartRatio = fadeInDuration / fadeOutDuration;\n      fadeOutAction.warp(1.0, startEndRatio, duration);\n      this.warp(endStartRatio, 1.0, duration);\n    }\n\n    return this;\n  }\n\n  crossFadeTo(fadeInAction, duration, warp) {\n    return fadeInAction.crossFadeFrom(this, duration, warp);\n  }\n\n  stopFading() {\n    var weightInterpolant = this._weightInterpolant;\n\n    if (weightInterpolant !== null) {\n      this._weightInterpolant = null;\n\n      this._mixer._takeBackControlInterpolant(weightInterpolant);\n    }\n\n    return this;\n  } // Time Scale Control\n  // set the time scale stopping any scheduled warping\n  // although .paused = true yields an effective time scale of zero, this\n  // method does *not* change .paused, because it would be confusing\n\n\n  setEffectiveTimeScale(timeScale) {\n    this.timeScale = timeScale;\n    this._effectiveTimeScale = this.paused ? 0 : timeScale;\n    return this.stopWarping();\n  } // return the time scale considering warping and .paused\n\n\n  getEffectiveTimeScale() {\n    return this._effectiveTimeScale;\n  }\n\n  setDuration(duration) {\n    this.timeScale = this._clip.duration / duration;\n    return this.stopWarping();\n  }\n\n  syncWith(action) {\n    this.time = action.time;\n    this.timeScale = action.timeScale;\n    return this.stopWarping();\n  }\n\n  halt(duration) {\n    return this.warp(this._effectiveTimeScale, 0, duration);\n  }\n\n  warp(startTimeScale, endTimeScale, duration) {\n    var mixer = this._mixer,\n        now = mixer.time,\n        timeScale = this.timeScale;\n    var interpolant = this._timeScaleInterpolant;\n\n    if (interpolant === null) {\n      interpolant = mixer._lendControlInterpolant();\n      this._timeScaleInterpolant = interpolant;\n    }\n\n    var times = interpolant.parameterPositions,\n        values = interpolant.sampleValues;\n    times[0] = now;\n    times[1] = now + duration;\n    values[0] = startTimeScale / timeScale;\n    values[1] = endTimeScale / timeScale;\n    return this;\n  }\n\n  stopWarping() {\n    var timeScaleInterpolant = this._timeScaleInterpolant;\n\n    if (timeScaleInterpolant !== null) {\n      this._timeScaleInterpolant = null;\n\n      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);\n    }\n\n    return this;\n  } // Object Accessors\n\n\n  getMixer() {\n    return this._mixer;\n  }\n\n  getClip() {\n    return this._clip;\n  }\n\n  getRoot() {\n    return this._localRoot || this._mixer._root;\n  } // Interna\n\n\n  _update(time, deltaTime, timeDirection, accuIndex) {\n    // called by the mixer\n    if (!this.enabled) {\n      // call ._updateWeight() to update ._effectiveWeight\n      this._updateWeight(time);\n\n      return;\n    }\n\n    var startTime = this._startTime;\n\n    if (startTime !== null) {\n      // check for scheduled start of action\n      var timeRunning = (time - startTime) * timeDirection;\n\n      if (timeRunning < 0 || timeDirection === 0) {\n        return; // yet to come / don't decide when delta = 0\n      } // start\n\n\n      this._startTime = null; // unschedule\n\n      deltaTime = timeDirection * timeRunning;\n    } // apply time scale and advance time\n\n\n    deltaTime *= this._updateTimeScale(time);\n\n    var clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in\n    // an effective weight of 0\n\n\n    var weight = this._updateWeight(time);\n\n    if (weight > 0) {\n      var interpolants = this._interpolants;\n      var propertyMixers = this._propertyBindings;\n\n      switch (this.blendMode) {\n        case AdditiveAnimationBlendMode:\n          for (var j = 0, m = interpolants.length; j !== m; ++j) {\n            interpolants[j].evaluate(clipTime);\n            propertyMixers[j].accumulateAdditive(weight);\n          }\n\n          break;\n\n        case NormalAnimationBlendMode:\n        default:\n          for (var _j = 0, _m = interpolants.length; _j !== _m; ++_j) {\n            interpolants[_j].evaluate(clipTime);\n\n            propertyMixers[_j].accumulate(accuIndex, weight);\n          }\n\n      }\n    }\n  }\n\n  _updateWeight(time) {\n    var weight = 0;\n\n    if (this.enabled) {\n      weight = this.weight;\n      var interpolant = this._weightInterpolant;\n\n      if (interpolant !== null) {\n        var interpolantValue = interpolant.evaluate(time)[0];\n        weight *= interpolantValue;\n\n        if (time > interpolant.parameterPositions[1]) {\n          this.stopFading();\n\n          if (interpolantValue === 0) {\n            // faded out, disable\n            this.enabled = false;\n          }\n        }\n      }\n    }\n\n    this._effectiveWeight = weight;\n    return weight;\n  }\n\n  _updateTimeScale(time) {\n    var timeScale = 0;\n\n    if (!this.paused) {\n      timeScale = this.timeScale;\n      var interpolant = this._timeScaleInterpolant;\n\n      if (interpolant !== null) {\n        var interpolantValue = interpolant.evaluate(time)[0];\n        timeScale *= interpolantValue;\n\n        if (time > interpolant.parameterPositions[1]) {\n          this.stopWarping();\n\n          if (timeScale === 0) {\n            // motion has halted, pause\n            this.paused = true;\n          } else {\n            // warp done - apply final time scale\n            this.timeScale = timeScale;\n          }\n        }\n      }\n    }\n\n    this._effectiveTimeScale = timeScale;\n    return timeScale;\n  }\n\n  _updateTime(deltaTime) {\n    var duration = this._clip.duration;\n    var loop = this.loop;\n    var time = this.time + deltaTime;\n    var loopCount = this._loopCount;\n    var pingPong = loop === LoopPingPong;\n\n    if (deltaTime === 0) {\n      if (loopCount === -1) return time;\n      return pingPong && (loopCount & 1) === 1 ? duration - time : time;\n    }\n\n    if (loop === LoopOnce) {\n      if (loopCount === -1) {\n        // just started\n        this._loopCount = 0;\n\n        this._setEndings(true, true, false);\n      }\n\n      handle_stop: {\n        if (time >= duration) {\n          time = duration;\n        } else if (time < 0) {\n          time = 0;\n        } else {\n          this.time = time;\n          break handle_stop;\n        }\n\n        if (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n        this.time = time;\n\n        this._mixer.dispatchEvent({\n          type: 'finished',\n          action: this,\n          direction: deltaTime < 0 ? -1 : 1\n        });\n      }\n    } else {\n      // repetitive Repeat or PingPong\n      if (loopCount === -1) {\n        // just started\n        if (deltaTime >= 0) {\n          loopCount = 0;\n\n          this._setEndings(true, this.repetitions === 0, pingPong);\n        } else {\n          // when looping in reverse direction, the initial\n          // transition through zero counts as a repetition,\n          // so leave loopCount at -1\n          this._setEndings(this.repetitions === 0, true, pingPong);\n        }\n      }\n\n      if (time >= duration || time < 0) {\n        // wrap around\n        var loopDelta = Math.floor(time / duration); // signed\n\n        time -= duration * loopDelta;\n        loopCount += Math.abs(loopDelta);\n        var pending = this.repetitions - loopCount;\n\n        if (pending <= 0) {\n          // have to stop (switch state, clamp time, fire event)\n          if (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n          time = deltaTime > 0 ? duration : 0;\n          this.time = time;\n\n          this._mixer.dispatchEvent({\n            type: 'finished',\n            action: this,\n            direction: deltaTime > 0 ? 1 : -1\n          });\n        } else {\n          // keep running\n          if (pending === 1) {\n            // entering the last round\n            var atStart = deltaTime < 0;\n\n            this._setEndings(atStart, !atStart, pingPong);\n          } else {\n            this._setEndings(false, false, pingPong);\n          }\n\n          this._loopCount = loopCount;\n          this.time = time;\n\n          this._mixer.dispatchEvent({\n            type: 'loop',\n            action: this,\n            loopDelta: loopDelta\n          });\n        }\n      } else {\n        this.time = time;\n      }\n\n      if (pingPong && (loopCount & 1) === 1) {\n        // invert time for the \"pong round\"\n        return duration - time;\n      }\n    }\n\n    return time;\n  }\n\n  _setEndings(atStart, atEnd, pingPong) {\n    var settings = this._interpolantSettings;\n\n    if (pingPong) {\n      settings.endingStart = ZeroSlopeEnding;\n      settings.endingEnd = ZeroSlopeEnding;\n    } else {\n      // assuming for LoopOnce atStart == atEnd == true\n      if (atStart) {\n        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n      } else {\n        settings.endingStart = WrapAroundEnding;\n      }\n\n      if (atEnd) {\n        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n      } else {\n        settings.endingEnd = WrapAroundEnding;\n      }\n    }\n  }\n\n  _scheduleFading(duration, weightNow, weightThen) {\n    var mixer = this._mixer,\n        now = mixer.time;\n    var interpolant = this._weightInterpolant;\n\n    if (interpolant === null) {\n      interpolant = mixer._lendControlInterpolant();\n      this._weightInterpolant = interpolant;\n    }\n\n    var times = interpolant.parameterPositions,\n        values = interpolant.sampleValues;\n    times[0] = now;\n    values[0] = weightNow;\n    times[1] = now + duration;\n    values[1] = weightThen;\n    return this;\n  }\n\n}\n\nexport { AnimationAction };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/animation/AnimationAction.js"],"names":["WrapAroundEnding","ZeroCurvatureEnding","ZeroSlopeEnding","LoopPingPong","LoopOnce","LoopRepeat","NormalAnimationBlendMode","AdditiveAnimationBlendMode","AnimationAction","constructor","mixer","clip","localRoot","blendMode","_mixer","_clip","_localRoot","tracks","nTracks","length","interpolants","Array","interpolantSettings","endingStart","endingEnd","i","interpolant","createInterpolant","settings","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","loop","_loopCount","_startTime","time","timeScale","_effectiveTimeScale","weight","_effectiveWeight","repetitions","Infinity","paused","enabled","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","play","_activateAction","stop","_deactivateAction","reset","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setLoop","mode","setEffectiveWeight","getEffectiveWeight","fadeIn","duration","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","action","halt","startTimeScale","endTimeScale","now","_lendControlInterpolant","times","parameterPositions","values","sampleValues","timeScaleInterpolant","getMixer","getClip","getRoot","_root","_update","deltaTime","timeDirection","accuIndex","_updateWeight","startTime","timeRunning","_updateTimeScale","clipTime","_updateTime","propertyMixers","j","m","evaluate","accumulateAdditive","accumulate","interpolantValue","loopCount","pingPong","_setEndings","handle_stop","dispatchEvent","type","direction","loopDelta","Math","floor","abs","pending","atStart","atEnd","weightNow","weightThen"],"mappings":"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","sourcesContent":["import { WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding, LoopPingPong, LoopOnce, LoopRepeat, NormalAnimationBlendMode, AdditiveAnimationBlendMode } from '../constants.js';\n\n\nclass AnimationAction {\n\n\tconstructor( mixer, clip, localRoot, blendMode ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot || null;\n\t\tthis.blendMode = blendMode || clip.blendMode;\n\n\t\tconst tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tconst interpolantSettings = {\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants; // bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null; // for the memory manager\n\t\tthis._byClipCacheIndex = null; // for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = - 1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\t\tthis.paused = false; // true -> zero effective time scale\n\t\tthis.enabled = true; // false -> zero effective weight\n\n\t\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n\t}\n\n\t// State & Scheduling\n\n\tplay() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t}\n\n\treset() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t}\n\n\tisRunning() {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t}\n\n\t// return true when play has been called\n\tisScheduled() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t}\n\n\tstartAt( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoop( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t}\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t}\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight() {\n\n\t\treturn this._effectiveWeight;\n\n\t}\n\n\tfadeIn( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t}\n\n\tfadeOut( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t}\n\n\tcrossFadeFrom( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcrossFadeTo( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t}\n\n\tstopFading() {\n\n\t\tconst weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t}\n\n\tsetDuration( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\tsyncWith( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\thalt( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t}\n\n\twarp( startTimeScale, endTimeScale, duration ) {\n\n\t\tconst mixer = this._mixer,\n\t\t\tnow = mixer.time,\n\t\t\ttimeScale = this.timeScale;\n\n\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t}\n\n\tstopWarping() {\n\n\t\tconst timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Object Accessors\n\n\tgetMixer() {\n\n\t\treturn this._mixer;\n\n\t}\n\n\tgetClip() {\n\n\t\treturn this._clip;\n\n\t}\n\n\tgetRoot() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t}\n\n\t// Interna\n\n\t_update( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tconst timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tthis._startTime = null; // unschedule\n\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tconst clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tconst weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tconst interpolants = this._interpolants;\n\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\tswitch ( this.blendMode ) {\n\n\t\t\t\tcase AdditiveAnimationBlendMode:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulateAdditive( weight );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\tdefault:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateWeight( time ) {\n\n\t\tlet weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t}\n\n\t_updateTimeScale( time ) {\n\n\t\tlet timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t}\n\n\t_updateTime( deltaTime ) {\n\n\t\tconst duration = this._clip.duration;\n\t\tconst loop = this.loop;\n\n\t\tlet time = this.time + deltaTime;\n\t\tlet loopCount = this._loopCount;\n\n\t\tconst pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tbreak handle_stop;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tconst loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn time;\n\n\t}\n\n\t_setEndings( atStart, atEnd, pingPong ) {\n\n\t\tconst settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_scheduleFading( duration, weightNow, weightThen ) {\n\n\t\tconst mixer = this._mixer, now = mixer.time;\n\t\tlet interpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nexport { AnimationAction };\n"]},"metadata":{},"sourceType":"module"}