{"ast":null,"code":"import { Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferAttribute.js';\nimport { BufferGeometry } from '../../core/BufferGeometry.js';\nimport { arrayMax } from '../../utils.js';\n\nfunction WebGLGeometries(gl, attributes, info, bindingStates) {\n  var geometries = new WeakMap();\n  var wireframeAttributes = new WeakMap();\n\n  function onGeometryDispose(event) {\n    var geometry = event.target;\n    var buffergeometry = geometries.get(geometry);\n\n    if (buffergeometry.index !== null) {\n      attributes.remove(buffergeometry.index);\n    }\n\n    for (var name in buffergeometry.attributes) {\n      attributes.remove(buffergeometry.attributes[name]);\n    }\n\n    geometry.removeEventListener('dispose', onGeometryDispose);\n    geometries.delete(geometry);\n    var attribute = wireframeAttributes.get(buffergeometry);\n\n    if (attribute) {\n      attributes.remove(attribute);\n      wireframeAttributes.delete(buffergeometry);\n    }\n\n    bindingStates.releaseStatesOfGeometry(geometry);\n\n    if (geometry.isInstancedBufferGeometry === true) {\n      delete geometry._maxInstanceCount;\n    } //\n\n\n    info.memory.geometries--;\n  }\n\n  function get(object, geometry) {\n    var buffergeometry = geometries.get(geometry);\n    if (buffergeometry) return buffergeometry;\n    geometry.addEventListener('dispose', onGeometryDispose);\n\n    if (geometry.isBufferGeometry) {\n      buffergeometry = geometry;\n    } else if (geometry.isGeometry) {\n      if (geometry._bufferGeometry === undefined) {\n        geometry._bufferGeometry = new BufferGeometry().setFromObject(object);\n      }\n\n      buffergeometry = geometry._bufferGeometry;\n    }\n\n    geometries.set(geometry, buffergeometry);\n    info.memory.geometries++;\n    return buffergeometry;\n  }\n\n  function update(geometry) {\n    var geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.\n\n    for (var name in geometryAttributes) {\n      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);\n    } // morph targets\n\n\n    var morphAttributes = geometry.morphAttributes;\n\n    for (var _name in morphAttributes) {\n      var array = morphAttributes[_name];\n\n      for (var i = 0, l = array.length; i < l; i++) {\n        attributes.update(array[i], gl.ARRAY_BUFFER);\n      }\n    }\n  }\n\n  function updateWireframeAttribute(geometry) {\n    var indices = [];\n    var geometryIndex = geometry.index;\n    var geometryPosition = geometry.attributes.position;\n    var version = 0;\n\n    if (geometryIndex !== null) {\n      var array = geometryIndex.array;\n      version = geometryIndex.version;\n\n      for (var i = 0, l = array.length; i < l; i += 3) {\n        var a = array[i + 0];\n        var b = array[i + 1];\n        var c = array[i + 2];\n        indices.push(a, b, b, c, c, a);\n      }\n    } else {\n      var _array = geometryPosition.array;\n      version = geometryPosition.version;\n\n      for (var _i = 0, _l = _array.length / 3 - 1; _i < _l; _i += 3) {\n        var _a = _i + 0;\n\n        var _b = _i + 1;\n\n        var _c = _i + 2;\n\n        indices.push(_a, _b, _b, _c, _c, _a);\n      }\n    }\n\n    var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);\n    attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates\n    //\n\n    var previousAttribute = wireframeAttributes.get(geometry);\n    if (previousAttribute) attributes.remove(previousAttribute); //\n\n    wireframeAttributes.set(geometry, attribute);\n  }\n\n  function getWireframeAttribute(geometry) {\n    var currentAttribute = wireframeAttributes.get(geometry);\n\n    if (currentAttribute) {\n      var geometryIndex = geometry.index;\n\n      if (geometryIndex !== null) {\n        // if the attribute is obsolete, create a new one\n        if (currentAttribute.version < geometryIndex.version) {\n          updateWireframeAttribute(geometry);\n        }\n      }\n    } else {\n      updateWireframeAttribute(geometry);\n    }\n\n    return wireframeAttributes.get(geometry);\n  }\n\n  return {\n    get: get,\n    update: update,\n    getWireframeAttribute: getWireframeAttribute\n  };\n}\n\nexport { WebGLGeometries };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/renderers/webgl/WebGLGeometries.js"],"names":["Uint16BufferAttribute","Uint32BufferAttribute","BufferGeometry","arrayMax","WebGLGeometries","gl","attributes","info","bindingStates","geometries","WeakMap","wireframeAttributes","onGeometryDispose","event","geometry","target","buffergeometry","get","index","remove","name","removeEventListener","delete","attribute","releaseStatesOfGeometry","isInstancedBufferGeometry","_maxInstanceCount","memory","object","addEventListener","isBufferGeometry","isGeometry","_bufferGeometry","undefined","setFromObject","set","update","geometryAttributes","ARRAY_BUFFER","morphAttributes","array","i","l","length","updateWireframeAttribute","indices","geometryIndex","geometryPosition","position","version","a","b","c","push","previousAttribute","getWireframeAttribute","currentAttribute"],"mappings":"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","sourcesContent":["import { Uint16BufferAttribute, Uint32BufferAttribute } from '../../core/BufferAttribute.js';\nimport { BufferGeometry } from '../../core/BufferGeometry.js';\nimport { arrayMax } from '../../utils.js';\n\nfunction WebGLGeometries( gl, attributes, info, bindingStates ) {\n\n\tconst geometries = new WeakMap();\n\tconst wireframeAttributes = new WeakMap();\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tconst geometry = event.target;\n\t\tconst buffergeometry = geometries.get( geometry );\n\n\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\tattributes.remove( buffergeometry.index );\n\n\t\t}\n\n\t\tfor ( const name in buffergeometry.attributes ) {\n\n\t\t\tattributes.remove( buffergeometry.attributes[ name ] );\n\n\t\t}\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tgeometries.delete( geometry );\n\n\t\tconst attribute = wireframeAttributes.get( buffergeometry );\n\n\t\tif ( attribute ) {\n\n\t\t\tattributes.remove( attribute );\n\t\t\twireframeAttributes.delete( buffergeometry );\n\n\t\t}\n\n\t\tbindingStates.releaseStatesOfGeometry( geometry );\n\n\t\tif ( geometry.isInstancedBufferGeometry === true ) {\n\n\t\t\tdelete geometry._maxInstanceCount;\n\n\t\t}\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction get( object, geometry ) {\n\n\t\tlet buffergeometry = geometries.get( geometry );\n\n\t\tif ( buffergeometry ) return buffergeometry;\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tbuffergeometry = geometry;\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\n\n\t\t\t}\n\n\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t}\n\n\t\tgeometries.set( geometry, buffergeometry );\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction update( geometry ) {\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\t// Updating index buffer in VAO now. See WebGLBindingStates.\n\n\t\tfor ( const name in geometryAttributes ) {\n\n\t\t\tattributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = morphAttributes[ name ];\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tattributes.update( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction updateWireframeAttribute( geometry ) {\n\n\t\tconst indices = [];\n\n\t\tconst geometryIndex = geometry.index;\n\t\tconst geometryPosition = geometry.attributes.position;\n\t\tlet version = 0;\n\n\t\tif ( geometryIndex !== null ) {\n\n\t\t\tconst array = geometryIndex.array;\n\t\t\tversion = geometryIndex.version;\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tconst a = array[ i + 0 ];\n\t\t\t\tconst b = array[ i + 1 ];\n\t\t\t\tconst c = array[ i + 2 ];\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst array = geometryPosition.array;\n\t\t\tversion = geometryPosition.version;\n\n\t\t\tfor ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tconst a = i + 0;\n\t\t\t\tconst b = i + 1;\n\t\t\t\tconst c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\t\tattribute.version = version;\n\n\t\t// Updating index buffer in VAO now. See WebGLBindingStates\n\n\t\t//\n\n\t\tconst previousAttribute = wireframeAttributes.get( geometry );\n\n\t\tif ( previousAttribute ) attributes.remove( previousAttribute );\n\n\t\t//\n\n\t\twireframeAttributes.set( geometry, attribute );\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tconst currentAttribute = wireframeAttributes.get( geometry );\n\n\t\tif ( currentAttribute ) {\n\n\t\t\tconst geometryIndex = geometry.index;\n\n\t\t\tif ( geometryIndex !== null ) {\n\n\t\t\t\t// if the attribute is obsolete, create a new one\n\n\t\t\t\tif ( currentAttribute.version < geometryIndex.version ) {\n\n\t\t\t\t\tupdateWireframeAttribute( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tupdateWireframeAttribute( geometry );\n\n\t\t}\n\n\t\treturn wireframeAttributes.get( geometry );\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tupdate: update,\n\n\t\tgetWireframeAttribute: getWireframeAttribute\n\n\t};\n\n}\n\n\nexport { WebGLGeometries };\n"]},"metadata":{},"sourceType":"module"}