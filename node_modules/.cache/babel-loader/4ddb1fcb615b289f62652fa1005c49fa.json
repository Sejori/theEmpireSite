{"ast":null,"code":"import { Vector2 } from '../math/Vector2.js';\n\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = []; // this.lineDistances = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  computeGroups(geometry) {\n    var groups = [];\n    var group, i;\n    var materialIndex = undefined;\n    var faces = geometry.faces;\n\n    for (i = 0; i < faces.length; i++) {\n      var face = faces[i]; // materials\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n\n        if (group !== undefined) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n\n        group = {\n          start: i * 3,\n          materialIndex: materialIndex\n        };\n      }\n    }\n\n    if (group !== undefined) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n\n    this.groups = groups;\n  }\n\n  fromGeometry(geometry) {\n    var faces = geometry.faces;\n    var vertices = geometry.vertices;\n    var faceVertexUvs = geometry.faceVertexUvs;\n    var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\n\n    var morphTargets = geometry.morphTargets;\n    var morphTargetsLength = morphTargets.length;\n    var morphTargetsPosition;\n\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n\n      for (var i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.position = morphTargetsPosition;\n    }\n\n    var morphNormals = geometry.morphNormals;\n    var morphNormalsLength = morphNormals.length;\n    var morphTargetsNormal;\n\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n\n      for (var _i = 0; _i < morphNormalsLength; _i++) {\n        morphTargetsNormal[_i] = {\n          name: morphNormals[_i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.normal = morphTargetsNormal;\n    } // skins\n\n\n    var skinIndices = geometry.skinIndices;\n    var skinWeights = geometry.skinWeights;\n    var hasSkinIndices = skinIndices.length === vertices.length;\n    var hasSkinWeights = skinWeights.length === vertices.length; //\n\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n    }\n\n    for (var _i2 = 0; _i2 < faces.length; _i2++) {\n      var face = faces[_i2];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      var vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        var normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n\n      var vertexColors = face.vertexColors;\n\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        var color = face.color;\n        this.colors.push(color, color, color);\n      }\n\n      if (hasFaceVertexUv === true) {\n        var vertexUvs = faceVertexUvs[0][_i2];\n\n        if (vertexUvs !== undefined) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', _i2);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n\n      if (hasFaceVertexUv2 === true) {\n        var _vertexUvs = faceVertexUvs[1][_i2];\n\n        if (_vertexUvs !== undefined) {\n          this.uvs2.push(_vertexUvs[0], _vertexUvs[1], _vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', _i2);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      } // morphs\n\n\n      for (var j = 0; j < morphTargetsLength; j++) {\n        var morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n\n      for (var _j = 0; _j < morphNormalsLength; _j++) {\n        var morphNormal = morphNormals[_j].vertexNormals[_i2];\n\n        morphTargetsNormal[_j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      } // skins\n\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return this;\n  }\n\n}\n\nexport { DirectGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/core/DirectGeometry.js"],"names":["Vector2","DirectGeometry","constructor","vertices","normals","colors","uvs","uvs2","groups","morphTargets","skinWeights","skinIndices","boundingBox","boundingSphere","verticesNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","uvsNeedUpdate","groupsNeedUpdate","computeGroups","geometry","group","i","materialIndex","undefined","faces","length","face","count","start","push","fromGeometry","faceVertexUvs","hasFaceVertexUv","hasFaceVertexUv2","morphTargetsLength","morphTargetsPosition","name","data","position","morphNormals","morphNormalsLength","morphTargetsNormal","normal","hasSkinIndices","hasSkinWeights","console","error","a","b","c","vertexNormals","vertexColors","color","vertexUvs","warn","j","morphTarget","morphNormal","clone"],"mappings":"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","sourcesContent":["import { Vector2 } from '../math/Vector2.js';\n\nclass DirectGeometry {\n\n\tconstructor() {\n\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.colors = [];\n\t\tthis.uvs = [];\n\t\tthis.uvs2 = [];\n\n\t\tthis.groups = [];\n\n\t\tthis.morphTargets = {};\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\t// this.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tcomputeGroups( geometry ) {\n\n\t\tconst groups = [];\n\n\t\tlet group, i;\n\t\tlet materialIndex = undefined;\n\n\t\tconst faces = geometry.faces;\n\n\t\tfor ( i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\t// materials\n\n\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t}\n\n\t\t\t\tgroup = {\n\t\t\t\t\tstart: i * 3,\n\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( group !== undefined ) {\n\n\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\tgroups.push( group );\n\n\t\t}\n\n\t\tthis.groups = groups;\n\n\t}\n\n\tfromGeometry( geometry ) {\n\n\t\tconst faces = geometry.faces;\n\t\tconst vertices = geometry.vertices;\n\t\tconst faceVertexUvs = geometry.faceVertexUvs;\n\n\t\tconst hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\tconst hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t// morphs\n\n\t\tconst morphTargets = geometry.morphTargets;\n\t\tconst morphTargetsLength = morphTargets.length;\n\n\t\tlet morphTargetsPosition;\n\n\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\tmorphTargetsPosition = [];\n\n\t\t\tfor ( let i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsPosition[ i ] = {\n\t\t\t\t\tname: morphTargets[ i ].name,\n\t\t\t\t \tdata: []\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t}\n\n\t\tconst morphNormals = geometry.morphNormals;\n\t\tconst morphNormalsLength = morphNormals.length;\n\n\t\tlet morphTargetsNormal;\n\n\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\tmorphTargetsNormal = [];\n\n\t\t\tfor ( let i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsNormal[ i ] = {\n\t\t\t\t\tname: morphNormals[ i ].name,\n\t\t\t\t \tdata: []\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t}\n\n\t\t// skins\n\n\t\tconst skinIndices = geometry.skinIndices;\n\t\tconst skinWeights = geometry.skinWeights;\n\n\t\tconst hasSkinIndices = skinIndices.length === vertices.length;\n\t\tconst hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t//\n\n\t\tif ( vertices.length > 0 && faces.length === 0 ) {\n\n\t\t\tconsole.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tconst normal = face.normal;\n\n\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t}\n\n\t\t\tconst vertexColors = face.vertexColors;\n\n\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tconst color = face.color;\n\n\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\tconst vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\tconst vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// morphs\n\n\t\t\tfor ( let j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\tconst morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\tmorphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\tconst morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\tmorphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t}\n\n\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeGroups( geometry );\n\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nexport { DirectGeometry };\n"]},"metadata":{},"sourceType":"module"}