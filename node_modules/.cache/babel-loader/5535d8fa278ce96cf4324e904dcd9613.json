{"ast":null,"code":"function WebGLBindingStates(gl, extensions, attributes, capabilities) {\n  var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n  var extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');\n  var vaoAvailable = capabilities.isWebGL2 || extension !== null;\n  var bindingStates = {};\n  var defaultState = createBindingState(null);\n  var currentState = defaultState;\n\n  function setup(object, material, program, geometry, index) {\n    var updateBuffers = false;\n\n    if (vaoAvailable) {\n      var state = getBindingState(geometry, program, material);\n\n      if (currentState !== state) {\n        currentState = state;\n        bindVertexArrayObject(currentState.object);\n      }\n\n      updateBuffers = needsUpdate(geometry, index);\n      if (updateBuffers) saveCache(geometry, index);\n    } else {\n      var wireframe = material.wireframe === true;\n\n      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {\n        currentState.geometry = geometry.id;\n        currentState.program = program.id;\n        currentState.wireframe = wireframe;\n        updateBuffers = true;\n      }\n    }\n\n    if (object.isInstancedMesh === true) {\n      updateBuffers = true;\n    }\n\n    if (index !== null) {\n      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);\n    }\n\n    if (updateBuffers) {\n      setupVertexAttributes(object, material, program, geometry);\n\n      if (index !== null) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);\n      }\n    }\n  }\n\n  function createVertexArrayObject() {\n    if (capabilities.isWebGL2) return gl.createVertexArray();\n    return extension.createVertexArrayOES();\n  }\n\n  function bindVertexArrayObject(vao) {\n    if (capabilities.isWebGL2) return gl.bindVertexArray(vao);\n    return extension.bindVertexArrayOES(vao);\n  }\n\n  function deleteVertexArrayObject(vao) {\n    if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);\n    return extension.deleteVertexArrayOES(vao);\n  }\n\n  function getBindingState(geometry, program, material) {\n    var wireframe = material.wireframe === true;\n    var programMap = bindingStates[geometry.id];\n\n    if (programMap === undefined) {\n      programMap = {};\n      bindingStates[geometry.id] = programMap;\n    }\n\n    var stateMap = programMap[program.id];\n\n    if (stateMap === undefined) {\n      stateMap = {};\n      programMap[program.id] = stateMap;\n    }\n\n    var state = stateMap[wireframe];\n\n    if (state === undefined) {\n      state = createBindingState(createVertexArrayObject());\n      stateMap[wireframe] = state;\n    }\n\n    return state;\n  }\n\n  function createBindingState(vao) {\n    var newAttributes = [];\n    var enabledAttributes = [];\n    var attributeDivisors = [];\n\n    for (var i = 0; i < maxVertexAttributes; i++) {\n      newAttributes[i] = 0;\n      enabledAttributes[i] = 0;\n      attributeDivisors[i] = 0;\n    }\n\n    return {\n      // for backward compatibility on non-VAO support browser\n      geometry: null,\n      program: null,\n      wireframe: false,\n      newAttributes: newAttributes,\n      enabledAttributes: enabledAttributes,\n      attributeDivisors: attributeDivisors,\n      object: vao,\n      attributes: {},\n      index: null\n    };\n  }\n\n  function needsUpdate(geometry, index) {\n    var cachedAttributes = currentState.attributes;\n    var geometryAttributes = geometry.attributes;\n    if (Object.keys(cachedAttributes).length !== Object.keys(geometryAttributes).length) return true;\n\n    for (var key in geometryAttributes) {\n      var cachedAttribute = cachedAttributes[key];\n      var geometryAttribute = geometryAttributes[key];\n      if (cachedAttribute === undefined) return true;\n      if (cachedAttribute.attribute !== geometryAttribute) return true;\n      if (cachedAttribute.data !== geometryAttribute.data) return true;\n    }\n\n    if (currentState.index !== index) return true;\n    return false;\n  }\n\n  function saveCache(geometry, index) {\n    var cache = {};\n    var attributes = geometry.attributes;\n\n    for (var key in attributes) {\n      var attribute = attributes[key];\n      var data = {};\n      data.attribute = attribute;\n\n      if (attribute.data) {\n        data.data = attribute.data;\n      }\n\n      cache[key] = data;\n    }\n\n    currentState.attributes = cache;\n    currentState.index = index;\n  }\n\n  function initAttributes() {\n    var newAttributes = currentState.newAttributes;\n\n    for (var i = 0, il = newAttributes.length; i < il; i++) {\n      newAttributes[i] = 0;\n    }\n  }\n\n  function enableAttribute(attribute) {\n    enableAttributeAndDivisor(attribute, 0);\n  }\n\n  function enableAttributeAndDivisor(attribute, meshPerAttribute) {\n    var newAttributes = currentState.newAttributes;\n    var enabledAttributes = currentState.enabledAttributes;\n    var attributeDivisors = currentState.attributeDivisors;\n    newAttributes[attribute] = 1;\n\n    if (enabledAttributes[attribute] === 0) {\n      gl.enableVertexAttribArray(attribute);\n      enabledAttributes[attribute] = 1;\n    }\n\n    if (attributeDivisors[attribute] !== meshPerAttribute) {\n      var _extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');\n\n      _extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);\n\n      attributeDivisors[attribute] = meshPerAttribute;\n    }\n  }\n\n  function disableUnusedAttributes() {\n    var newAttributes = currentState.newAttributes;\n    var enabledAttributes = currentState.enabledAttributes;\n\n    for (var i = 0, il = enabledAttributes.length; i < il; i++) {\n      if (enabledAttributes[i] !== newAttributes[i]) {\n        gl.disableVertexAttribArray(i);\n        enabledAttributes[i] = 0;\n      }\n    }\n  }\n\n  function vertexAttribPointer(index, size, type, normalized, stride, offset) {\n    if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {\n      gl.vertexAttribIPointer(index, size, type, stride, offset);\n    } else {\n      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);\n    }\n  }\n\n  function setupVertexAttributes(object, material, program, geometry) {\n    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {\n      if (extensions.get('ANGLE_instanced_arrays') === null) return;\n    }\n\n    initAttributes();\n    var geometryAttributes = geometry.attributes;\n    var programAttributes = program.getAttributes();\n    var materialDefaultAttributeValues = material.defaultAttributeValues;\n\n    for (var name in programAttributes) {\n      var programAttribute = programAttributes[name];\n\n      if (programAttribute >= 0) {\n        var geometryAttribute = geometryAttributes[name];\n\n        if (geometryAttribute !== undefined) {\n          var normalized = geometryAttribute.normalized;\n          var size = geometryAttribute.itemSize;\n          var attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore\n\n          if (attribute === undefined) continue;\n          var buffer = attribute.buffer;\n          var type = attribute.type;\n          var bytesPerElement = attribute.bytesPerElement;\n\n          if (geometryAttribute.isInterleavedBufferAttribute) {\n            var data = geometryAttribute.data;\n            var stride = data.stride;\n            var offset = geometryAttribute.offset;\n\n            if (data && data.isInstancedInterleavedBuffer) {\n              enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);\n\n              if (geometry._maxInstanceCount === undefined) {\n                geometry._maxInstanceCount = data.meshPerAttribute * data.count;\n              }\n            } else {\n              enableAttribute(programAttribute);\n            }\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);\n          } else {\n            if (geometryAttribute.isInstancedBufferAttribute) {\n              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);\n\n              if (geometry._maxInstanceCount === undefined) {\n                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n              }\n            } else {\n              enableAttribute(programAttribute);\n            }\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);\n          }\n        } else if (name === 'instanceMatrix') {\n          var _attribute = attributes.get(object.instanceMatrix); // TODO Attribute may not be available on context restore\n\n\n          if (_attribute === undefined) continue;\n          var _buffer = _attribute.buffer;\n          var _type = _attribute.type;\n          enableAttributeAndDivisor(programAttribute + 0, 1);\n          enableAttributeAndDivisor(programAttribute + 1, 1);\n          enableAttributeAndDivisor(programAttribute + 2, 1);\n          enableAttributeAndDivisor(programAttribute + 3, 1);\n          gl.bindBuffer(gl.ARRAY_BUFFER, _buffer);\n          gl.vertexAttribPointer(programAttribute + 0, 4, _type, false, 64, 0);\n          gl.vertexAttribPointer(programAttribute + 1, 4, _type, false, 64, 16);\n          gl.vertexAttribPointer(programAttribute + 2, 4, _type, false, 64, 32);\n          gl.vertexAttribPointer(programAttribute + 3, 4, _type, false, 64, 48);\n        } else if (name === 'instanceColor') {\n          var _attribute2 = attributes.get(object.instanceColor); // TODO Attribute may not be available on context restore\n\n\n          if (_attribute2 === undefined) continue;\n          var _buffer2 = _attribute2.buffer;\n          var _type2 = _attribute2.type;\n          enableAttributeAndDivisor(programAttribute, 1);\n          gl.bindBuffer(gl.ARRAY_BUFFER, _buffer2);\n          gl.vertexAttribPointer(programAttribute, 3, _type2, false, 12, 0);\n        } else if (materialDefaultAttributeValues !== undefined) {\n          var value = materialDefaultAttributeValues[name];\n\n          if (value !== undefined) {\n            switch (value.length) {\n              case 2:\n                gl.vertexAttrib2fv(programAttribute, value);\n                break;\n\n              case 3:\n                gl.vertexAttrib3fv(programAttribute, value);\n                break;\n\n              case 4:\n                gl.vertexAttrib4fv(programAttribute, value);\n                break;\n\n              default:\n                gl.vertexAttrib1fv(programAttribute, value);\n            }\n          }\n        }\n      }\n    }\n\n    disableUnusedAttributes();\n  }\n\n  function dispose() {\n    reset();\n\n    for (var geometryId in bindingStates) {\n      var programMap = bindingStates[geometryId];\n\n      for (var programId in programMap) {\n        var stateMap = programMap[programId];\n\n        for (var wireframe in stateMap) {\n          deleteVertexArrayObject(stateMap[wireframe].object);\n          delete stateMap[wireframe];\n        }\n\n        delete programMap[programId];\n      }\n\n      delete bindingStates[geometryId];\n    }\n  }\n\n  function releaseStatesOfGeometry(geometry) {\n    if (bindingStates[geometry.id] === undefined) return;\n    var programMap = bindingStates[geometry.id];\n\n    for (var programId in programMap) {\n      var stateMap = programMap[programId];\n\n      for (var wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n        delete stateMap[wireframe];\n      }\n\n      delete programMap[programId];\n    }\n\n    delete bindingStates[geometry.id];\n  }\n\n  function releaseStatesOfProgram(program) {\n    for (var geometryId in bindingStates) {\n      var programMap = bindingStates[geometryId];\n      if (programMap[program.id] === undefined) continue;\n      var stateMap = programMap[program.id];\n\n      for (var wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n        delete stateMap[wireframe];\n      }\n\n      delete programMap[program.id];\n    }\n  }\n\n  function reset() {\n    resetDefaultState();\n    if (currentState === defaultState) return;\n    currentState = defaultState;\n    bindVertexArrayObject(currentState.object);\n  } // for backward-compatilibity\n\n\n  function resetDefaultState() {\n    defaultState.geometry = null;\n    defaultState.program = null;\n    defaultState.wireframe = false;\n  }\n\n  return {\n    setup: setup,\n    reset: reset,\n    resetDefaultState: resetDefaultState,\n    dispose: dispose,\n    releaseStatesOfGeometry: releaseStatesOfGeometry,\n    releaseStatesOfProgram: releaseStatesOfProgram,\n    initAttributes: initAttributes,\n    enableAttribute: enableAttribute,\n    disableUnusedAttributes: disableUnusedAttributes\n  };\n}\n\nexport { WebGLBindingStates };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/renderers/webgl/WebGLBindingStates.js"],"names":["WebGLBindingStates","gl","extensions","attributes","capabilities","maxVertexAttributes","getParameter","MAX_VERTEX_ATTRIBS","extension","isWebGL2","get","vaoAvailable","bindingStates","defaultState","createBindingState","currentState","setup","object","material","program","geometry","index","updateBuffers","state","getBindingState","bindVertexArrayObject","needsUpdate","saveCache","wireframe","id","isInstancedMesh","update","ELEMENT_ARRAY_BUFFER","setupVertexAttributes","bindBuffer","buffer","createVertexArrayObject","createVertexArray","createVertexArrayOES","vao","bindVertexArray","bindVertexArrayOES","deleteVertexArrayObject","deleteVertexArray","deleteVertexArrayOES","programMap","undefined","stateMap","newAttributes","enabledAttributes","attributeDivisors","i","cachedAttributes","geometryAttributes","Object","keys","length","key","cachedAttribute","geometryAttribute","attribute","data","cache","initAttributes","il","enableAttribute","enableAttributeAndDivisor","meshPerAttribute","enableVertexAttribArray","disableUnusedAttributes","disableVertexAttribArray","vertexAttribPointer","size","type","normalized","stride","offset","INT","UNSIGNED_INT","vertexAttribIPointer","isInstancedBufferGeometry","programAttributes","getAttributes","materialDefaultAttributeValues","defaultAttributeValues","name","programAttribute","itemSize","bytesPerElement","isInterleavedBufferAttribute","isInstancedInterleavedBuffer","_maxInstanceCount","count","ARRAY_BUFFER","isInstancedBufferAttribute","instanceMatrix","instanceColor","value","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","dispose","reset","geometryId","programId","releaseStatesOfGeometry","releaseStatesOfProgram","resetDefaultState"],"mappings":"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","sourcesContent":["function WebGLBindingStates( gl, extensions, attributes, capabilities ) {\n\n\tconst maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\n\tconst extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );\n\tconst vaoAvailable = capabilities.isWebGL2 || extension !== null;\n\n\tconst bindingStates = {};\n\n\tconst defaultState = createBindingState( null );\n\tlet currentState = defaultState;\n\n\tfunction setup( object, material, program, geometry, index ) {\n\n\t\tlet updateBuffers = false;\n\n\t\tif ( vaoAvailable ) {\n\n\t\t\tconst state = getBindingState( geometry, program, material );\n\n\t\t\tif ( currentState !== state ) {\n\n\t\t\t\tcurrentState = state;\n\t\t\t\tbindVertexArrayObject( currentState.object );\n\n\t\t\t}\n\n\t\t\tupdateBuffers = needsUpdate( geometry, index );\n\n\t\t\tif ( updateBuffers ) saveCache( geometry, index );\n\n\t\t} else {\n\n\t\t\tconst wireframe = ( material.wireframe === true );\n\n\t\t\tif ( currentState.geometry !== geometry.id ||\n\t\t\t\tcurrentState.program !== program.id ||\n\t\t\t\tcurrentState.wireframe !== wireframe ) {\n\n\t\t\t\tcurrentState.geometry = geometry.id;\n\t\t\t\tcurrentState.program = program.id;\n\t\t\t\tcurrentState.wireframe = wireframe;\n\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.isInstancedMesh === true ) {\n\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\tif ( index !== null ) {\n\n\t\t\tattributes.update( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tsetupVertexAttributes( object, material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction createVertexArrayObject() {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.createVertexArray();\n\n\t\treturn extension.createVertexArrayOES();\n\n\t}\n\n\tfunction bindVertexArrayObject( vao ) {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );\n\n\t\treturn extension.bindVertexArrayOES( vao );\n\n\t}\n\n\tfunction deleteVertexArrayObject( vao ) {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );\n\n\t\treturn extension.deleteVertexArrayOES( vao );\n\n\t}\n\n\tfunction getBindingState( geometry, program, material ) {\n\n\t\tconst wireframe = ( material.wireframe === true );\n\n\t\tlet programMap = bindingStates[ geometry.id ];\n\n\t\tif ( programMap === undefined ) {\n\n\t\t\tprogramMap = {};\n\t\t\tbindingStates[ geometry.id ] = programMap;\n\n\t\t}\n\n\t\tlet stateMap = programMap[ program.id ];\n\n\t\tif ( stateMap === undefined ) {\n\n\t\t\tstateMap = {};\n\t\t\tprogramMap[ program.id ] = stateMap;\n\n\t\t}\n\n\t\tlet state = stateMap[ wireframe ];\n\n\t\tif ( state === undefined ) {\n\n\t\t\tstate = createBindingState( createVertexArrayObject() );\n\t\t\tstateMap[ wireframe ] = state;\n\n\t\t}\n\n\t\treturn state;\n\n\t}\n\n\tfunction createBindingState( vao ) {\n\n\t\tconst newAttributes = [];\n\t\tconst enabledAttributes = [];\n\t\tconst attributeDivisors = [];\n\n\t\tfor ( let i = 0; i < maxVertexAttributes; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\t\t\tenabledAttributes[ i ] = 0;\n\t\t\tattributeDivisors[ i ] = 0;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\t// for backward compatibility on non-VAO support browser\n\t\t\tgeometry: null,\n\t\t\tprogram: null,\n\t\t\twireframe: false,\n\n\t\t\tnewAttributes: newAttributes,\n\t\t\tenabledAttributes: enabledAttributes,\n\t\t\tattributeDivisors: attributeDivisors,\n\t\t\tobject: vao,\n\t\t\tattributes: {},\n\t\t\tindex: null\n\n\t\t};\n\n\t}\n\n\tfunction needsUpdate( geometry, index ) {\n\n\t\tconst cachedAttributes = currentState.attributes;\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tif ( Object.keys( cachedAttributes ).length !== Object.keys( geometryAttributes ).length ) return true;\n\n\t\tfor ( const key in geometryAttributes ) {\n\n\t\t\tconst cachedAttribute = cachedAttributes[ key ];\n\t\t\tconst geometryAttribute = geometryAttributes[ key ];\n\n\t\t\tif ( cachedAttribute === undefined ) return true;\n\n\t\t\tif ( cachedAttribute.attribute !== geometryAttribute ) return true;\n\n\t\t\tif ( cachedAttribute.data !== geometryAttribute.data ) return true;\n\n\t\t}\n\n\t\tif ( currentState.index !== index ) return true;\n\n\t\treturn false;\n\n\t}\n\n\tfunction saveCache( geometry, index ) {\n\n\t\tconst cache = {};\n\t\tconst attributes = geometry.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tconst data = {};\n\t\t\tdata.attribute = attribute;\n\n\t\t\tif ( attribute.data ) {\n\n\t\t\t\tdata.data = attribute.data;\n\n\t\t\t}\n\n\t\t\tcache[ key ] = data;\n\n\t\t}\n\n\t\tcurrentState.attributes = cache;\n\n\t\tcurrentState.index = index;\n\n\t}\n\n\tfunction initAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\n\t\tfor ( let i = 0, il = newAttributes.length; i < il; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\tfunction enableAttribute( attribute ) {\n\n\t\tenableAttributeAndDivisor( attribute, 0 );\n\n\t}\n\n\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\t\tconst attributeDivisors = currentState.attributeDivisors;\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\tconst extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\textension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t}\n\n\tfunction disableUnusedAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\n\t\tfor ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction vertexAttribPointer( index, size, type, normalized, stride, offset ) {\n\n\t\tif ( capabilities.isWebGL2 === true && ( type === gl.INT || type === gl.UNSIGNED_INT ) ) {\n\n\t\t\tgl.vertexAttribIPointer( index, size, type, stride, offset );\n\n\t\t} else {\n\n\t\t\tgl.vertexAttribPointer( index, size, type, normalized, stride, offset );\n\n\t\t}\n\n\t}\n\n\tfunction setupVertexAttributes( object, material, program, geometry ) {\n\n\t\tif ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {\n\n\t\t\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;\n\n\t\t}\n\n\t\tinitAttributes();\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tconst materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\tconst geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tconst normalized = geometryAttribute.normalized;\n\t\t\t\t\tconst size = geometryAttribute.itemSize;\n\n\t\t\t\t\tconst attribute = attributes.get( geometryAttribute );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\tconst bytesPerElement = attribute.bytesPerElement;\n\n\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst data = geometryAttribute.data;\n\t\t\t\t\t\tconst stride = data.stride;\n\t\t\t\t\t\tconst offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data && data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute, data.meshPerAttribute );\n\n\t\t\t\t\t\t\tif ( geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tenableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\tvertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );\n\n\t\t\t\t\t\t\tif ( geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tenableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\tvertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( name === 'instanceMatrix' ) {\n\n\t\t\t\t\tconst attribute = attributes.get( object.instanceMatrix );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\tconst type = attribute.type;\n\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute + 0, 1 );\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute + 1, 1 );\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute + 2, 1 );\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute + 3, 1 );\n\n\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );\n\n\t\t\t\t} else if ( name === 'instanceColor' ) {\n\n\t\t\t\t\tconst attribute = attributes.get( object.instanceColor );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\tconst type = attribute.type;\n\n\t\t\t\t\tenableAttributeAndDivisor( programAttribute, 1 );\n\n\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n\n\t\t\t\t\tgl.vertexAttribPointer( programAttribute, 3, type, false, 12, 0 );\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tconst value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tgl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tgl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\tgl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tgl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tdisableUnusedAttributes();\n\n\t}\n\n\tfunction dispose() {\n\n\t\treset();\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tfor ( const programId in programMap ) {\n\n\t\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t\t}\n\n\t\t\t\tdelete programMap[ programId ];\n\n\t\t\t}\n\n\t\t\tdelete bindingStates[ geometryId ];\n\n\t\t}\n\n\t}\n\n\tfunction releaseStatesOfGeometry( geometry ) {\n\n\t\tif ( bindingStates[ geometry.id ] === undefined ) return;\n\n\t\tconst programMap = bindingStates[ geometry.id ];\n\n\t\tfor ( const programId in programMap ) {\n\n\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ programId ];\n\n\t\t}\n\n\t\tdelete bindingStates[ geometry.id ];\n\n\t}\n\n\tfunction releaseStatesOfProgram( program ) {\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tif ( programMap[ program.id ] === undefined ) continue;\n\n\t\t\tconst stateMap = programMap[ program.id ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ program.id ];\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\tresetDefaultState();\n\n\t\tif ( currentState === defaultState ) return;\n\n\t\tcurrentState = defaultState;\n\t\tbindVertexArrayObject( currentState.object );\n\n\t}\n\n\t// for backward-compatilibity\n\n\tfunction resetDefaultState() {\n\n\t\tdefaultState.geometry = null;\n\t\tdefaultState.program = null;\n\t\tdefaultState.wireframe = false;\n\n\t}\n\n\treturn {\n\n\t\tsetup: setup,\n\t\treset: reset,\n\t\tresetDefaultState: resetDefaultState,\n\t\tdispose: dispose,\n\t\treleaseStatesOfGeometry: releaseStatesOfGeometry,\n\t\treleaseStatesOfProgram: releaseStatesOfProgram,\n\n\t\tinitAttributes: initAttributes,\n\t\tenableAttribute: enableAttribute,\n\t\tdisableUnusedAttributes: disableUnusedAttributes\n\n\t};\n\n}\n\n\nexport { WebGLBindingStates };\n"]},"metadata":{},"sourceType":"module"}