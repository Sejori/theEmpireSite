{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass CircleBufferGeometry extends BufferGeometry {\n  constructor(radius, segments, thetaStart, thetaLength) {\n    super();\n    this.type = 'CircleBufferGeometry';\n    this.parameters = {\n      radius: radius,\n      segments: segments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    radius = radius || 1;\n    segments = segments !== undefined ? Math.max(3, segments) : 8;\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2; // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helper variables\n\n    var vertex = new Vector3();\n    var uv = new Vector2(); // center point\n\n    vertices.push(0, 0, 0);\n    normals.push(0, 0, 1);\n    uvs.push(0.5, 0.5);\n\n    for (var s = 0, i = 3; s <= segments; s++, i += 3) {\n      var segment = thetaStart + s / segments * thetaLength; // vertex\n\n      vertex.x = radius * Math.cos(segment);\n      vertex.y = radius * Math.sin(segment);\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n      normals.push(0, 0, 1); // uvs\n\n      uv.x = (vertices[i] / radius + 1) / 2;\n      uv.y = (vertices[i + 1] / radius + 1) / 2;\n      uvs.push(uv.x, uv.y);\n    } // indices\n\n\n    for (var _i = 1; _i <= segments; _i++) {\n      indices.push(_i, _i + 1, 0);\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n\n}\n\nexport { CircleBufferGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/CircleBufferGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","Vector2","CircleBufferGeometry","constructor","radius","segments","thetaStart","thetaLength","type","parameters","undefined","Math","max","PI","indices","vertices","normals","uvs","vertex","uv","push","s","i","segment","x","cos","y","sin","z","setIndex","setAttribute"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass CircleBufferGeometry extends BufferGeometry {\n\n\tconstructor( radius, segments, thetaStart, thetaLength ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CircleBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tradius = radius || 1;\n\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// center point\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tnormals.push( 0, 0, 1 );\n\t\tuvs.push( 0.5, 0.5 );\n\n\t\tfor ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n\t\t\tconst segment = thetaStart + s / segments * thetaLength;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t// uvs\n\n\t\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n}\n\n\nexport { CircleBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}