{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass BoxBufferGeometry extends BufferGeometry {\n  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {\n    super();\n    this.type = 'BoxBufferGeometry';\n    this.parameters = {\n      width: width,\n      height: height,\n      depth: depth,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      depthSegments: depthSegments\n    };\n    var scope = this; // segments\n\n    widthSegments = Math.floor(widthSegments);\n    heightSegments = Math.floor(heightSegments);\n    depthSegments = Math.floor(depthSegments); // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helper variables\n\n    var numberOfVertices = 0;\n    var groupStart = 0; // build each side of the box geometry\n\n    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px\n\n    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx\n\n    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py\n\n    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny\n\n    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz\n\n    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {\n      var segmentWidth = width / gridX;\n      var segmentHeight = height / gridY;\n      var widthHalf = width / 2;\n      var heightHalf = height / 2;\n      var depthHalf = depth / 2;\n      var gridX1 = gridX + 1;\n      var gridY1 = gridY + 1;\n      var vertexCounter = 0;\n      var groupCount = 0;\n      var vector = new Vector3(); // generate vertices, normals and uvs\n\n      for (var iy = 0; iy < gridY1; iy++) {\n        var y = iy * segmentHeight - heightHalf;\n\n        for (var ix = 0; ix < gridX1; ix++) {\n          var x = ix * segmentWidth - widthHalf; // set values to correct vector component\n\n          vector[u] = x * udir;\n          vector[v] = y * vdir;\n          vector[w] = depthHalf; // now apply vector to vertex buffer\n\n          vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component\n\n          vector[u] = 0;\n          vector[v] = 0;\n          vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer\n\n          normals.push(vector.x, vector.y, vector.z); // uvs\n\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY); // counters\n\n          vertexCounter += 1;\n        }\n      } // indices\n      // 1. you need three indices to draw a single face\n      // 2. a single segment consists of two faces\n      // 3. so we need to generate six (2*3) indices per segment\n\n\n      for (var _iy = 0; _iy < gridY; _iy++) {\n        for (var _ix = 0; _ix < gridX; _ix++) {\n          var a = numberOfVertices + _ix + gridX1 * _iy;\n          var b = numberOfVertices + _ix + gridX1 * (_iy + 1);\n          var c = numberOfVertices + (_ix + 1) + gridX1 * (_iy + 1);\n          var d = numberOfVertices + (_ix + 1) + gridX1 * _iy; // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d); // increase counter\n\n          groupCount += 6;\n        }\n      } // add a group to the geometry. this will ensure multi material support\n\n\n      scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups\n\n      groupStart += groupCount; // update total number of vertices\n\n      numberOfVertices += vertexCounter;\n    }\n  }\n\n}\n\nexport { BoxBufferGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/BoxBufferGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","BoxBufferGeometry","constructor","width","height","depth","widthSegments","heightSegments","depthSegments","type","parameters","scope","Math","floor","indices","vertices","normals","uvs","numberOfVertices","groupStart","buildPlane","setIndex","setAttribute","u","v","w","udir","vdir","gridX","gridY","materialIndex","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","vector","iy","y","ix","x","push","z","a","b","c","d","addGroup"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass BoxBufferGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'BoxBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tconst scope = this;\n\n\t\t// segments\n\n\t\twidthSegments = Math.floor( widthSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\t\tdepthSegments = Math.floor( depthSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet numberOfVertices = 0;\n\t\tlet groupStart = 0;\n\n\t\t// build each side of the box geometry\n\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tconst segmentWidth = width / gridX;\n\t\t\tconst segmentHeight = height / gridY;\n\n\t\t\tconst widthHalf = width / 2;\n\t\t\tconst heightHalf = height / 2;\n\t\t\tconst depthHalf = depth / 2;\n\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\n\t\t\tlet vertexCounter = 0;\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tconst x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t\t// counters\n\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// increase counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n}\n\nexport { BoxBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}