{"ast":null,"code":"import { LinearFilter } from '../constants.js';\nimport { FileLoader } from './FileLoader.js';\nimport { CompressedTexture } from '../textures/CompressedTexture.js';\nimport { Loader } from './Loader.js';\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nfunction CompressedTextureLoader(manager) {\n  Loader.call(this, manager);\n}\n\nCompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: CompressedTextureLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var images = [];\n    var texture = new CompressedTexture();\n    texture.image = images;\n    var loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    var loaded = 0;\n\n    function loadTexture(i) {\n      loader.load(url[i], function (buffer) {\n        var texDatas = scope.parse(buffer, true);\n        images[i] = {\n          width: texDatas.width,\n          height: texDatas.height,\n          format: texDatas.format,\n          mipmaps: texDatas.mipmaps\n        };\n        loaded += 1;\n\n        if (loaded === 6) {\n          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;\n          texture.format = texDatas.format;\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }\n      }, onProgress, onError);\n    }\n\n    if (Array.isArray(url)) {\n      for (var i = 0, il = url.length; i < il; ++i) {\n        loadTexture(i);\n      }\n    } else {\n      // compressed cubemap texture stored in a single DDS file\n      loader.load(url, function (buffer) {\n        var texDatas = scope.parse(buffer, true);\n\n        if (texDatas.isCubemap) {\n          var faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n          for (var f = 0; f < faces; f++) {\n            images[f] = {\n              mipmaps: []\n            };\n\n            for (var _i = 0; _i < texDatas.mipmapCount; _i++) {\n              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + _i]);\n              images[f].format = texDatas.format;\n              images[f].width = texDatas.width;\n              images[f].height = texDatas.height;\n            }\n          }\n        } else {\n          texture.image.width = texDatas.width;\n          texture.image.height = texDatas.height;\n          texture.mipmaps = texDatas.mipmaps;\n        }\n\n        if (texDatas.mipmapCount === 1) {\n          texture.minFilter = LinearFilter;\n        }\n\n        texture.format = texDatas.format;\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }, onProgress, onError);\n    }\n\n    return texture;\n  }\n});\nexport { CompressedTextureLoader };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/loaders/CompressedTextureLoader.js"],"names":["LinearFilter","FileLoader","CompressedTexture","Loader","CompressedTextureLoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","images","texture","image","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","loaded","loadTexture","i","buffer","texDatas","parse","width","height","format","mipmaps","mipmapCount","minFilter","needsUpdate","Array","isArray","il","length","isCubemap","faces","f","push"],"mappings":"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","sourcesContent":["import { LinearFilter } from '../constants.js';\nimport { FileLoader } from './FileLoader.js';\nimport { CompressedTexture } from '../textures/CompressedTexture.js';\nimport { Loader } from './Loader.js';\n\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nfunction CompressedTextureLoader( manager ) {\n\n\tLoader.call( this, manager );\n\n}\n\nCompressedTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: CompressedTextureLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst images = [];\n\n\t\tconst texture = new CompressedTexture();\n\t\ttexture.image = images;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tfor ( let i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( let f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\tfor ( let i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n} );\n\n\nexport { CompressedTextureLoader };\n"]},"metadata":{},"sourceType":"module"}