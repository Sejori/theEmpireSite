{"ast":null,"code":"import { FrontSide, BackSide, DoubleSide, RGBAFormat, NearestFilter, LinearFilter, PCFShadowMap, VSMShadowMap, RGBADepthPacking, NoBlending } from '../../constants.js';\nimport { WebGLRenderTarget } from '../WebGLRenderTarget.js';\nimport { MeshDepthMaterial } from '../../materials/MeshDepthMaterial.js';\nimport { MeshDistanceMaterial } from '../../materials/MeshDistanceMaterial.js';\nimport { ShaderMaterial } from '../../materials/ShaderMaterial.js';\nimport { BufferAttribute } from '../../core/BufferAttribute.js';\nimport { BufferGeometry } from '../../core/BufferGeometry.js';\nimport { Mesh } from '../../objects/Mesh.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Frustum } from '../../math/Frustum.js';\nimport vsm_frag from '../shaders/ShaderLib/vsm_frag.glsl.js';\nimport vsm_vert from '../shaders/ShaderLib/vsm_vert.glsl.js';\n\nfunction WebGLShadowMap(_renderer, _objects, maxTextureSize) {\n  var _frustum = new Frustum();\n\n  var _shadowMapSize = new Vector2(),\n      _viewportSize = new Vector2(),\n      _viewport = new Vector4(),\n      _depthMaterials = [],\n      _distanceMaterials = [],\n      _materialCache = {};\n\n  var shadowSide = {\n    0: BackSide,\n    1: FrontSide,\n    2: DoubleSide\n  };\n  var shadowMaterialVertical = new ShaderMaterial({\n    defines: {\n      SAMPLE_RATE: 2.0 / 8.0,\n      HALF_SAMPLE_RATE: 1.0 / 8.0\n    },\n    uniforms: {\n      shadow_pass: {\n        value: null\n      },\n      resolution: {\n        value: new Vector2()\n      },\n      radius: {\n        value: 4.0\n      }\n    },\n    vertexShader: vsm_vert,\n    fragmentShader: vsm_frag\n  });\n  var shadowMaterialHorizonal = shadowMaterialVertical.clone();\n  shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;\n  var fullScreenTri = new BufferGeometry();\n  fullScreenTri.setAttribute(\"position\", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));\n  var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);\n  var scope = this;\n  this.enabled = false;\n  this.autoUpdate = true;\n  this.needsUpdate = false;\n  this.type = PCFShadowMap;\n\n  this.render = function (lights, scene, camera) {\n    if (scope.enabled === false) return;\n    if (scope.autoUpdate === false && scope.needsUpdate === false) return;\n    if (lights.length === 0) return;\n\n    var currentRenderTarget = _renderer.getRenderTarget();\n\n    var activeCubeFace = _renderer.getActiveCubeFace();\n\n    var activeMipmapLevel = _renderer.getActiveMipmapLevel();\n\n    var _state = _renderer.state; // Set GL state for depth map.\n\n    _state.setBlending(NoBlending);\n\n    _state.buffers.color.setClear(1, 1, 1, 1);\n\n    _state.buffers.depth.setTest(true);\n\n    _state.setScissorTest(false); // render depth map\n\n\n    for (var i = 0, il = lights.length; i < il; i++) {\n      var light = lights[i];\n      var shadow = light.shadow;\n\n      if (shadow === undefined) {\n        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');\n        continue;\n      }\n\n      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;\n\n      _shadowMapSize.copy(shadow.mapSize);\n\n      var shadowFrameExtents = shadow.getFrameExtents();\n\n      _shadowMapSize.multiply(shadowFrameExtents);\n\n      _viewportSize.copy(shadow.mapSize);\n\n      if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {\n        if (_shadowMapSize.x > maxTextureSize) {\n          _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);\n          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n          shadow.mapSize.x = _viewportSize.x;\n        }\n\n        if (_shadowMapSize.y > maxTextureSize) {\n          _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);\n          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n          shadow.mapSize.y = _viewportSize.y;\n        }\n      }\n\n      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {\n        var pars = {\n          minFilter: LinearFilter,\n          magFilter: LinearFilter,\n          format: RGBAFormat\n        };\n        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        shadow.map.texture.name = light.name + \".shadowMap\";\n        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        shadow.camera.updateProjectionMatrix();\n      }\n\n      if (shadow.map === null) {\n        var _pars = {\n          minFilter: NearestFilter,\n          magFilter: NearestFilter,\n          format: RGBAFormat\n        };\n        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, _pars);\n        shadow.map.texture.name = light.name + \".shadowMap\";\n        shadow.camera.updateProjectionMatrix();\n      }\n\n      _renderer.setRenderTarget(shadow.map);\n\n      _renderer.clear();\n\n      var viewportCount = shadow.getViewportCount();\n\n      for (var vp = 0; vp < viewportCount; vp++) {\n        var viewport = shadow.getViewport(vp);\n\n        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);\n\n        _state.viewport(_viewport);\n\n        shadow.updateMatrices(light, vp);\n        _frustum = shadow.getFrustum();\n        renderObject(scene, camera, shadow.camera, light, this.type);\n      } // do blur pass for VSM\n\n\n      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {\n        VSMPass(shadow, camera);\n      }\n\n      shadow.needsUpdate = false;\n    }\n\n    scope.needsUpdate = false;\n\n    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);\n  };\n\n  function VSMPass(shadow, camera) {\n    var geometry = _objects.update(fullScreenMesh); // vertical pass\n\n\n    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\n    _renderer.setRenderTarget(shadow.mapPass);\n\n    _renderer.clear();\n\n    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizonal pass\n\n\n    shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n    shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;\n\n    _renderer.setRenderTarget(shadow.map);\n\n    _renderer.clear();\n\n    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);\n  }\n\n  function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {\n    var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;\n    var material = _depthMaterials[index];\n\n    if (material === undefined) {\n      material = new MeshDepthMaterial({\n        depthPacking: RGBADepthPacking,\n        morphTargets: useMorphing,\n        skinning: useSkinning\n      });\n      _depthMaterials[index] = material;\n    }\n\n    return material;\n  }\n\n  function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {\n    var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;\n    var material = _distanceMaterials[index];\n\n    if (material === undefined) {\n      material = new MeshDistanceMaterial({\n        morphTargets: useMorphing,\n        skinning: useSkinning\n      });\n      _distanceMaterials[index] = material;\n    }\n\n    return material;\n  }\n\n  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {\n    var result = null;\n    var getMaterialVariant = getDepthMaterialVariant;\n    var customMaterial = object.customDepthMaterial;\n\n    if (light.isPointLight === true) {\n      getMaterialVariant = getDistanceMaterialVariant;\n      customMaterial = object.customDistanceMaterial;\n    }\n\n    if (customMaterial === undefined) {\n      var useMorphing = false;\n\n      if (material.morphTargets === true) {\n        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n      }\n\n      var useSkinning = false;\n\n      if (object.isSkinnedMesh === true) {\n        if (material.skinning === true) {\n          useSkinning = true;\n        } else {\n          console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);\n        }\n      }\n\n      var useInstancing = object.isInstancedMesh === true;\n      result = getMaterialVariant(useMorphing, useSkinning, useInstancing);\n    } else {\n      result = customMaterial;\n    }\n\n    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {\n      // in this case we need a unique material instance reflecting the\n      // appropriate state\n      var keyA = result.uuid,\n          keyB = material.uuid;\n      var materialsForVariant = _materialCache[keyA];\n\n      if (materialsForVariant === undefined) {\n        materialsForVariant = {};\n        _materialCache[keyA] = materialsForVariant;\n      }\n\n      var cachedMaterial = materialsForVariant[keyB];\n\n      if (cachedMaterial === undefined) {\n        cachedMaterial = result.clone();\n        materialsForVariant[keyB] = cachedMaterial;\n      }\n\n      result = cachedMaterial;\n    }\n\n    result.visible = material.visible;\n    result.wireframe = material.wireframe;\n\n    if (type === VSMShadowMap) {\n      result.side = material.shadowSide !== null ? material.shadowSide : material.side;\n    } else {\n      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];\n    }\n\n    result.clipShadows = material.clipShadows;\n    result.clippingPlanes = material.clippingPlanes;\n    result.clipIntersection = material.clipIntersection;\n    result.wireframeLinewidth = material.wireframeLinewidth;\n    result.linewidth = material.linewidth;\n\n    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {\n      result.referencePosition.setFromMatrixPosition(light.matrixWorld);\n      result.nearDistance = shadowCameraNear;\n      result.farDistance = shadowCameraFar;\n    }\n\n    return result;\n  }\n\n  function renderObject(object, camera, shadowCamera, light, type) {\n    if (object.visible === false) return;\n    var visible = object.layers.test(camera.layers);\n\n    if (visible && (object.isMesh || object.isLine || object.isPoints)) {\n      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {\n        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);\n\n        var geometry = _objects.update(object);\n\n        var material = object.material;\n\n        if (Array.isArray(material)) {\n          var groups = geometry.groups;\n\n          for (var k = 0, kl = groups.length; k < kl; k++) {\n            var group = groups[k];\n            var groupMaterial = material[group.materialIndex];\n\n            if (groupMaterial && groupMaterial.visible) {\n              var depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);\n\n              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);\n            }\n          }\n        } else if (material.visible) {\n          var _depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);\n\n          _renderer.renderBufferDirect(shadowCamera, null, geometry, _depthMaterial, object, null);\n        }\n      }\n    }\n\n    var children = object.children;\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      renderObject(children[i], camera, shadowCamera, light, type);\n    }\n  }\n}\n\nexport { WebGLShadowMap };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/renderers/webgl/WebGLShadowMap.js"],"names":["FrontSide","BackSide","DoubleSide","RGBAFormat","NearestFilter","LinearFilter","PCFShadowMap","VSMShadowMap","RGBADepthPacking","NoBlending","WebGLRenderTarget","MeshDepthMaterial","MeshDistanceMaterial","ShaderMaterial","BufferAttribute","BufferGeometry","Mesh","Vector4","Vector2","Frustum","vsm_frag","vsm_vert","WebGLShadowMap","_renderer","_objects","maxTextureSize","_frustum","_shadowMapSize","_viewportSize","_viewport","_depthMaterials","_distanceMaterials","_materialCache","shadowSide","shadowMaterialVertical","defines","SAMPLE_RATE","HALF_SAMPLE_RATE","uniforms","shadow_pass","value","resolution","radius","vertexShader","fragmentShader","shadowMaterialHorizonal","clone","HORIZONAL_PASS","fullScreenTri","setAttribute","Float32Array","fullScreenMesh","scope","enabled","autoUpdate","needsUpdate","type","render","lights","scene","camera","length","currentRenderTarget","getRenderTarget","activeCubeFace","getActiveCubeFace","activeMipmapLevel","getActiveMipmapLevel","_state","state","setBlending","buffers","color","setClear","depth","setTest","setScissorTest","i","il","light","shadow","undefined","console","warn","copy","mapSize","shadowFrameExtents","getFrameExtents","multiply","x","y","Math","floor","map","isPointLightShadow","pars","minFilter","magFilter","format","texture","name","mapPass","updateProjectionMatrix","setRenderTarget","clear","viewportCount","getViewportCount","vp","viewport","getViewport","set","z","w","updateMatrices","getFrustum","renderObject","VSMPass","geometry","update","renderBufferDirect","getDepthMaterialVariant","useMorphing","useSkinning","useInstancing","index","material","depthPacking","morphTargets","skinning","getDistanceMaterialVariant","getDepthMaterial","object","shadowCameraNear","shadowCameraFar","result","getMaterialVariant","customMaterial","customDepthMaterial","isPointLight","customDistanceMaterial","morphAttributes","position","isSkinnedMesh","isInstancedMesh","localClippingEnabled","clipShadows","clippingPlanes","keyA","uuid","keyB","materialsForVariant","cachedMaterial","visible","wireframe","side","clipIntersection","wireframeLinewidth","linewidth","isMeshDistanceMaterial","referencePosition","setFromMatrixPosition","matrixWorld","nearDistance","farDistance","shadowCamera","layers","test","isMesh","isLine","isPoints","castShadow","receiveShadow","frustumCulled","intersectsObject","modelViewMatrix","multiplyMatrices","matrixWorldInverse","Array","isArray","groups","k","kl","group","groupMaterial","materialIndex","depthMaterial","near","far","children","l"],"mappings":"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","sourcesContent":["import { FrontSide, BackSide, DoubleSide, RGBAFormat, NearestFilter, LinearFilter, PCFShadowMap, VSMShadowMap, RGBADepthPacking, NoBlending } from '../../constants.js';\nimport { WebGLRenderTarget } from '../WebGLRenderTarget.js';\nimport { MeshDepthMaterial } from '../../materials/MeshDepthMaterial.js';\nimport { MeshDistanceMaterial } from '../../materials/MeshDistanceMaterial.js';\nimport { ShaderMaterial } from '../../materials/ShaderMaterial.js';\nimport { BufferAttribute } from '../../core/BufferAttribute.js';\nimport { BufferGeometry } from '../../core/BufferGeometry.js';\nimport { Mesh } from '../../objects/Mesh.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Frustum } from '../../math/Frustum.js';\n\nimport vsm_frag from '../shaders/ShaderLib/vsm_frag.glsl.js';\nimport vsm_vert from '../shaders/ShaderLib/vsm_vert.glsl.js';\n\nfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {\n\n\tlet _frustum = new Frustum();\n\n\tconst _shadowMapSize = new Vector2(),\n\t\t_viewportSize = new Vector2(),\n\n\t\t_viewport = new Vector4(),\n\n\t\t_depthMaterials = [],\n\t\t_distanceMaterials = [],\n\n\t\t_materialCache = {};\n\n\tconst shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };\n\n\tconst shadowMaterialVertical = new ShaderMaterial( {\n\n\t\tdefines: {\n\t\t\tSAMPLE_RATE: 2.0 / 8.0,\n\t\t\tHALF_SAMPLE_RATE: 1.0 / 8.0\n\t\t},\n\n\t\tuniforms: {\n\t\t\tshadow_pass: { value: null },\n\t\t\tresolution: { value: new Vector2() },\n\t\t\tradius: { value: 4.0 }\n\t\t},\n\n\t\tvertexShader: vsm_vert,\n\n\t\tfragmentShader: vsm_frag\n\n\t} );\n\n\tconst shadowMaterialHorizonal = shadowMaterialVertical.clone();\n\tshadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;\n\n\tconst fullScreenTri = new BufferGeometry();\n\tfullScreenTri.setAttribute(\n\t\t\"position\",\n\t\tnew BufferAttribute(\n\t\t\tnew Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),\n\t\t\t3\n\t\t)\n\t);\n\n\tconst fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );\n\n\tconst scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = PCFShadowMap;\n\n\tthis.render = function ( lights, scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( lights.length === 0 ) return;\n\n\t\tconst currentRenderTarget = _renderer.getRenderTarget();\n\t\tconst activeCubeFace = _renderer.getActiveCubeFace();\n\t\tconst activeMipmapLevel = _renderer.getActiveMipmapLevel();\n\n\t\tconst _state = _renderer.state;\n\n\t\t// Set GL state for depth map.\n\t\t_state.setBlending( NoBlending );\n\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\n\t\t_state.buffers.depth.setTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// render depth map\n\n\t\tfor ( let i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\t\t\tconst shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\n\t\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t\tif ( _shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize ) {\n\n\t\t\t\tif ( _shadowMapSize.x > maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.x = Math.floor( maxTextureSize / shadowFrameExtents.x );\n\t\t\t\t\t_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n\t\t\t\t\tshadow.mapSize.x = _viewportSize.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _shadowMapSize.y > maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.y = Math.floor( maxTextureSize / shadowFrameExtents.y );\n\t\t\t\t\t_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n\t\t\t\t\tshadow.mapSize.y = _viewportSize.y;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {\n\n\t\t\t\tconst pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\n\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\tshadow.map.texture.name = light.name + \".shadowMap\";\n\n\t\t\t\tshadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\n\t\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\tconst pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\tshadow.map.texture.name = light.name + \".shadowMap\";\n\n\t\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\t_renderer.setRenderTarget( shadow.map );\n\t\t\t_renderer.clear();\n\n\t\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\t\t_viewport.set(\n\t\t\t\t\t_viewportSize.x * viewport.x,\n\t\t\t\t\t_viewportSize.y * viewport.y,\n\t\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t\t);\n\n\t\t\t\t_state.viewport( _viewport );\n\n\t\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\t\t_frustum = shadow.getFrustum();\n\n\t\t\t\trenderObject( scene, camera, shadow.camera, light, this.type );\n\n\t\t\t}\n\n\t\t\t// do blur pass for VSM\n\n\t\t\tif ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {\n\n\t\t\t\tVSMPass( shadow, camera );\n\n\t\t\t}\n\n\t\t\tshadow.needsUpdate = false;\n\n\t\t}\n\n\t\tscope.needsUpdate = false;\n\n\t\t_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t};\n\n\tfunction VSMPass( shadow, camera ) {\n\n\t\tconst geometry = _objects.update( fullScreenMesh );\n\n\t\t// vertical pass\n\n\t\tshadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n\t\tshadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\t\t_renderer.setRenderTarget( shadow.mapPass );\n\t\t_renderer.clear();\n\t\t_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );\n\n\t\t// horizonal pass\n\n\t\tshadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n\t\tshadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialHorizonal.uniforms.radius.value = shadow.radius;\n\t\t_renderer.setRenderTarget( shadow.map );\n\t\t_renderer.clear();\n\t\t_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null );\n\n\t}\n\n\tfunction getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {\n\n\t\tconst index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;\n\n\t\tlet material = _depthMaterials[ index ];\n\n\t\tif ( material === undefined ) {\n\n\t\t\tmaterial = new MeshDepthMaterial( {\n\n\t\t\t\tdepthPacking: RGBADepthPacking,\n\n\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\tskinning: useSkinning\n\n\t\t\t} );\n\n\t\t\t_depthMaterials[ index ] = material;\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n\tfunction getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {\n\n\t\tconst index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;\n\n\t\tlet material = _distanceMaterials[ index ];\n\n\t\tif ( material === undefined ) {\n\n\t\t\tmaterial = new MeshDistanceMaterial( {\n\n\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\tskinning: useSkinning\n\n\t\t\t} );\n\n\t\t\t_distanceMaterials[ index ] = material;\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n\tfunction getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {\n\n\t\tlet result = null;\n\n\t\tlet getMaterialVariant = getDepthMaterialVariant;\n\t\tlet customMaterial = object.customDepthMaterial;\n\n\t\tif ( light.isPointLight === true ) {\n\n\t\t\tgetMaterialVariant = getDistanceMaterialVariant;\n\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t}\n\n\t\tif ( customMaterial === undefined ) {\n\n\t\t\tlet useMorphing = false;\n\n\t\t\tif ( material.morphTargets === true ) {\n\n\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\n\t\t\t}\n\n\t\t\tlet useSkinning = false;\n\n\t\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\t\tif ( material.skinning === true ) {\n\n\t\t\t\t\tuseSkinning = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst useInstancing = object.isInstancedMesh === true;\n\n\t\t\tresult = getMaterialVariant( useMorphing, useSkinning, useInstancing );\n\n\t\t} else {\n\n\t\t\tresult = customMaterial;\n\n\t\t}\n\n\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\tmaterial.clipShadows === true &&\n\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t// appropriate state\n\n\t\t\tconst keyA = result.uuid, keyB = material.uuid;\n\n\t\t\tlet materialsForVariant = _materialCache[ keyA ];\n\n\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t}\n\n\t\t\tlet cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult = cachedMaterial;\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tif ( type === VSMShadowMap ) {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;\n\n\t\t} else {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];\n\n\t\t}\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\tresult.clipIntersection = material.clipIntersection;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {\n\n\t\t\tresult.referencePosition.setFromMatrixPosition( light.matrixWorld );\n\t\t\tresult.nearDistance = shadowCameraNear;\n\t\t\tresult.farDistance = shadowCameraFar;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction renderObject( object, camera, shadowCamera, light, type ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\tif ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\tconst geometry = _objects.update( object );\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\tfor ( let k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ k ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );\n\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );\n\n\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trenderObject( children[ i ], camera, shadowCamera, light, type );\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { WebGLShadowMap };\n"]},"metadata":{},"sourceType":"module"}