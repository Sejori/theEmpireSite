{"ast":null,"code":"import { CubeUVReflectionMapping, GammaEncoding, LinearEncoding, NoToneMapping, NearestFilter, NoBlending, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBM16Encoding, RGBM7Encoding, UnsignedByteType, sRGBEncoding } from '../constants.js';\nimport { BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { OrthographicCamera } from '../cameras/OrthographicCamera.js';\nimport { PerspectiveCamera } from '../cameras/PerspectiveCamera.js';\nimport { RawShaderMaterial } from '../materials/RawShaderMaterial.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { WebGLRenderTarget } from '../renderers/WebGLRenderTarget.js';\nvar LOD_MIN = 4;\nvar LOD_MAX = 8;\nvar SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\n\nvar EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\nvar TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\n\nvar MAX_SAMPLES = 20;\nvar ENCODINGS = {\n  [LinearEncoding]: 0,\n  [sRGBEncoding]: 1,\n  [RGBEEncoding]: 2,\n  [RGBM7Encoding]: 3,\n  [RGBM16Encoding]: 4,\n  [RGBDEncoding]: 5,\n  [GammaEncoding]: 6\n};\n\nvar _flatCamera = /*@__PURE__*/new OrthographicCamera();\n\nvar _createPlanes2 = /*@__PURE__*/_createPlanes(),\n    _lodPlanes = _createPlanes2._lodPlanes,\n    _sizeLods = _createPlanes2._sizeLods,\n    _sigmas = _createPlanes2._sigmas;\n\nvar _oldTarget = null; // Golden Ratio\n\nvar PHI = (1 + Math.sqrt(5)) / 2;\nvar INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\n\nvar _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n */\n\nclass PMREMGenerator {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n    this._blurMaterial = _getBlurShader(MAX_SAMPLES);\n    this._equirectShader = null;\n    this._cubemapShader = null;\n\n    this._compileMaterial(this._blurMaterial);\n  }\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   */\n\n\n  fromScene(scene, sigma = 0, near = 0.1, far = 100) {\n    _oldTarget = this._renderer.getRenderTarget();\n\n    var cubeUVRenderTarget = this._allocateTargets();\n\n    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n\n    if (sigma > 0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n\n    this._applyPMREM(cubeUVRenderTarget);\n\n    this._cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  }\n  /**\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\n   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n\n\n  fromEquirectangular(equirectangular) {\n    return this._fromTexture(equirectangular);\n  }\n  /**\n   * Generates a PMREM from an cubemap texture, which can be either LDR\n   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n\n\n  fromCubemap(cubemap) {\n    return this._fromTexture(cubemap);\n  }\n  /**\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n\n\n  compileCubemapShader() {\n    if (this._cubemapShader === null) {\n      this._cubemapShader = _getCubemapShader();\n\n      this._compileMaterial(this._cubemapShader);\n    }\n  }\n  /**\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n\n\n  compileEquirectangularShader() {\n    if (this._equirectShader === null) {\n      this._equirectShader = _getEquirectShader();\n\n      this._compileMaterial(this._equirectShader);\n    }\n  }\n  /**\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n   * one of them will cause any others to also become unusable.\n   */\n\n\n  dispose() {\n    this._blurMaterial.dispose();\n\n    if (this._cubemapShader !== null) this._cubemapShader.dispose();\n    if (this._equirectShader !== null) this._equirectShader.dispose();\n\n    for (var i = 0; i < _lodPlanes.length; i++) {\n      _lodPlanes[i].dispose();\n    }\n  } // private interface\n\n\n  _cleanup(outputTarget) {\n    this._pingPongRenderTarget.dispose();\n\n    this._renderer.setRenderTarget(_oldTarget);\n\n    outputTarget.scissorTest = false;\n\n    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  }\n\n  _fromTexture(texture) {\n    _oldTarget = this._renderer.getRenderTarget();\n\n    var cubeUVRenderTarget = this._allocateTargets(texture);\n\n    this._textureToCubeUV(texture, cubeUVRenderTarget);\n\n    this._applyPMREM(cubeUVRenderTarget);\n\n    this._cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  }\n\n  _allocateTargets(texture) {\n    // warning: null texture is valid\n    var params = {\n      magFilter: NearestFilter,\n      minFilter: NearestFilter,\n      generateMipmaps: false,\n      type: UnsignedByteType,\n      format: RGBEFormat,\n      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,\n      depthBuffer: false\n    };\n\n    var cubeUVRenderTarget = _createRenderTarget(params);\n\n    cubeUVRenderTarget.depthBuffer = texture ? false : true;\n    this._pingPongRenderTarget = _createRenderTarget(params);\n    return cubeUVRenderTarget;\n  }\n\n  _compileMaterial(material) {\n    var tmpMesh = new Mesh(_lodPlanes[0], material);\n\n    this._renderer.compile(tmpMesh, _flatCamera);\n  }\n\n  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n    var fov = 90;\n    var aspect = 1;\n    var cubeCamera = new PerspectiveCamera(fov, aspect, near, far);\n    var upSign = [1, -1, 1, 1, 1, 1];\n    var forwardSign = [1, 1, 1, -1, -1, -1];\n    var renderer = this._renderer;\n    var outputEncoding = renderer.outputEncoding;\n    var toneMapping = renderer.toneMapping;\n    var clearColor = renderer.getClearColor();\n    var clearAlpha = renderer.getClearAlpha();\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputEncoding = LinearEncoding;\n    var background = scene.background;\n\n    if (background && background.isColor) {\n      background.convertSRGBToLinear(); // Convert linear to RGBE\n\n      var maxComponent = Math.max(background.r, background.g, background.b);\n      var fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);\n      background = background.multiplyScalar(Math.pow(2.0, -fExp));\n      var alpha = (fExp + 128.0) / 255.0;\n      renderer.setClearColor(background, alpha);\n      scene.background = null;\n    }\n\n    for (var i = 0; i < 6; i++) {\n      var col = i % 3;\n\n      if (col == 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col == 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n\n      _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);\n\n      renderer.setRenderTarget(cubeUVRenderTarget);\n      renderer.render(scene, cubeCamera);\n    }\n\n    renderer.toneMapping = toneMapping;\n    renderer.outputEncoding = outputEncoding;\n    renderer.setClearColor(clearColor, clearAlpha);\n  }\n\n  _textureToCubeUV(texture, cubeUVRenderTarget) {\n    var renderer = this._renderer;\n\n    if (texture.isCubeTexture) {\n      if (this._cubemapShader == null) {\n        this._cubemapShader = _getCubemapShader();\n      }\n    } else {\n      if (this._equirectShader == null) {\n        this._equirectShader = _getEquirectShader();\n      }\n    }\n\n    var material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;\n    var mesh = new Mesh(_lodPlanes[0], material);\n    var uniforms = material.uniforms;\n    uniforms['envMap'].value = texture;\n\n    if (!texture.isCubeTexture) {\n      uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);\n    }\n\n    uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];\n    uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];\n\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);\n\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.render(mesh, _flatCamera);\n  }\n\n  _applyPMREM(cubeUVRenderTarget) {\n    var renderer = this._renderer;\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n\n    for (var i = 1; i < TOTAL_LODS; i++) {\n      var sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);\n      var poleAxis = _axisDirections[(i - 1) % _axisDirections.length];\n\n      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n    }\n\n    renderer.autoClear = autoClear;\n  }\n  /**\n   * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n   * vertically and horizontally, but this breaks down on a cube. Here we apply\n   * the blur latitudinally (around the poles), and then longitudinally (towards\n   * the poles) to approximate the orthogonally-separable blur. It is least\n   * accurate at the poles, but still does a decent job.\n   */\n\n\n  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n    var pingPongRenderTarget = this._pingPongRenderTarget;\n\n    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n\n    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n  }\n\n  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n    var renderer = this._renderer;\n    var blurMaterial = this._blurMaterial;\n\n    if (direction !== 'latitudinal' && direction !== 'longitudinal') {\n      console.error('blur direction must be either latitudinal or longitudinal!');\n    } // Number of standard deviations at which to cut off the discrete approximation.\n\n\n    var STANDARD_DEVIATIONS = 3;\n    var blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);\n    var blurUniforms = blurMaterial.uniforms;\n    var pixels = _sizeLods[lodIn] - 1;\n    var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    var sigmaPixels = sigmaRadians / radiansPerPixel;\n    var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n\n    if (samples > MAX_SAMPLES) {\n      console.warn(\"sigmaRadians, \".concat(sigmaRadians, \", is too large and will clip, as it requested \").concat(samples, \" samples when the maximum is set to \").concat(MAX_SAMPLES));\n    }\n\n    var weights = [];\n    var sum = 0;\n\n    for (var i = 0; i < MAX_SAMPLES; ++i) {\n      var _x = i / sigmaPixels;\n\n      var weight = Math.exp(-_x * _x / 2);\n      weights.push(weight);\n\n      if (i == 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n\n    for (var _i = 0; _i < weights.length; _i++) {\n      weights[_i] = weights[_i] / sum;\n    }\n\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n\n    if (poleAxis) {\n      blurUniforms['poleAxis'].value = poleAxis;\n    }\n\n    blurUniforms['dTheta'].value = radiansPerPixel;\n    blurUniforms['mipInt'].value = LOD_MAX - lodIn;\n    blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n    blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n    var outputSize = _sizeLods[lodOut];\n    var x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);\n    var y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);\n\n    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n\n    renderer.setRenderTarget(targetOut);\n    renderer.render(blurMesh, _flatCamera);\n  }\n\n}\n\nfunction _isLDR(texture) {\n  if (texture === undefined || texture.type !== UnsignedByteType) return false;\n  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;\n}\n\nfunction _createPlanes() {\n  var _lodPlanes = [];\n  var _sizeLods = [];\n  var _sigmas = [];\n  var lod = LOD_MAX;\n\n  for (var i = 0; i < TOTAL_LODS; i++) {\n    var sizeLod = Math.pow(2, lod);\n\n    _sizeLods.push(sizeLod);\n\n    var sigma = 1.0 / sizeLod;\n\n    if (i > LOD_MAX - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];\n    } else if (i == 0) {\n      sigma = 0;\n    }\n\n    _sigmas.push(sigma);\n\n    var texelSize = 1.0 / (sizeLod - 1);\n    var min = -texelSize / 2;\n    var max = 1 + texelSize / 2;\n    var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    var cubeFaces = 6;\n    var vertices = 6;\n    var positionSize = 3;\n    var uvSize = 2;\n    var faceIndexSize = 1;\n    var position = new Float32Array(positionSize * vertices * cubeFaces);\n    var uv = new Float32Array(uvSize * vertices * cubeFaces);\n    var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n\n    for (var face = 0; face < cubeFaces; face++) {\n      var x = face % 3 * 2 / 3 - 1;\n      var y = face > 2 ? 0 : -1;\n      var coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n      position.set(coordinates, positionSize * vertices * face);\n      uv.set(uv1, uvSize * vertices * face);\n      var fill = [face, face, face, face, face, face];\n      faceIndex.set(fill, faceIndexSize * vertices * face);\n    }\n\n    var planes = new BufferGeometry();\n    planes.setAttribute('position', new BufferAttribute(position, positionSize));\n    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));\n\n    _lodPlanes.push(planes);\n\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n\n  return {\n    _lodPlanes,\n    _sizeLods,\n    _sigmas\n  };\n}\n\nfunction _createRenderTarget(params) {\n  var cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\n\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\n\nfunction _getBlurShader(maxSamples) {\n  var weights = new Float32Array(maxSamples);\n  var poleAxis = new Vector3(0, 1, 0);\n  var shaderMaterial = new RawShaderMaterial({\n    name: 'SphericalGaussianBlur',\n    defines: {\n      'n': maxSamples\n    },\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'samples': {\n        value: 1\n      },\n      'weights': {\n        value: weights\n      },\n      'latitudinal': {\n        value: false\n      },\n      'dTheta': {\n        value: 0\n      },\n      'mipInt': {\n        value: 0\n      },\n      'poleAxis': {\n        value: poleAxis\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    \"\\n\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t\\tuniform sampler2D envMap;\\n\\t\\t\\tuniform int samples;\\n\\t\\t\\tuniform float weights[ n ];\\n\\t\\t\\tuniform bool latitudinal;\\n\\t\\t\\tuniform float dTheta;\\n\\t\\t\\tuniform float mipInt;\\n\\t\\t\\tuniform vec3 poleAxis;\\n\\n\\t\\t\\t\".concat(_getEncodings(), \"\\n\\n\\t\\t\\t#define ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\t#include <cube_uv_reflection_fragment>\\n\\n\\t\\t\\tvec3 getSample( float theta, vec3 axis ) {\\n\\n\\t\\t\\t\\tfloat cosTheta = cos( theta );\\n\\t\\t\\t\\t// Rodrigues' axis-angle rotation\\n\\t\\t\\t\\tvec3 sampleDirection = vOutputDirection * cosTheta\\n\\t\\t\\t\\t\\t+ cross( axis, vOutputDirection ) * sin( theta )\\n\\t\\t\\t\\t\\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\\n\\n\\t\\t\\t\\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\\n\\n\\t\\t\\t\\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\\n\\n\\t\\t\\t\\t\\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\taxis = normalize( axis );\\n\\n\\t\\t\\t\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\t\\t\\t\\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\\n\\n\\t\\t\\t\\tfor ( int i = 1; i < n; i++ ) {\\n\\n\\t\\t\\t\\t\\tif ( i >= samples ) {\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfloat theta = dTheta * float( i );\\n\\t\\t\\t\\t\\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\\n\\t\\t\\t\\t\\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgl_FragColor = linearToOutputTexel( gl_FragColor );\\n\\n\\t\\t\\t}\\n\\t\\t\"),\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getEquirectShader() {\n  var texelSize = new Vector2(1, 1);\n  var shaderMaterial = new RawShaderMaterial({\n    name: 'EquirectangularToCubeUV',\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'texelSize': {\n        value: texelSize\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    \"\\n\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t\\tuniform sampler2D envMap;\\n\\t\\t\\tuniform vec2 texelSize;\\n\\n\\t\\t\\t\".concat(_getEncodings(), \"\\n\\n\\t\\t\\t#include <common>\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\n\\t\\t\\t\\tvec3 outputDirection = normalize( vOutputDirection );\\n\\t\\t\\t\\tvec2 uv = equirectUv( outputDirection );\\n\\n\\t\\t\\t\\tvec2 f = fract( uv / texelSize - 0.5 );\\n\\t\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\t\\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\\n\\t\\t\\t\\tuv.x += texelSize.x;\\n\\t\\t\\t\\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\\n\\t\\t\\t\\tuv.y += texelSize.y;\\n\\t\\t\\t\\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\\n\\t\\t\\t\\tuv.x -= texelSize.x;\\n\\t\\t\\t\\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\\n\\n\\t\\t\\t\\tvec3 tm = mix( tl, tr, f.x );\\n\\t\\t\\t\\tvec3 bm = mix( bl, br, f.x );\\n\\t\\t\\t\\tgl_FragColor.rgb = mix( tm, bm, f.y );\\n\\n\\t\\t\\t\\tgl_FragColor = linearToOutputTexel( gl_FragColor );\\n\\n\\t\\t\\t}\\n\\t\\t\"),\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getCubemapShader() {\n  var shaderMaterial = new RawShaderMaterial({\n    name: 'CubemapToCubeUV',\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'inputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      },\n      'outputEncoding': {\n        value: ENCODINGS[LinearEncoding]\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    \"\\n\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t\\tuniform samplerCube envMap;\\n\\n\\t\\t\\t\".concat(_getEncodings(), \"\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\t\\t\\t\\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\\n\\t\\t\\t\\tgl_FragColor = linearToOutputTexel( gl_FragColor );\\n\\n\\t\\t\\t}\\n\\t\\t\"),\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getCommonVertexShader() {\n  return (\n    /* glsl */\n    \"\\n\\n\\t\\tprecision mediump float;\\n\\t\\tprecision mediump int;\\n\\n\\t\\tattribute vec3 position;\\n\\t\\tattribute vec2 uv;\\n\\t\\tattribute float faceIndex;\\n\\n\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t// RH coordinate system; PMREM face-indexing convention\\n\\t\\tvec3 getDirection( vec2 uv, float face ) {\\n\\n\\t\\t\\tuv = 2.0 * uv - 1.0;\\n\\n\\t\\t\\tvec3 direction = vec3( uv, 1.0 );\\n\\n\\t\\t\\tif ( face == 0.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.zyx; // ( 1, v, u ) pos x\\n\\n\\t\\t\\t} else if ( face == 1.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.xzy;\\n\\t\\t\\t\\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\\n\\n\\t\\t\\t} else if ( face == 2.0 ) {\\n\\n\\t\\t\\t\\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\\n\\n\\t\\t\\t} else if ( face == 3.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.zyx;\\n\\t\\t\\t\\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\\n\\n\\t\\t\\t} else if ( face == 4.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.xzy;\\n\\t\\t\\t\\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\\n\\n\\t\\t\\t} else if ( face == 5.0 ) {\\n\\n\\t\\t\\t\\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn direction;\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvOutputDirection = getDirection( uv, faceIndex );\\n\\t\\t\\tgl_Position = vec4( position, 1.0 );\\n\\n\\t\\t}\\n\\t\"\n  );\n}\n\nfunction _getEncodings() {\n  return (\n    /* glsl */\n    \"\\n\\n\\t\\tuniform int inputEncoding;\\n\\t\\tuniform int outputEncoding;\\n\\n\\t\\t#include <encodings_pars_fragment>\\n\\n\\t\\tvec4 inputTexelToLinear( vec4 value ) {\\n\\n\\t\\t\\tif ( inputEncoding == 0 ) {\\n\\n\\t\\t\\t\\treturn value;\\n\\n\\t\\t\\t} else if ( inputEncoding == 1 ) {\\n\\n\\t\\t\\t\\treturn sRGBToLinear( value );\\n\\n\\t\\t\\t} else if ( inputEncoding == 2 ) {\\n\\n\\t\\t\\t\\treturn RGBEToLinear( value );\\n\\n\\t\\t\\t} else if ( inputEncoding == 3 ) {\\n\\n\\t\\t\\t\\treturn RGBMToLinear( value, 7.0 );\\n\\n\\t\\t\\t} else if ( inputEncoding == 4 ) {\\n\\n\\t\\t\\t\\treturn RGBMToLinear( value, 16.0 );\\n\\n\\t\\t\\t} else if ( inputEncoding == 5 ) {\\n\\n\\t\\t\\t\\treturn RGBDToLinear( value, 256.0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn GammaToLinear( value, 2.2 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvec4 linearToOutputTexel( vec4 value ) {\\n\\n\\t\\t\\tif ( outputEncoding == 0 ) {\\n\\n\\t\\t\\t\\treturn value;\\n\\n\\t\\t\\t} else if ( outputEncoding == 1 ) {\\n\\n\\t\\t\\t\\treturn LinearTosRGB( value );\\n\\n\\t\\t\\t} else if ( outputEncoding == 2 ) {\\n\\n\\t\\t\\t\\treturn LinearToRGBE( value );\\n\\n\\t\\t\\t} else if ( outputEncoding == 3 ) {\\n\\n\\t\\t\\t\\treturn LinearToRGBM( value, 7.0 );\\n\\n\\t\\t\\t} else if ( outputEncoding == 4 ) {\\n\\n\\t\\t\\t\\treturn LinearToRGBM( value, 16.0 );\\n\\n\\t\\t\\t} else if ( outputEncoding == 5 ) {\\n\\n\\t\\t\\t\\treturn LinearToRGBD( value, 256.0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn LinearToGamma( value, 2.2 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvec4 envMapTexelToLinear( vec4 color ) {\\n\\n\\t\\t\\treturn inputTexelToLinear( color );\\n\\n\\t\\t}\\n\\t\"\n  );\n}\n\nexport { PMREMGenerator };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/extras/PMREMGenerator.js"],"names":["CubeUVReflectionMapping","GammaEncoding","LinearEncoding","NoToneMapping","NearestFilter","NoBlending","RGBDEncoding","RGBEEncoding","RGBEFormat","RGBM16Encoding","RGBM7Encoding","UnsignedByteType","sRGBEncoding","BufferAttribute","BufferGeometry","Mesh","OrthographicCamera","PerspectiveCamera","RawShaderMaterial","Vector2","Vector3","WebGLRenderTarget","LOD_MIN","LOD_MAX","SIZE_MAX","Math","pow","EXTRA_LOD_SIGMA","TOTAL_LODS","length","MAX_SAMPLES","ENCODINGS","_flatCamera","_createPlanes","_lodPlanes","_sizeLods","_sigmas","_oldTarget","PHI","sqrt","INV_PHI","_axisDirections","PMREMGenerator","constructor","renderer","_renderer","_pingPongRenderTarget","_blurMaterial","_getBlurShader","_equirectShader","_cubemapShader","_compileMaterial","fromScene","scene","sigma","near","far","getRenderTarget","cubeUVRenderTarget","_allocateTargets","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","fromEquirectangular","equirectangular","_fromTexture","fromCubemap","cubemap","compileCubemapShader","_getCubemapShader","compileEquirectangularShader","_getEquirectShader","dispose","i","outputTarget","setRenderTarget","scissorTest","_setViewport","width","height","texture","_textureToCubeUV","params","magFilter","minFilter","generateMipmaps","type","format","encoding","_isLDR","depthBuffer","_createRenderTarget","material","tmpMesh","compile","fov","aspect","cubeCamera","upSign","forwardSign","outputEncoding","toneMapping","clearColor","getClearColor","clearAlpha","getClearAlpha","background","isColor","convertSRGBToLinear","maxComponent","max","r","g","b","fExp","min","ceil","log2","multiplyScalar","alpha","setClearColor","col","up","set","lookAt","render","isCubeTexture","mesh","uniforms","value","image","autoClear","poleAxis","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","direction","blurMaterial","console","error","STANDARD_DEVIATIONS","blurMesh","blurUniforms","pixels","radiansPerPixel","isFinite","PI","sigmaPixels","samples","floor","warn","weights","sum","x","weight","exp","push","outputSize","y","undefined","lod","sizeLod","texelSize","uv1","cubeFaces","vertices","positionSize","uvSize","faceIndexSize","position","Float32Array","uv","faceIndex","face","coordinates","fill","planes","setAttribute","mapping","name","target","viewport","scissor","maxSamples","shaderMaterial","defines","vertexShader","_getCommonVertexShader","fragmentShader","_getEncodings","blending","depthTest","depthWrite"],"mappings":"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","sourcesContent":["import {\n\tCubeUVReflectionMapping,\n\tGammaEncoding,\n\tLinearEncoding,\n\tNoToneMapping,\n\tNearestFilter,\n\tNoBlending,\n\tRGBDEncoding,\n\tRGBEEncoding,\n\tRGBEFormat,\n\tRGBM16Encoding,\n\tRGBM7Encoding,\n\tUnsignedByteType,\n\tsRGBEncoding\n} from '../constants.js';\n\nimport { BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { OrthographicCamera } from '../cameras/OrthographicCamera.js';\nimport { PerspectiveCamera } from '../cameras/PerspectiveCamera.js';\nimport { RawShaderMaterial } from '../materials/RawShaderMaterial.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { WebGLRenderTarget } from '../renderers/WebGLRenderTarget.js';\n\nconst LOD_MIN = 4;\nconst LOD_MAX = 8;\nconst SIZE_MAX = Math.pow( 2, LOD_MAX );\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\nconst TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst ENCODINGS = {\n\t[ LinearEncoding ]: 0,\n\t[ sRGBEncoding ]: 1,\n\t[ RGBEEncoding ]: 2,\n\t[ RGBM7Encoding ]: 3,\n\t[ RGBM16Encoding ]: 4,\n\t[ RGBDEncoding ]: 5,\n\t[ GammaEncoding ]: 6\n};\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera();\nconst { _lodPlanes, _sizeLods, _sigmas } = /*@__PURE__*/ _createPlanes();\nlet _oldTarget = null;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n */\n\nclass PMREMGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._blurMaterial = _getBlurShader( MAX_SAMPLES );\n\t\tthis._equirectShader = null;\n\t\tthis._cubemapShader = null;\n\n\t\tthis._compileMaterial( this._blurMaterial );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100 ) {\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\tconst cubeUVRenderTarget = this._allocateTargets();\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromEquirectangular( equirectangular ) {\n\n\t\treturn this._fromTexture( equirectangular );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromCubemap( cubemap ) {\n\n\t\treturn this._fromTexture( cubemap );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileCubemapShader() {\n\n\t\tif ( this._cubemapShader === null ) {\n\n\t\t\tthis._cubemapShader = _getCubemapShader();\n\t\t\tthis._compileMaterial( this._cubemapShader );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileEquirectangularShader() {\n\n\t\tif ( this._equirectShader === null ) {\n\n\t\t\tthis._equirectShader = _getEquirectShader();\n\t\t\tthis._compileMaterial( this._equirectShader );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._blurMaterial.dispose();\n\n\t\tif ( this._cubemapShader !== null ) this._cubemapShader.dispose();\n\t\tif ( this._equirectShader !== null ) this._equirectShader.dispose();\n\n\t\tfor ( let i = 0; i < _lodPlanes.length; i ++ ) {\n\n\t\t\t_lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t// private interface\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._pingPongRenderTarget.dispose();\n\t\tthis._renderer.setRenderTarget( _oldTarget );\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture ) {\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\t\tconst cubeUVRenderTarget = this._allocateTargets( texture );\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets( texture ) { // warning: null texture is valid\n\n\t\tconst params = {\n\t\t\tmagFilter: NearestFilter,\n\t\t\tminFilter: NearestFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: UnsignedByteType,\n\t\t\tformat: RGBEFormat,\n\t\t\tencoding: _isLDR( texture ) ? texture.encoding : RGBEEncoding,\n\t\t\tdepthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( params );\n\t\tcubeUVRenderTarget.depthBuffer = texture ? false : true;\n\t\tthis._pingPongRenderTarget = _createRenderTarget( params );\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_compileMaterial( material ) {\n\n\t\tconst tmpMesh = new Mesh( _lodPlanes[ 0 ], material );\n\t\tthis._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\t\tconst fov = 90;\n\t\tconst aspect = 1;\n\t\tconst cubeCamera = new PerspectiveCamera( fov, aspect, near, far );\n\t\tconst upSign = [ 1, - 1, 1, 1, 1, 1 ];\n\t\tconst forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\n\t\tconst renderer = this._renderer;\n\n\t\tconst outputEncoding = renderer.outputEncoding;\n\t\tconst toneMapping = renderer.toneMapping;\n\t\tconst clearColor = renderer.getClearColor();\n\t\tconst clearAlpha = renderer.getClearAlpha();\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.outputEncoding = LinearEncoding;\n\n\t\tlet background = scene.background;\n\t\tif ( background && background.isColor ) {\n\n\t\t\tbackground.convertSRGBToLinear();\n\t\t\t// Convert linear to RGBE\n\t\t\tconst maxComponent = Math.max( background.r, background.g, background.b );\n\t\t\tconst fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );\n\t\t\tbackground = background.multiplyScalar( Math.pow( 2.0, - fExp ) );\n\t\t\tconst alpha = ( fExp + 128.0 ) / 255.0;\n\t\t\trenderer.setClearColor( background, alpha );\n\t\t\tscene.background = null;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\t\t\tif ( col == 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t\t} else if ( col == 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\t_setViewport( cubeUVRenderTarget,\n\t\t\t\tcol * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );\n\t\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.outputEncoding = outputEncoding;\n\t\trenderer.setClearColor( clearColor, clearAlpha );\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tif ( texture.isCubeTexture ) {\n\n\t\t\tif ( this._cubemapShader == null ) {\n\n\t\t\t\tthis._cubemapShader = _getCubemapShader();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( this._equirectShader == null ) {\n\n\t\t\t\tthis._equirectShader = _getEquirectShader();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;\n\t\tconst mesh = new Mesh( _lodPlanes[ 0 ], material );\n\n\t\tconst uniforms = material.uniforms;\n\n\t\tuniforms[ 'envMap' ].value = texture;\n\n\t\tif ( ! texture.isCubeTexture ) {\n\n\t\t\tuniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );\n\n\t\t}\n\n\t\tuniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];\n\t\tuniforms[ 'outputEncoding' ].value = ENCODINGS[ cubeUVRenderTarget.texture.encoding ];\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tfor ( let i = 1; i < TOTAL_LODS; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( _sigmas[ i ] * _sigmas[ i ] - _sigmas[ i - 1 ] * _sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error(\n\t\t\t\t'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = new Mesh( _lodPlanes[ lodOut ], blurMaterial );\n\t\tconst blurUniforms = blurMaterial.uniforms;\n\n\t\tconst pixels = _sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i == 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\tblurUniforms[ 'envMap' ].value = targetIn.texture;\n\t\tblurUniforms[ 'samples' ].value = samples;\n\t\tblurUniforms[ 'weights' ].value = weights;\n\t\tblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms[ 'poleAxis' ].value = poleAxis;\n\n\t\t}\n\n\t\tblurUniforms[ 'dTheta' ].value = radiansPerPixel;\n\t\tblurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;\n\t\tblurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];\n\t\tblurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];\n\n\t\tconst outputSize = _sizeLods[ lodOut ];\n\t\tconst x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );\n\t\tconst y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) + 2 * outputSize * ( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\nfunction _isLDR( texture ) {\n\n\tif ( texture === undefined || texture.type !== UnsignedByteType ) return false;\n\n\treturn texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;\n\n}\n\nfunction _createPlanes() {\n\n\tconst _lodPlanes = [];\n\tconst _sizeLods = [];\n\tconst _sigmas = [];\n\n\tlet lod = LOD_MAX;\n\n\tfor ( let i = 0; i < TOTAL_LODS; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\t_sizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > LOD_MAX - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];\n\n\t\t} else if ( i == 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\t_sigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 1 );\n\t\tconst min = - texelSize / 2;\n\t\tconst max = 1 + texelSize / 2;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\t\t\tposition.set( coordinates, positionSize * vertices * face );\n\t\t\tuv.set( uv1, uvSize * vertices * face );\n\t\t\tconst fill = [ face, face, face, face, face, face ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * face );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\t_lodPlanes.push( planes );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { _lodPlanes, _sizeLods, _sigmas };\n\n}\n\nfunction _createRenderTarget( params ) {\n\n\tconst cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getBlurShader( maxSamples ) {\n\n\tconst weights = new Float32Array( maxSamples );\n\tconst poleAxis = new Vector3( 0, 1, 0 );\n\tconst shaderMaterial = new RawShaderMaterial( {\n\n\t\tname: 'SphericalGaussianBlur',\n\n\t\tdefines: { 'n': maxSamples },\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'samples': { value: 1 },\n\t\t\t'weights': { value: weights },\n\t\t\t'latitudinal': { value: false },\n\t\t\t'dTheta': { value: 0 },\n\t\t\t'mipInt': { value: 0 },\n\t\t\t'poleAxis': { value: poleAxis },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${ _getEncodings() }\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getEquirectShader() {\n\n\tconst texelSize = new Vector2( 1, 1 );\n\tconst shaderMaterial = new RawShaderMaterial( {\n\n\t\tname: 'EquirectangularToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'texelSize': { value: texelSize },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${ _getEncodings() }\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getCubemapShader() {\n\n\tconst shaderMaterial = new RawShaderMaterial( {\n\n\t\tname: 'CubemapToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },\n\t\t\t'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${ _getEncodings() }\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getCommonVertexShader() {\n\n\treturn /* glsl */`\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`;\n\n}\n\nfunction _getEncodings() {\n\n\treturn /* glsl */`\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t`;\n\n}\n\nexport { PMREMGenerator };\n"]},"metadata":{},"sourceType":"module"}