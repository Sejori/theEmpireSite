{"ast":null,"code":"/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\n\nclass ExtrudeBufferGeometry extends BufferGeometry {\n  constructor(shapes, options) {\n    super();\n    this.type = 'ExtrudeBufferGeometry';\n    this.parameters = {\n      shapes: shapes,\n      options: options\n    };\n    shapes = Array.isArray(shapes) ? shapes : [shapes];\n    var scope = this;\n    var verticesArray = [];\n    var uvArray = [];\n\n    for (var i = 0, l = shapes.length; i < l; i++) {\n      var shape = shapes[i];\n      addShape(shape);\n    } // build geometry\n\n\n    this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));\n    this.computeVertexNormals(); // functions\n\n    function addShape(shape) {\n      var placeholder = []; // options\n\n      var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n      var steps = options.steps !== undefined ? options.steps : 1;\n      var depth = options.depth !== undefined ? options.depth : 100;\n      var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n      var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\n      var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\n      var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n      var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n      var extrudePath = options.extrudePath;\n      var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options\n\n      if (options.amount !== undefined) {\n        console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');\n        depth = options.amount;\n      } //\n\n\n      var extrudePts,\n          extrudeByPath = false;\n      var splineTube, binormal, normal, position2;\n\n      if (extrudePath) {\n        extrudePts = extrudePath.getSpacedPoints(steps);\n        extrudeByPath = true;\n        bevelEnabled = false; // bevels not supported for path extrusion\n        // SETUP TNB variables\n        // TODO1 - have a .isClosed in spline?\n\n        splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n        binormal = new Vector3();\n        normal = new Vector3();\n        position2 = new Vector3();\n      } // Safeguards if bevels are not enabled\n\n\n      if (!bevelEnabled) {\n        bevelSegments = 0;\n        bevelThickness = 0;\n        bevelSize = 0;\n        bevelOffset = 0;\n      } // Variables initialization\n\n\n      var shapePoints = shape.extractPoints(curveSegments);\n      var vertices = shapePoints.shape;\n      var holes = shapePoints.holes;\n      var reverse = !ShapeUtils.isClockWise(vertices);\n\n      if (reverse) {\n        vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n        for (var h = 0, hl = holes.length; h < hl; h++) {\n          var ahole = holes[h];\n\n          if (ShapeUtils.isClockWise(ahole)) {\n            holes[h] = ahole.reverse();\n          }\n        }\n      }\n\n      var faces = ShapeUtils.triangulateShape(vertices, holes);\n      /* Vertices */\n\n      var contour = vertices; // vertices has all points but contour has only points of circumference\n\n      for (var _h = 0, _hl = holes.length; _h < _hl; _h++) {\n        var _ahole = holes[_h];\n        vertices = vertices.concat(_ahole);\n      }\n\n      function scalePt2(pt, vec, size) {\n        if (!vec) console.error(\"THREE.ExtrudeGeometry: vec does not exist\");\n        return vec.clone().multiplyScalar(size).add(pt);\n      }\n\n      var vlen = vertices.length,\n          flen = faces.length; // Find directions for point movement\n\n      function getBevelVec(inPt, inPrev, inNext) {\n        // computes for inPt the corresponding point inPt' on a new contour\n        //   shifted by 1 unit (length of normalized vector) to the left\n        // if we walk along contour clockwise, this new contour is outside the old one\n        //\n        // inPt' is the intersection of the two lines parallel to the two\n        //  adjacent edges of inPt at a distance of 1 unit on the left side.\n        var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n        // good reading for geometry algorithms (here: line-line intersection)\n        // http://geomalgorithms.com/a05-_intersect-1.html\n\n        var v_prev_x = inPt.x - inPrev.x,\n            v_prev_y = inPt.y - inPrev.y;\n        var v_next_x = inNext.x - inPt.x,\n            v_next_y = inNext.y - inPt.y;\n        var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges\n\n        var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\n\n        if (Math.abs(collinear0) > Number.EPSILON) {\n          // not collinear\n          // length of vectors for normalizing\n          var v_prev_len = Math.sqrt(v_prev_lensq);\n          var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left\n\n          var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\n          var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\n          var ptNextShift_x = inNext.x - v_next_y / v_next_len;\n          var ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point\n\n          var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point\n\n          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\n          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly\n          //  but prevent crazy spikes\n\n          var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\n\n          if (v_trans_lensq <= 2) {\n            return new Vector2(v_trans_x, v_trans_y);\n          } else {\n            shrink_by = Math.sqrt(v_trans_lensq / 2);\n          }\n        } else {\n          // handle special case of collinear edges\n          var direction_eq = false; // assumes: opposite\n\n          if (v_prev_x > Number.EPSILON) {\n            if (v_next_x > Number.EPSILON) {\n              direction_eq = true;\n            }\n          } else {\n            if (v_prev_x < -Number.EPSILON) {\n              if (v_next_x < -Number.EPSILON) {\n                direction_eq = true;\n              }\n            } else {\n              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\n                direction_eq = true;\n              }\n            }\n          }\n\n          if (direction_eq) {\n            // console.log(\"Warning: lines are a straight sequence\");\n            v_trans_x = -v_prev_y;\n            v_trans_y = v_prev_x;\n            shrink_by = Math.sqrt(v_prev_lensq);\n          } else {\n            // console.log(\"Warning: lines are a straight spike\");\n            v_trans_x = v_prev_x;\n            v_trans_y = v_prev_y;\n            shrink_by = Math.sqrt(v_prev_lensq / 2);\n          }\n        }\n\n        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\n      }\n\n      var contourMovements = [];\n\n      for (var _i = 0, il = contour.length, j = il - 1, k = _i + 1; _i < il; _i++, j++, k++) {\n        if (j === il) j = 0;\n        if (k === il) k = 0; //  (j)---(i)---(k)\n        // console.log('i,j,k', i, j , k)\n\n        contourMovements[_i] = getBevelVec(contour[_i], contour[j], contour[k]);\n      }\n\n      var holesMovements = [];\n      var oneHoleMovements,\n          verticesMovements = contourMovements.concat();\n\n      for (var _h2 = 0, _hl2 = holes.length; _h2 < _hl2; _h2++) {\n        var _ahole2 = holes[_h2];\n        oneHoleMovements = [];\n\n        for (var _i2 = 0, _il = _ahole2.length, _j = _il - 1, _k = _i2 + 1; _i2 < _il; _i2++, _j++, _k++) {\n          if (_j === _il) _j = 0;\n          if (_k === _il) _k = 0; //  (j)---(i)---(k)\n\n          oneHoleMovements[_i2] = getBevelVec(_ahole2[_i2], _ahole2[_j], _ahole2[_k]);\n        }\n\n        holesMovements.push(oneHoleMovements);\n        verticesMovements = verticesMovements.concat(oneHoleMovements);\n      } // Loop bevelSegments, 1 for the front, 1 for the back\n\n\n      for (var b = 0; b < bevelSegments; b++) {\n        //for ( b = bevelSegments; b > 0; b -- ) {\n        var t = b / bevelSegments;\n        var z = bevelThickness * Math.cos(t * Math.PI / 2);\n\n        var _bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape\n\n\n        for (var _i3 = 0, _il2 = contour.length; _i3 < _il2; _i3++) {\n          var vert = scalePt2(contour[_i3], contourMovements[_i3], _bs);\n          v(vert.x, vert.y, -z);\n        } // expand holes\n\n\n        for (var _h3 = 0, _hl3 = holes.length; _h3 < _hl3; _h3++) {\n          var _ahole3 = holes[_h3];\n          oneHoleMovements = holesMovements[_h3];\n\n          for (var _i4 = 0, _il3 = _ahole3.length; _i4 < _il3; _i4++) {\n            var _vert = scalePt2(_ahole3[_i4], oneHoleMovements[_i4], _bs);\n\n            v(_vert.x, _vert.y, -z);\n          }\n        }\n      }\n\n      var bs = bevelSize + bevelOffset; // Back facing vertices\n\n      for (var _i5 = 0; _i5 < vlen; _i5++) {\n        var _vert2 = bevelEnabled ? scalePt2(vertices[_i5], verticesMovements[_i5], bs) : vertices[_i5];\n\n        if (!extrudeByPath) {\n          v(_vert2.x, _vert2.y, 0);\n        } else {\n          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n          normal.copy(splineTube.normals[0]).multiplyScalar(_vert2.x);\n          binormal.copy(splineTube.binormals[0]).multiplyScalar(_vert2.y);\n          position2.copy(extrudePts[0]).add(normal).add(binormal);\n          v(position2.x, position2.y, position2.z);\n        }\n      } // Add stepped vertices...\n      // Including front facing vertices\n\n\n      for (var s = 1; s <= steps; s++) {\n        for (var _i6 = 0; _i6 < vlen; _i6++) {\n          var _vert3 = bevelEnabled ? scalePt2(vertices[_i6], verticesMovements[_i6], bs) : vertices[_i6];\n\n          if (!extrudeByPath) {\n            v(_vert3.x, _vert3.y, depth / steps * s);\n          } else {\n            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n            normal.copy(splineTube.normals[s]).multiplyScalar(_vert3.x);\n            binormal.copy(splineTube.binormals[s]).multiplyScalar(_vert3.y);\n            position2.copy(extrudePts[s]).add(normal).add(binormal);\n            v(position2.x, position2.y, position2.z);\n          }\n        }\n      } // Add bevel segments planes\n      //for ( b = 1; b <= bevelSegments; b ++ ) {\n\n\n      for (var _b = bevelSegments - 1; _b >= 0; _b--) {\n        var _t = _b / bevelSegments;\n\n        var _z = bevelThickness * Math.cos(_t * Math.PI / 2);\n\n        var _bs2 = bevelSize * Math.sin(_t * Math.PI / 2) + bevelOffset; // contract shape\n\n\n        for (var _i7 = 0, _il4 = contour.length; _i7 < _il4; _i7++) {\n          var _vert4 = scalePt2(contour[_i7], contourMovements[_i7], _bs2);\n\n          v(_vert4.x, _vert4.y, depth + _z);\n        } // expand holes\n\n\n        for (var _h4 = 0, _hl4 = holes.length; _h4 < _hl4; _h4++) {\n          var _ahole4 = holes[_h4];\n          oneHoleMovements = holesMovements[_h4];\n\n          for (var _i8 = 0, _il5 = _ahole4.length; _i8 < _il5; _i8++) {\n            var _vert5 = scalePt2(_ahole4[_i8], oneHoleMovements[_i8], _bs2);\n\n            if (!extrudeByPath) {\n              v(_vert5.x, _vert5.y, depth + _z);\n            } else {\n              v(_vert5.x, _vert5.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + _z);\n            }\n          }\n        }\n      }\n      /* Faces */\n      // Top and bottom faces\n\n\n      buildLidFaces(); // Sides faces\n\n      buildSideFaces(); /////  Internal functions\n\n      function buildLidFaces() {\n        var start = verticesArray.length / 3;\n\n        if (bevelEnabled) {\n          var layer = 0; // steps + 1\n\n          var offset = vlen * layer; // Bottom faces\n\n          for (var _i9 = 0; _i9 < flen; _i9++) {\n            var face = faces[_i9];\n            f3(face[2] + offset, face[1] + offset, face[0] + offset);\n          }\n\n          layer = steps + bevelSegments * 2;\n          offset = vlen * layer; // Top faces\n\n          for (var _i10 = 0; _i10 < flen; _i10++) {\n            var _face = faces[_i10];\n            f3(_face[0] + offset, _face[1] + offset, _face[2] + offset);\n          }\n        } else {\n          // Bottom faces\n          for (var _i11 = 0; _i11 < flen; _i11++) {\n            var _face2 = faces[_i11];\n            f3(_face2[2], _face2[1], _face2[0]);\n          } // Top faces\n\n\n          for (var _i12 = 0; _i12 < flen; _i12++) {\n            var _face3 = faces[_i12];\n            f3(_face3[0] + vlen * steps, _face3[1] + vlen * steps, _face3[2] + vlen * steps);\n          }\n        }\n\n        scope.addGroup(start, verticesArray.length / 3 - start, 0);\n      } // Create faces for the z-sides of the shape\n\n\n      function buildSideFaces() {\n        var start = verticesArray.length / 3;\n        var layeroffset = 0;\n        sidewalls(contour, layeroffset);\n        layeroffset += contour.length;\n\n        for (var _h5 = 0, _hl5 = holes.length; _h5 < _hl5; _h5++) {\n          var _ahole5 = holes[_h5];\n          sidewalls(_ahole5, layeroffset); //, true\n\n          layeroffset += _ahole5.length;\n        }\n\n        scope.addGroup(start, verticesArray.length / 3 - start, 1);\n      }\n\n      function sidewalls(contour, layeroffset) {\n        var i = contour.length;\n\n        while (--i >= 0) {\n          var _j2 = i;\n\n          var _k2 = i - 1;\n\n          if (_k2 < 0) _k2 = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);\n\n          for (var _s = 0, sl = steps + bevelSegments * 2; _s < sl; _s++) {\n            var slen1 = vlen * _s;\n            var slen2 = vlen * (_s + 1);\n\n            var a = layeroffset + _j2 + slen1,\n                _b2 = layeroffset + _k2 + slen1,\n                c = layeroffset + _k2 + slen2,\n                d = layeroffset + _j2 + slen2;\n\n            f4(a, _b2, c, d);\n          }\n        }\n      }\n\n      function v(x, y, z) {\n        placeholder.push(x);\n        placeholder.push(y);\n        placeholder.push(z);\n      }\n\n      function f3(a, b, c) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(c);\n        var nextIndex = verticesArray.length / 3;\n        var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n      }\n\n      function f4(a, b, c, d) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(d);\n        addVertex(b);\n        addVertex(c);\n        addVertex(d);\n        var nextIndex = verticesArray.length / 3;\n        var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[3]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n        addUV(uvs[3]);\n      }\n\n      function addVertex(index) {\n        verticesArray.push(placeholder[index * 3 + 0]);\n        verticesArray.push(placeholder[index * 3 + 1]);\n        verticesArray.push(placeholder[index * 3 + 2]);\n      }\n\n      function addUV(vector2) {\n        uvArray.push(vector2.x);\n        uvArray.push(vector2.y);\n      }\n    }\n  }\n\n  toJSON() {\n    var data = BufferGeometry.prototype.toJSON.call(this);\n    var shapes = this.parameters.shapes;\n    var options = this.parameters.options;\n    return toJSON(shapes, options, data);\n  }\n\n}\n\nvar WorldUVGenerator = {\n  generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {\n    var a_x = vertices[indexA * 3];\n    var a_y = vertices[indexA * 3 + 1];\n    var b_x = vertices[indexB * 3];\n    var b_y = vertices[indexB * 3 + 1];\n    var c_x = vertices[indexC * 3];\n    var c_y = vertices[indexC * 3 + 1];\n    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];\n  },\n  generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {\n    var a_x = vertices[indexA * 3];\n    var a_y = vertices[indexA * 3 + 1];\n    var a_z = vertices[indexA * 3 + 2];\n    var b_x = vertices[indexB * 3];\n    var b_y = vertices[indexB * 3 + 1];\n    var b_z = vertices[indexB * 3 + 2];\n    var c_x = vertices[indexC * 3];\n    var c_y = vertices[indexC * 3 + 1];\n    var c_z = vertices[indexC * 3 + 2];\n    var d_x = vertices[indexD * 3];\n    var d_y = vertices[indexD * 3 + 1];\n    var d_z = vertices[indexD * 3 + 2];\n\n    if (Math.abs(a_y - b_y) < 0.01) {\n      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];\n    } else {\n      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];\n    }\n  }\n};\n\nfunction toJSON(shapes, options, data) {\n  data.shapes = [];\n\n  if (Array.isArray(shapes)) {\n    for (var i = 0, l = shapes.length; i < l; i++) {\n      var shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n\n  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();\n  return data;\n}\n\nexport { ExtrudeBufferGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/ExtrudeBufferGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector2","Vector3","ShapeUtils","ExtrudeBufferGeometry","constructor","shapes","options","type","parameters","Array","isArray","scope","verticesArray","uvArray","i","l","length","shape","addShape","setAttribute","computeVertexNormals","placeholder","curveSegments","undefined","steps","depth","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","extrudePath","uvgen","UVGenerator","WorldUVGenerator","amount","console","warn","extrudePts","extrudeByPath","splineTube","binormal","normal","position2","getSpacedPoints","computeFrenetFrames","shapePoints","extractPoints","vertices","holes","reverse","isClockWise","h","hl","ahole","faces","triangulateShape","contour","concat","scalePt2","pt","vec","size","error","clone","multiplyScalar","add","vlen","flen","getBevelVec","inPt","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","x","v_prev_y","y","v_next_x","v_next_y","v_prev_lensq","collinear0","Math","abs","Number","EPSILON","v_prev_len","sqrt","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","sign","contourMovements","il","j","k","holesMovements","oneHoleMovements","verticesMovements","push","b","t","z","cos","PI","bs","sin","vert","v","copy","normals","binormals","s","buildLidFaces","buildSideFaces","start","layer","offset","face","f3","addGroup","layeroffset","sidewalls","sl","slen1","slen2","a","c","d","f4","addVertex","nextIndex","uvs","generateTopUV","addUV","generateSideWallUV","index","vector2","toJSON","data","prototype","call","geometry","indexA","indexB","indexC","a_x","a_y","b_x","b_y","c_x","c_y","indexD","a_z","b_z","c_z","d_x","d_y","d_z","uuid"],"mappings":"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","sourcesContent":["/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\n\nclass ExtrudeBufferGeometry extends BufferGeometry {\n\n\tconstructor( shapes, options ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ExtrudeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\toptions: options\n\t\t};\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tconst scope = this;\n\n\t\tconst verticesArray = [];\n\t\tconst uvArray = [];\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\t\t\taddShape( shape );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\t\tthis.computeVertexNormals();\n\n\t\t// functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst placeholder = [];\n\n\t\t\t// options\n\n\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\n\t\t\tlet depth = options.depth !== undefined ? options.depth : 100;\n\n\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\n\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\n\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\t\tconst extrudePath = options.extrudePath;\n\n\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t\t// deprecated options\n\n\t\t\tif ( options.amount !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );\n\t\t\t\tdepth = options.amount;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet extrudePts, extrudeByPath = false;\n\t\t\tlet splineTube, binormal, normal, position2;\n\n\t\t\tif ( extrudePath ) {\n\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t\t// SETUP TNB variables\n\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\n\t\t\t}\n\n\t\t\t// Safeguards if bevels are not enabled\n\n\t\t\tif ( ! bevelEnabled ) {\n\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\t\t\tbevelOffset = 0;\n\n\t\t\t}\n\n\t\t\t// Variables initialization\n\n\t\t\tconst shapePoints = shape.extractPoints( curveSegments );\n\n\t\t\tlet vertices = shapePoints.shape;\n\t\t\tconst holes = shapePoints.holes;\n\n\t\t\tconst reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\t\tif ( reverse ) {\n\n\t\t\t\tvertices = vertices.reverse();\n\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t\t/* Vertices */\n\n\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\tvertices = vertices.concat( ahole );\n\n\t\t\t}\n\n\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t\t\t}\n\n\t\t\tconst vlen = vertices.length, flen = faces.length;\n\n\n\t\t\t// Find directions for point movement\n\n\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\tconst v_next_x = inNext.x - inPt.x,\n\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\t\tconst v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t\t// check for collinear edges\n\t\t\t\tconst collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not collinear\n\n\t\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\t\tconst v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tconst v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\t\tconst ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tconst ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\t\tconst ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tconst ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\t\tconst sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tconst v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\t\tlet direction_eq = false; // assumes: opposite\n\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t\t}\n\n\n\t\t\tconst contourMovements = [];\n\n\t\t\tfor ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t\t}\n\n\t\t\tconst holesMovements = [];\n\t\t\tlet oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\toneHoleMovements = [];\n\n\t\t\t\tfor ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t\t}\n\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t\t}\n\n\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\t\tfor ( let b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst bs = bevelSize + bevelOffset;\n\n\t\t\t// Back facing vertices\n\n\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\n\t\t\tfor ( let s = 1; s <= steps; s ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// Add bevel segments planes\n\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( let b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Faces */\n\n\t\t\t// Top and bottom faces\n\n\t\t\tbuildLidFaces();\n\n\t\t\t// Sides faces\n\n\t\t\tbuildSideFaces();\n\n\n\t\t\t/////  Internal functions\n\n\t\t\tfunction buildLidFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\n\t\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\t\tlet layer = 0; // steps + 1\n\t\t\t\t\tlet offset = vlen * layer;\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\n\n\t\t\t}\n\n\t\t\t// Create faces for the z-sides of the shape\n\n\t\t\tfunction buildSideFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\t\t\t\tlet layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t\t}\n\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\n\n\n\t\t\t}\n\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\t\tlet i = contour.length;\n\n\t\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\t\tconst j = i;\n\t\t\t\t\tlet k = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\tfor ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {\n\n\t\t\t\t\t\tconst slen1 = vlen * s;\n\t\t\t\t\t\tconst slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\t\tconst a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction v( x, y, z ) {\n\n\t\t\t\tplaceholder.push( x );\n\t\t\t\tplaceholder.push( y );\n\t\t\t\tplaceholder.push( z );\n\n\t\t\t}\n\n\n\t\t\tfunction f3( a, b, c ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\n\t\t\t}\n\n\t\t\tfunction f4( a, b, c, d ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( d );\n\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\t\t\t\taddVertex( d );\n\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t}\n\n\t\t\tfunction addVertex( index ) {\n\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t\t}\n\n\n\t\t\tfunction addUV( vector2 ) {\n\n\t\t\t\tuvArray.push( vector2.x );\n\t\t\t\tuvArray.push( vector2.y );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = BufferGeometry.prototype.toJSON.call( this );\n\n\t\tconst shapes = this.parameters.shapes;\n\t\tconst options = this.parameters.options;\n\n\t\treturn toJSON( shapes, options, data );\n\n\t}\n\n}\n\nconst WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\n\t\treturn [\n\t\t\tnew Vector2( a_x, a_y ),\n\t\t\tnew Vector2( b_x, b_y ),\n\t\t\tnew Vector2( c_x, c_y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst a_z = vertices[ indexA * 3 + 2 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst b_z = vertices[ indexB * 3 + 2 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\t\tconst c_z = vertices[ indexC * 3 + 2 ];\n\t\tconst d_x = vertices[ indexD * 3 ];\n\t\tconst d_y = vertices[ indexD * 3 + 1 ];\n\t\tconst d_z = vertices[ indexD * 3 + 2 ];\n\n\t\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t];\n\n\t\t}\n\n\t}\n\n};\n\nfunction toJSON( shapes, options, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\n\nexport { ExtrudeBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}