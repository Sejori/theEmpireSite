{"ast":null,"code":"import { Vector3 } from '../math/Vector3.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { DirectGeometry } from './DirectGeometry.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { arrayMax } from '../utils.js';\nvar _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\n\nvar _m1 = new Matrix4();\n\nvar _obj = new Object3D();\n\nvar _offset = new Vector3();\n\nvar _box = new Box3();\n\nvar _boxMorphTargets = new Box3();\n\nvar _vector = new Vector3();\n\nfunction BufferGeometry() {\n  Object.defineProperty(this, 'id', {\n    value: _bufferGeometryId += 2\n  });\n  this.uuid = MathUtils.generateUUID();\n  this.name = '';\n  this.type = 'BufferGeometry';\n  this.index = null;\n  this.attributes = {};\n  this.morphAttributes = {};\n  this.morphTargetsRelative = false;\n  this.groups = [];\n  this.boundingBox = null;\n  this.boundingSphere = null;\n  this.drawRange = {\n    start: 0,\n    count: Infinity\n  };\n  this.userData = {};\n}\n\nBufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\n  constructor: BufferGeometry,\n  isBufferGeometry: true,\n  getIndex: function getIndex() {\n    return this.index;\n  },\n  setIndex: function setIndex(index) {\n    if (Array.isArray(index)) {\n      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n    } else {\n      this.index = index;\n    }\n\n    return this;\n  },\n  getAttribute: function getAttribute(name) {\n    return this.attributes[name];\n  },\n  setAttribute: function setAttribute(name, attribute) {\n    this.attributes[name] = attribute;\n    return this;\n  },\n  deleteAttribute: function deleteAttribute(name) {\n    delete this.attributes[name];\n    return this;\n  },\n  addGroup: function addGroup(start, count, materialIndex) {\n    this.groups.push({\n      start: start,\n      count: count,\n      materialIndex: materialIndex !== undefined ? materialIndex : 0\n    });\n  },\n  clearGroups: function clearGroups() {\n    this.groups = [];\n  },\n  setDrawRange: function setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  },\n  applyMatrix4: function applyMatrix4(matrix) {\n    var position = this.attributes.position;\n\n    if (position !== undefined) {\n      position.applyMatrix4(matrix);\n      position.needsUpdate = true;\n    }\n\n    var normal = this.attributes.normal;\n\n    if (normal !== undefined) {\n      var normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      normal.applyNormalMatrix(normalMatrix);\n      normal.needsUpdate = true;\n    }\n\n    var tangent = this.attributes.tangent;\n\n    if (tangent !== undefined) {\n      tangent.transformDirection(matrix);\n      tangent.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  },\n  rotateX: function rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  rotateY: function rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  rotateZ: function rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  translate: function translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  scale: function scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  },\n  lookAt: function lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  },\n  center: function center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  },\n  setFromObject: function setFromObject(object) {\n    // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n    var geometry = object.geometry;\n\n    if (object.isPoints || object.isLine) {\n      var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n      var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n      this.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n      this.setAttribute('color', colors.copyColorsArray(geometry.colors));\n\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n        this.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n      }\n\n      if (geometry.boundingSphere !== null) {\n        this.boundingSphere = geometry.boundingSphere.clone();\n      }\n\n      if (geometry.boundingBox !== null) {\n        this.boundingBox = geometry.boundingBox.clone();\n      }\n    } else if (object.isMesh) {\n      if (geometry && geometry.isGeometry) {\n        this.fromGeometry(geometry);\n      }\n    }\n\n    return this;\n  },\n  setFromPoints: function setFromPoints(points) {\n    var position = [];\n\n    for (var i = 0, l = points.length; i < l; i++) {\n      var point = points[i];\n      position.push(point.x, point.y, point.z || 0);\n    }\n\n    this.setAttribute('position', new Float32BufferAttribute(position, 3));\n    return this;\n  },\n  updateFromObject: function updateFromObject(object) {\n    var geometry = object.geometry;\n\n    if (object.isMesh) {\n      var direct = geometry.__directGeometry;\n\n      if (geometry.elementsNeedUpdate === true) {\n        direct = undefined;\n        geometry.elementsNeedUpdate = false;\n      }\n\n      if (direct === undefined) {\n        return this.fromGeometry(geometry);\n      }\n\n      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;\n      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;\n      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;\n      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;\n      direct.groupsNeedUpdate = geometry.groupsNeedUpdate;\n      geometry.verticesNeedUpdate = false;\n      geometry.normalsNeedUpdate = false;\n      geometry.colorsNeedUpdate = false;\n      geometry.uvsNeedUpdate = false;\n      geometry.groupsNeedUpdate = false;\n      geometry = direct;\n    }\n\n    if (geometry.verticesNeedUpdate === true) {\n      var attribute = this.attributes.position;\n\n      if (attribute !== undefined) {\n        attribute.copyVector3sArray(geometry.vertices);\n        attribute.needsUpdate = true;\n      }\n\n      geometry.verticesNeedUpdate = false;\n    }\n\n    if (geometry.normalsNeedUpdate === true) {\n      var _attribute = this.attributes.normal;\n\n      if (_attribute !== undefined) {\n        _attribute.copyVector3sArray(geometry.normals);\n\n        _attribute.needsUpdate = true;\n      }\n\n      geometry.normalsNeedUpdate = false;\n    }\n\n    if (geometry.colorsNeedUpdate === true) {\n      var _attribute2 = this.attributes.color;\n\n      if (_attribute2 !== undefined) {\n        _attribute2.copyColorsArray(geometry.colors);\n\n        _attribute2.needsUpdate = true;\n      }\n\n      geometry.colorsNeedUpdate = false;\n    }\n\n    if (geometry.uvsNeedUpdate) {\n      var _attribute3 = this.attributes.uv;\n\n      if (_attribute3 !== undefined) {\n        _attribute3.copyVector2sArray(geometry.uvs);\n\n        _attribute3.needsUpdate = true;\n      }\n\n      geometry.uvsNeedUpdate = false;\n    }\n\n    if (geometry.lineDistancesNeedUpdate) {\n      var _attribute4 = this.attributes.lineDistance;\n\n      if (_attribute4 !== undefined) {\n        _attribute4.copyArray(geometry.lineDistances);\n\n        _attribute4.needsUpdate = true;\n      }\n\n      geometry.lineDistancesNeedUpdate = false;\n    }\n\n    if (geometry.groupsNeedUpdate) {\n      geometry.computeGroups(object.geometry);\n      this.groups = geometry.groups;\n      geometry.groupsNeedUpdate = false;\n    }\n\n    return this;\n  },\n  fromGeometry: function fromGeometry(geometry) {\n    geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);\n    return this.fromDirectGeometry(geometry.__directGeometry);\n  },\n  fromDirectGeometry: function fromDirectGeometry(geometry) {\n    var positions = new Float32Array(geometry.vertices.length * 3);\n    this.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n    if (geometry.normals.length > 0) {\n      var normals = new Float32Array(geometry.normals.length * 3);\n      this.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n\n    if (geometry.colors.length > 0) {\n      var colors = new Float32Array(geometry.colors.length * 3);\n      this.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n\n    if (geometry.uvs.length > 0) {\n      var uvs = new Float32Array(geometry.uvs.length * 2);\n      this.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n\n    if (geometry.uvs2.length > 0) {\n      var uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      this.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    } // groups\n\n\n    this.groups = geometry.groups; // morphs\n\n    for (var name in geometry.morphTargets) {\n      var array = [];\n      var morphTargets = geometry.morphTargets[name];\n\n      for (var i = 0, l = morphTargets.length; i < l; i++) {\n        var morphTarget = morphTargets[i];\n        var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n\n      this.morphAttributes[name] = array;\n    } // skinning\n\n\n    if (geometry.skinIndices.length > 0) {\n      var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      this.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      this.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n    } //\n\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return this;\n  },\n  computeBoundingBox: function computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    var position = this.attributes.position;\n    var morphAttributesPosition = this.morphAttributes.position;\n\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));\n      return;\n    }\n\n    if (position !== undefined) {\n      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          var morphAttribute = morphAttributesPosition[i];\n\n          _box.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(this.boundingBox.min, _box.min);\n\n            this.boundingBox.expandByPoint(_vector);\n\n            _vector.addVectors(this.boundingBox.max, _box.max);\n\n            this.boundingBox.expandByPoint(_vector);\n          } else {\n            this.boundingBox.expandByPoint(_box.min);\n            this.boundingBox.expandByPoint(_box.max);\n          }\n        }\n      }\n    } else {\n      this.boundingBox.makeEmpty();\n    }\n\n    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n    }\n  },\n  computeBoundingSphere: function computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    var position = this.attributes.position;\n    var morphAttributesPosition = this.morphAttributes.position;\n\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n      this.boundingSphere.set(new Vector3(), Infinity);\n      return;\n    }\n\n    if (position) {\n      // first, find the center of the bounding sphere\n      var center = this.boundingSphere.center;\n\n      _box.setFromBufferAttribute(position); // process morph attributes if present\n\n\n      if (morphAttributesPosition) {\n        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          var morphAttribute = morphAttributesPosition[i];\n\n          _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(_box.min, _boxMorphTargets.min);\n\n            _box.expandByPoint(_vector);\n\n            _vector.addVectors(_box.max, _boxMorphTargets.max);\n\n            _box.expandByPoint(_vector);\n          } else {\n            _box.expandByPoint(_boxMorphTargets.min);\n\n            _box.expandByPoint(_boxMorphTargets.max);\n          }\n        }\n      }\n\n      _box.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the\n      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\n      var maxRadiusSq = 0;\n\n      for (var _i = 0, _il = position.count; _i < _il; _i++) {\n        _vector.fromBufferAttribute(position, _i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      } // process morph attributes if present\n\n\n      if (morphAttributesPosition) {\n        for (var _i2 = 0, _il2 = morphAttributesPosition.length; _i2 < _il2; _i2++) {\n          var _morphAttribute = morphAttributesPosition[_i2];\n          var morphTargetsRelative = this.morphTargetsRelative;\n\n          for (var j = 0, jl = _morphAttribute.count; j < jl; j++) {\n            _vector.fromBufferAttribute(_morphAttribute, j);\n\n            if (morphTargetsRelative) {\n              _offset.fromBufferAttribute(position, j);\n\n              _vector.add(_offset);\n            }\n\n            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n          }\n        }\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n      }\n    }\n  },\n  computeFaceNormals: function computeFaceNormals() {// backwards compatibility\n  },\n  computeVertexNormals: function computeVertexNormals() {\n    var index = this.index;\n    var positionAttribute = this.getAttribute('position');\n\n    if (positionAttribute !== undefined) {\n      var normalAttribute = this.getAttribute('normal');\n\n      if (normalAttribute === undefined) {\n        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n        this.setAttribute('normal', normalAttribute);\n      } else {\n        // reset existing normals to zero\n        for (var i = 0, il = normalAttribute.count; i < il; i++) {\n          normalAttribute.setXYZ(i, 0, 0, 0);\n        }\n      }\n\n      var pA = new Vector3(),\n          pB = new Vector3(),\n          pC = new Vector3();\n      var nA = new Vector3(),\n          nB = new Vector3(),\n          nC = new Vector3();\n      var cb = new Vector3(),\n          ab = new Vector3(); // indexed elements\n\n      if (index) {\n        for (var _i3 = 0, _il3 = index.count; _i3 < _il3; _i3 += 3) {\n          var vA = index.getX(_i3 + 0);\n          var vB = index.getX(_i3 + 1);\n          var vC = index.getX(_i3 + 2);\n          pA.fromBufferAttribute(positionAttribute, vA);\n          pB.fromBufferAttribute(positionAttribute, vB);\n          pC.fromBufferAttribute(positionAttribute, vC);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          nA.fromBufferAttribute(normalAttribute, vA);\n          nB.fromBufferAttribute(normalAttribute, vB);\n          nC.fromBufferAttribute(normalAttribute, vC);\n          nA.add(cb);\n          nB.add(cb);\n          nC.add(cb);\n          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n        }\n      } else {\n        // non-indexed elements (unconnected triangle soup)\n        for (var _i4 = 0, _il4 = positionAttribute.count; _i4 < _il4; _i4 += 3) {\n          pA.fromBufferAttribute(positionAttribute, _i4 + 0);\n          pB.fromBufferAttribute(positionAttribute, _i4 + 1);\n          pC.fromBufferAttribute(positionAttribute, _i4 + 2);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          normalAttribute.setXYZ(_i4 + 0, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(_i4 + 1, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(_i4 + 2, cb.x, cb.y, cb.z);\n        }\n      }\n\n      this.normalizeNormals();\n      normalAttribute.needsUpdate = true;\n    }\n  },\n  merge: function merge(geometry, offset) {\n    if (!(geometry && geometry.isBufferGeometry)) {\n      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);\n      return;\n    }\n\n    if (offset === undefined) {\n      offset = 0;\n      console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');\n    }\n\n    var attributes = this.attributes;\n\n    for (var key in attributes) {\n      if (geometry.attributes[key] === undefined) continue;\n      var attribute1 = attributes[key];\n      var attributeArray1 = attribute1.array;\n      var attribute2 = geometry.attributes[key];\n      var attributeArray2 = attribute2.array;\n      var attributeOffset = attribute2.itemSize * offset;\n      var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);\n\n      for (var i = 0, j = attributeOffset; i < length; i++, j++) {\n        attributeArray1[j] = attributeArray2[i];\n      }\n    }\n\n    return this;\n  },\n  normalizeNormals: function normalizeNormals() {\n    var normals = this.attributes.normal;\n\n    for (var i = 0, il = normals.count; i < il; i++) {\n      _vector.fromBufferAttribute(normals, i);\n\n      _vector.normalize();\n\n      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n  },\n  toNonIndexed: function toNonIndexed() {\n    function convertBufferAttribute(attribute, indices) {\n      var array = attribute.array;\n      var itemSize = attribute.itemSize;\n      var normalized = attribute.normalized;\n      var array2 = new array.constructor(indices.length * itemSize);\n      var index = 0,\n          index2 = 0;\n\n      for (var i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n\n        for (var j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n\n      return new BufferAttribute(array2, itemSize, normalized);\n    } //\n\n\n    if (this.index === null) {\n      console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');\n      return this;\n    }\n\n    var geometry2 = new BufferGeometry();\n    var indices = this.index.array;\n    var attributes = this.attributes; // attributes\n\n    for (var name in attributes) {\n      var attribute = attributes[name];\n      var newAttribute = convertBufferAttribute(attribute, indices);\n      geometry2.setAttribute(name, newAttribute);\n    } // morph attributes\n\n\n    var morphAttributes = this.morphAttributes;\n\n    for (var _name in morphAttributes) {\n      var morphArray = [];\n      var morphAttribute = morphAttributes[_name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (var i = 0, il = morphAttribute.length; i < il; i++) {\n        var _attribute5 = morphAttribute[i];\n\n        var _newAttribute = convertBufferAttribute(_attribute5, indices);\n\n        morphArray.push(_newAttribute);\n      }\n\n      geometry2.morphAttributes[_name] = morphArray;\n    }\n\n    geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups\n\n    var groups = this.groups;\n\n    for (var _i5 = 0, l = groups.length; _i5 < l; _i5++) {\n      var group = groups[_i5];\n      geometry2.addGroup(group.start, group.count, group.materialIndex);\n    }\n\n    return geometry2;\n  },\n  toJSON: function toJSON() {\n    var data = {\n      metadata: {\n        version: 4.5,\n        type: 'BufferGeometry',\n        generator: 'BufferGeometry.toJSON'\n      }\n    }; // standard BufferGeometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n\n    if (this.parameters !== undefined) {\n      var parameters = this.parameters;\n\n      for (var key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    data.data = {\n      attributes: {}\n    };\n    var index = this.index;\n\n    if (index !== null) {\n      data.data.index = {\n        type: index.array.constructor.name,\n        array: Array.prototype.slice.call(index.array)\n      };\n    }\n\n    var attributes = this.attributes;\n\n    for (var _key in attributes) {\n      var attribute = attributes[_key];\n      var attributeData = attribute.toJSON(data.data);\n      if (attribute.name !== '') attributeData.name = attribute.name;\n      data.data.attributes[_key] = attributeData;\n    }\n\n    var morphAttributes = {};\n    var hasMorphAttributes = false;\n\n    for (var _key2 in this.morphAttributes) {\n      var attributeArray = this.morphAttributes[_key2];\n      var array = [];\n\n      for (var i = 0, il = attributeArray.length; i < il; i++) {\n        var _attribute6 = attributeArray[i];\n\n        var _attributeData = _attribute6.toJSON(data.data);\n\n        if (_attribute6.name !== '') _attributeData.name = _attribute6.name;\n        array.push(_attributeData);\n      }\n\n      if (array.length > 0) {\n        morphAttributes[_key2] = array;\n        hasMorphAttributes = true;\n      }\n    }\n\n    if (hasMorphAttributes) {\n      data.data.morphAttributes = morphAttributes;\n      data.data.morphTargetsRelative = this.morphTargetsRelative;\n    }\n\n    var groups = this.groups;\n\n    if (groups.length > 0) {\n      data.data.groups = JSON.parse(JSON.stringify(groups));\n    }\n\n    var boundingSphere = this.boundingSphere;\n\n    if (boundingSphere !== null) {\n      data.data.boundingSphere = {\n        center: boundingSphere.center.toArray(),\n        radius: boundingSphere.radius\n      };\n    }\n\n    return data;\n  },\n  clone: function clone() {\n    /*\n     // Handle primitives\n    \t const parameters = this.parameters;\n    \t if ( parameters !== undefined ) {\n    \t const values = [];\n    \t for ( const key in parameters ) {\n    \t values.push( parameters[ key ] );\n    \t }\n    \t const geometry = Object.create( this.constructor.prototype );\n     this.constructor.apply( geometry, values );\n     return geometry;\n    \t }\n    \t return new this.constructor().copy( this );\n     */\n    return new BufferGeometry().copy(this);\n  },\n  copy: function copy(source) {\n    // reset\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // used for storing cloned, shared data\n\n    var data = {}; // name\n\n    this.name = source.name; // index\n\n    var index = source.index;\n\n    if (index !== null) {\n      this.setIndex(index.clone(data));\n    } // attributes\n\n\n    var attributes = source.attributes;\n\n    for (var name in attributes) {\n      var attribute = attributes[name];\n      this.setAttribute(name, attribute.clone(data));\n    } // morph attributes\n\n\n    var morphAttributes = source.morphAttributes;\n\n    for (var _name2 in morphAttributes) {\n      var array = [];\n      var morphAttribute = morphAttributes[_name2]; // morphAttribute: array of Float32BufferAttributes\n\n      for (var i = 0, l = morphAttribute.length; i < l; i++) {\n        array.push(morphAttribute[i].clone(data));\n      }\n\n      this.morphAttributes[_name2] = array;\n    }\n\n    this.morphTargetsRelative = source.morphTargetsRelative; // groups\n\n    var groups = source.groups;\n\n    for (var _i6 = 0, _l = groups.length; _i6 < _l; _i6++) {\n      var group = groups[_i6];\n      this.addGroup(group.start, group.count, group.materialIndex);\n    } // bounding box\n\n\n    var boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    var boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // draw range\n\n\n    this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = source.drawRange.count; // user data\n\n    this.userData = source.userData;\n    return this;\n  },\n  dispose: function dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n});\nexport { BufferGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/core/BufferGeometry.js"],"names":["Vector3","Box3","EventDispatcher","BufferAttribute","Float32BufferAttribute","Uint16BufferAttribute","Uint32BufferAttribute","Sphere","DirectGeometry","Object3D","Matrix4","Matrix3","MathUtils","arrayMax","_bufferGeometryId","_m1","_obj","_offset","_box","_boxMorphTargets","_vector","BufferGeometry","Object","defineProperty","value","uuid","generateUUID","name","type","index","attributes","morphAttributes","morphTargetsRelative","groups","boundingBox","boundingSphere","drawRange","start","count","Infinity","userData","prototype","assign","create","constructor","isBufferGeometry","getIndex","setIndex","Array","isArray","getAttribute","setAttribute","attribute","deleteAttribute","addGroup","materialIndex","push","undefined","clearGroups","setDrawRange","applyMatrix4","matrix","position","needsUpdate","normal","normalMatrix","getNormalMatrix","applyNormalMatrix","tangent","transformDirection","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","center","getCenter","negate","setFromObject","object","geometry","isPoints","isLine","positions","vertices","length","colors","copyVector3sArray","copyColorsArray","lineDistances","copyArray","clone","isMesh","isGeometry","fromGeometry","setFromPoints","points","i","l","point","updateFromObject","direct","__directGeometry","elementsNeedUpdate","verticesNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","uvsNeedUpdate","groupsNeedUpdate","normals","color","uv","copyVector2sArray","uvs","lineDistancesNeedUpdate","lineDistance","computeGroups","fromDirectGeometry","Float32Array","uvs2","morphTargets","array","morphTarget","data","skinIndices","copyVector4sArray","skinWeights","morphAttributesPosition","isGLBufferAttribute","console","error","set","setFromBufferAttribute","il","morphAttribute","addVectors","min","expandByPoint","max","makeEmpty","isNaN","maxRadiusSq","fromBufferAttribute","Math","distanceToSquared","j","jl","add","radius","sqrt","computeFaceNormals","computeVertexNormals","positionAttribute","normalAttribute","setXYZ","pA","pB","pC","nA","nB","nC","cb","ab","vA","getX","vB","vC","subVectors","cross","normalizeNormals","merge","offset","warn","key","attribute1","attributeArray1","attribute2","attributeArray2","attributeOffset","itemSize","normalize","toNonIndexed","convertBufferAttribute","indices","normalized","array2","index2","geometry2","newAttribute","morphArray","group","toJSON","metadata","version","generator","keys","parameters","slice","call","attributeData","hasMorphAttributes","attributeArray","JSON","parse","stringify","toArray","copy","source","dispose","dispatchEvent"],"mappings":"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","sourcesContent":["import { Vector3 } from '../math/Vector3.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { DirectGeometry } from './DirectGeometry.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { arrayMax } from '../utils.js';\n\nlet _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\n\nconst _m1 = new Matrix4();\nconst _obj = new Object3D();\nconst _offset = new Vector3();\nconst _box = new Box3();\nconst _boxMorphTargets = new Box3();\nconst _vector = new Vector3();\n\nfunction BufferGeometry() {\n\n\tObject.defineProperty( this, 'id', { value: _bufferGeometryId += 2 } );\n\n\tthis.uuid = MathUtils.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'BufferGeometry';\n\n\tthis.index = null;\n\tthis.attributes = {};\n\n\tthis.morphAttributes = {};\n\tthis.morphTargetsRelative = false;\n\n\tthis.groups = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.drawRange = { start: 0, count: Infinity };\n\n\tthis.userData = {};\n\n}\n\nBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: BufferGeometry,\n\n\tisBufferGeometry: true,\n\n\tgetIndex: function () {\n\n\t\treturn this.index;\n\n\t},\n\n\tsetIndex: function ( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t},\n\n\tsetAttribute: function ( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t},\n\n\tdeleteAttribute: function ( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t},\n\n\taddGroup: function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t} );\n\n\t},\n\n\tclearGroups: function () {\n\n\t\tthis.groups = [];\n\n\t},\n\n\tsetDrawRange: function ( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function ( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromObject: function ( object ) {\n\n\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( object.isPoints || object.isLine ) {\n\n\t\t\tconst positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\n\t\t\tconst colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\n\n\t\t\tthis.setAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\tthis.setAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\tconst lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\tthis.setAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t} else if ( object.isMesh ) {\n\n\t\t\tif ( geometry && geometry.isGeometry ) {\n\n\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tconst position = [];\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst point = points[ i ];\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t}\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\treturn this;\n\n\t},\n\n\tupdateFromObject: function ( object ) {\n\n\t\tlet geometry = object.geometry;\n\n\t\tif ( object.isMesh ) {\n\n\t\t\tlet direct = geometry.__directGeometry;\n\n\t\t\tif ( geometry.elementsNeedUpdate === true ) {\n\n\t\t\t\tdirect = undefined;\n\t\t\t\tgeometry.elementsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( direct === undefined ) {\n\n\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\tgeometry = direct;\n\n\t\t}\n\n\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\tconst attribute = this.attributes.position;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\tconst attribute = this.attributes.normal;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\tconst attribute = this.attributes.color;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\tconst attribute = this.attributes.uv;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\tconst attribute = this.attributes.lineDistance;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t},\n\n\tfromDirectGeometry: function ( geometry ) {\n\n\t\tconst positions = new Float32Array( geometry.vertices.length * 3 );\n\t\tthis.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\tconst normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\tthis.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t}\n\n\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\tconst colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\tthis.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\tconst uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\tthis.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\tconst uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\tthis.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t}\n\n\t\t// groups\n\n\t\tthis.groups = geometry.groups;\n\n\t\t// morphs\n\n\t\tfor ( const name in geometry.morphTargets ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphTargets = geometry.morphTargets[ name ];\n\n\t\t\tfor ( let i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tconst morphTarget = morphTargets[ i ];\n\n\t\t\t\tconst attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\n\t\t\t\tattribute.name = morphTarget.name;\n\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget.data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// skinning\n\n\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\tconst skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\n\t\t\tthis.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t}\n\n\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\tconst skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\n\t\t\tthis.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\t// backwards compatibility\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t},\n\n\tmerge: function ( geometry, offset ) {\n\n\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) {\n\n\t\t\toffset = 0;\n\n\t\t\tconsole.warn(\n\t\t\t\t'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\n\t\t\t\t+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'\n\t\t\t);\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tconst attribute1 = attributes[ key ];\n\t\t\tconst attributeArray1 = attribute1.array;\n\n\t\t\tconst attribute2 = geometry.attributes[ key ];\n\t\t\tconst attributeArray2 = attribute2.array;\n\n\t\t\tconst attributeOffset = attribute2.itemSize * offset;\n\t\t\tconst length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );\n\n\t\t\tfor ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( normals, i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t},\n\n\ttoNonIndexed: function () {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tconst attributeData = attribute.toJSON( data.data );\n\n\t\t\tif ( attribute.name !== '' ) attributeData.name = attribute.name;\n\n\t\t\tdata.data.attributes[ key ] = attributeData;\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tconst attributeData = attribute.toJSON( data.data );\n\n\t\t\t\tif ( attribute.name !== '' ) attributeData.name = attribute.name;\n\n\t\t\t\tarray.push( attributeData );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t const parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t const values = [];\n\n\t\t for ( const key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new BufferGeometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone( data ) );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n\nexport { BufferGeometry };\n"]},"metadata":{},"sourceType":"module"}