{"ast":null,"code":"import { AnimationUtils } from './AnimationUtils.js';\nimport { KeyframeTrack } from './KeyframeTrack.js';\nimport { BooleanKeyframeTrack } from './tracks/BooleanKeyframeTrack.js';\nimport { ColorKeyframeTrack } from './tracks/ColorKeyframeTrack.js';\nimport { NumberKeyframeTrack } from './tracks/NumberKeyframeTrack.js';\nimport { QuaternionKeyframeTrack } from './tracks/QuaternionKeyframeTrack.js';\nimport { StringKeyframeTrack } from './tracks/StringKeyframeTrack.js';\nimport { VectorKeyframeTrack } from './tracks/VectorKeyframeTrack.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\nfunction AnimationClip(name, duration, tracks, blendMode) {\n  this.name = name;\n  this.tracks = tracks;\n  this.duration = duration !== undefined ? duration : -1;\n  this.blendMode = blendMode !== undefined ? blendMode : NormalAnimationBlendMode;\n  this.uuid = MathUtils.generateUUID(); // this means it should figure out its duration by scanning the tracks\n\n  if (this.duration < 0) {\n    this.resetDuration();\n  }\n}\n\nfunction getTrackTypeForValueTypeName(typeName) {\n  switch (typeName.toLowerCase()) {\n    case 'scalar':\n    case 'double':\n    case 'float':\n    case 'number':\n    case 'integer':\n      return NumberKeyframeTrack;\n\n    case 'vector':\n    case 'vector2':\n    case 'vector3':\n    case 'vector4':\n      return VectorKeyframeTrack;\n\n    case 'color':\n      return ColorKeyframeTrack;\n\n    case 'quaternion':\n      return QuaternionKeyframeTrack;\n\n    case 'bool':\n    case 'boolean':\n      return BooleanKeyframeTrack;\n\n    case 'string':\n      return StringKeyframeTrack;\n  }\n\n  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);\n}\n\nfunction parseKeyframeTrack(json) {\n  if (json.type === undefined) {\n    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');\n  }\n\n  var trackType = getTrackTypeForValueTypeName(json.type);\n\n  if (json.times === undefined) {\n    var times = [],\n        values = [];\n    AnimationUtils.flattenJSON(json.keys, times, values, 'value');\n    json.times = times;\n    json.values = values;\n  } // derived classes can define a static parse method\n\n\n  if (trackType.parse !== undefined) {\n    return trackType.parse(json);\n  } else {\n    // by default, we assume a constructor compatible with the base\n    return new trackType(json.name, json.times, json.values, json.interpolation);\n  }\n}\n\nObject.assign(AnimationClip, {\n  parse: function parse(json) {\n    var tracks = [],\n        jsonTracks = json.tracks,\n        frameTime = 1.0 / (json.fps || 1.0);\n\n    for (var i = 0, n = jsonTracks.length; i !== n; ++i) {\n      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));\n    }\n\n    return new AnimationClip(json.name, json.duration, tracks, json.blendMode);\n  },\n  toJSON: function toJSON(clip) {\n    var tracks = [],\n        clipTracks = clip.tracks;\n    var json = {\n      'name': clip.name,\n      'duration': clip.duration,\n      'tracks': tracks,\n      'uuid': clip.uuid,\n      'blendMode': clip.blendMode\n    };\n\n    for (var i = 0, n = clipTracks.length; i !== n; ++i) {\n      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));\n    }\n\n    return json;\n  },\n  CreateFromMorphTargetSequence: function CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {\n    var numMorphTargets = morphTargetSequence.length;\n    var tracks = [];\n\n    for (var i = 0; i < numMorphTargets; i++) {\n      var times = [];\n      var values = [];\n      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);\n      values.push(0, 1, 0);\n      var order = AnimationUtils.getKeyframeOrder(times);\n      times = AnimationUtils.sortedArray(times, 1, order);\n      values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the\n      // last frame as well for perfect loop.\n\n      if (!noLoop && times[0] === 0) {\n        times.push(numMorphTargets);\n        values.push(values[0]);\n      }\n\n      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));\n    }\n\n    return new AnimationClip(name, -1, tracks);\n  },\n  findByName: function findByName(objectOrClipArray, name) {\n    var clipArray = objectOrClipArray;\n\n    if (!Array.isArray(objectOrClipArray)) {\n      var o = objectOrClipArray;\n      clipArray = o.geometry && o.geometry.animations || o.animations;\n    }\n\n    for (var i = 0; i < clipArray.length; i++) {\n      if (clipArray[i].name === name) {\n        return clipArray[i];\n      }\n    }\n\n    return null;\n  },\n  CreateClipsFromMorphTargetSequences: function CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {\n    var animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences\n    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\n    var pattern = /^([\\w-]*?)([\\d]+)$/; // sort morph target names into animation groups based\n    // patterns like Walk_001, Walk_002, Run_001, Run_002\n\n    for (var i = 0, il = morphTargets.length; i < il; i++) {\n      var morphTarget = morphTargets[i];\n      var parts = morphTarget.name.match(pattern);\n\n      if (parts && parts.length > 1) {\n        var name = parts[1];\n        var animationMorphTargets = animationToMorphTargets[name];\n\n        if (!animationMorphTargets) {\n          animationToMorphTargets[name] = animationMorphTargets = [];\n        }\n\n        animationMorphTargets.push(morphTarget);\n      }\n    }\n\n    var clips = [];\n\n    for (var _name in animationToMorphTargets) {\n      clips.push(AnimationClip.CreateFromMorphTargetSequence(_name, animationToMorphTargets[_name], fps, noLoop));\n    }\n\n    return clips;\n  },\n  // parse the animation.hierarchy format\n  parseAnimation: function parseAnimation(animation, bones) {\n    if (!animation) {\n      console.error('THREE.AnimationClip: No animation in JSONLoader data.');\n      return null;\n    }\n\n    var addNonemptyTrack = function addNonemptyTrack(trackType, trackName, animationKeys, propertyName, destTracks) {\n      // only return track if there are actually keys.\n      if (animationKeys.length !== 0) {\n        var times = [];\n        var values = [];\n        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again\n\n        if (times.length !== 0) {\n          destTracks.push(new trackType(trackName, times, values));\n        }\n      }\n    };\n\n    var tracks = [];\n    var clipName = animation.name || 'default';\n    var fps = animation.fps || 30;\n    var blendMode = animation.blendMode; // automatic length determination in AnimationClip.\n\n    var duration = animation.length || -1;\n    var hierarchyTracks = animation.hierarchy || [];\n\n    for (var h = 0; h < hierarchyTracks.length; h++) {\n      var animationKeys = hierarchyTracks[h].keys; // skip empty tracks\n\n      if (!animationKeys || animationKeys.length === 0) continue; // process morph targets\n\n      if (animationKeys[0].morphTargets) {\n        // figure out all morph targets used in this track\n        var morphTargetNames = {};\n        var k = void 0;\n\n        for (k = 0; k < animationKeys.length; k++) {\n          if (animationKeys[k].morphTargets) {\n            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {\n              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;\n            }\n          }\n        } // create a track for each morph target with all zero\n        // morphTargetInfluences except for the keys in which\n        // the morphTarget is named.\n\n\n        for (var morphTargetName in morphTargetNames) {\n          var times = [];\n          var values = [];\n\n          for (var _m = 0; _m !== animationKeys[k].morphTargets.length; ++_m) {\n            var animationKey = animationKeys[k];\n            times.push(animationKey.time);\n            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);\n          }\n\n          tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));\n        }\n\n        duration = morphTargetNames.length * (fps || 1.0);\n      } else {\n        // ...assume skeletal animation\n        var boneName = '.bones[' + bones[h].name + ']';\n        addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);\n        addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);\n        addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);\n      }\n    }\n\n    if (tracks.length === 0) {\n      return null;\n    }\n\n    var clip = new AnimationClip(clipName, duration, tracks, blendMode);\n    return clip;\n  }\n});\nObject.assign(AnimationClip.prototype, {\n  resetDuration: function resetDuration() {\n    var tracks = this.tracks;\n    var duration = 0;\n\n    for (var i = 0, n = tracks.length; i !== n; ++i) {\n      var track = this.tracks[i];\n      duration = Math.max(duration, track.times[track.times.length - 1]);\n    }\n\n    this.duration = duration;\n    return this;\n  },\n  trim: function trim() {\n    for (var i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].trim(0, this.duration);\n    }\n\n    return this;\n  },\n  validate: function validate() {\n    var valid = true;\n\n    for (var i = 0; i < this.tracks.length; i++) {\n      valid = valid && this.tracks[i].validate();\n    }\n\n    return valid;\n  },\n  optimize: function optimize() {\n    for (var i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].optimize();\n    }\n\n    return this;\n  },\n  clone: function clone() {\n    var tracks = [];\n\n    for (var i = 0; i < this.tracks.length; i++) {\n      tracks.push(this.tracks[i].clone());\n    }\n\n    return new AnimationClip(this.name, this.duration, tracks, this.blendMode);\n  }\n});\nexport { AnimationClip };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/animation/AnimationClip.js"],"names":["AnimationUtils","KeyframeTrack","BooleanKeyframeTrack","ColorKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","StringKeyframeTrack","VectorKeyframeTrack","MathUtils","NormalAnimationBlendMode","AnimationClip","name","duration","tracks","blendMode","undefined","uuid","generateUUID","resetDuration","getTrackTypeForValueTypeName","typeName","toLowerCase","Error","parseKeyframeTrack","json","type","trackType","times","values","flattenJSON","keys","parse","interpolation","Object","assign","jsonTracks","frameTime","fps","i","n","length","push","scale","toJSON","clip","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","order","getKeyframeOrder","sortedArray","findByName","objectOrClipArray","clipArray","Array","isArray","o","geometry","animations","CreateClipsFromMorphTargetSequences","morphTargets","animationToMorphTargets","pattern","il","morphTarget","parts","match","animationMorphTargets","clips","parseAnimation","animation","bones","console","error","addNonemptyTrack","trackName","animationKeys","propertyName","destTracks","clipName","hierarchyTracks","hierarchy","h","morphTargetNames","k","m","morphTargetName","animationKey","time","boneName","prototype","track","Math","max","trim","validate","valid","optimize","clone"],"mappings":"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","sourcesContent":["import { AnimationUtils } from './AnimationUtils.js';\nimport { KeyframeTrack } from './KeyframeTrack.js';\nimport { BooleanKeyframeTrack } from './tracks/BooleanKeyframeTrack.js';\nimport { ColorKeyframeTrack } from './tracks/ColorKeyframeTrack.js';\nimport { NumberKeyframeTrack } from './tracks/NumberKeyframeTrack.js';\nimport { QuaternionKeyframeTrack } from './tracks/QuaternionKeyframeTrack.js';\nimport { StringKeyframeTrack } from './tracks/StringKeyframeTrack.js';\nimport { VectorKeyframeTrack } from './tracks/VectorKeyframeTrack.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\nfunction AnimationClip( name, duration, tracks, blendMode ) {\n\n\tthis.name = name;\n\tthis.tracks = tracks;\n\tthis.duration = ( duration !== undefined ) ? duration : - 1;\n\tthis.blendMode = ( blendMode !== undefined ) ? blendMode : NormalAnimationBlendMode;\n\n\tthis.uuid = MathUtils.generateUUID();\n\n\t// this means it should figure out its duration by scanning the tracks\n\tif ( this.duration < 0 ) {\n\n\t\tthis.resetDuration();\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tconst trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tconst times = [], values = [];\n\n\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nObject.assign( AnimationClip, {\n\n\tparse: function ( json ) {\n\n\t\tconst tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\treturn new AnimationClip( json.name, json.duration, tracks, json.blendMode );\n\n\t},\n\n\ttoJSON: function ( clip ) {\n\n\t\tconst tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tconst json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid,\n\t\t\t'blendMode': clip.blendMode\n\n\t\t};\n\n\t\tfor ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t},\n\n\tCreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tlet times = [];\n\t\t\tlet values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tconst order = AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new AnimationClip( name, - 1, tracks );\n\n\t},\n\n\tfindByName: function ( objectOrClipArray, name ) {\n\n\t\tlet clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tconst o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\tCreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {\n\n\t\tconst animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tconst name = parts[ 1 ];\n\n\t\t\t\tlet animationMorphTargets = animationToMorphTargets[ name ];\n\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst clips = [];\n\n\t\tfor ( const name in animationToMorphTargets ) {\n\n\t\t\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t},\n\n\t// parse the animation.hierarchy format\n\tparseAnimation: function ( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst tracks = [];\n\n\t\tconst clipName = animation.name || 'default';\n\t\tconst fps = animation.fps || 30;\n\t\tconst blendMode = animation.blendMode;\n\n\t\t// automatic length determination in AnimationClip.\n\t\tlet duration = animation.length || - 1;\n\n\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( let h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tconst animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tconst morphTargetNames = {};\n\n\t\t\t\tlet k;\n\n\t\t\t\tfor ( k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( const morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\n\t\t\t\t\tfor ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tconst animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tconst boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst clip = new AnimationClip( clipName, duration, tracks, blendMode );\n\n\t\treturn clip;\n\n\t}\n\n} );\n\nObject.assign( AnimationClip.prototype, {\n\n\tresetDuration: function () {\n\n\t\tconst tracks = this.tracks;\n\t\tlet duration = 0;\n\n\t\tfor ( let i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tconst track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t},\n\n\ttrim: function () {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tvalidate: function () {\n\n\t\tlet valid = true;\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\toptimize: function () {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new AnimationClip( this.name, this.duration, tracks, this.blendMode );\n\n\t}\n\n} );\n\n\nexport { AnimationClip };\n"]},"metadata":{},"sourceType":"module"}