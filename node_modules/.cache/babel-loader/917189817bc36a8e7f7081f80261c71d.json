{"ast":null,"code":"function numericalSort(a, b) {\n  return a[0] - b[0];\n}\n\nfunction absNumericalSort(a, b) {\n  return Math.abs(b[1]) - Math.abs(a[1]);\n}\n\nfunction WebGLMorphtargets(gl) {\n  var influencesList = {};\n  var morphInfluences = new Float32Array(8);\n  var workInfluences = [];\n\n  for (var i = 0; i < 8; i++) {\n    workInfluences[i] = [i, 0];\n  }\n\n  function update(object, geometry, material, program) {\n    var objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array\n    // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n\n    var length = objectInfluences === undefined ? 0 : objectInfluences.length;\n    var influences = influencesList[geometry.id];\n\n    if (influences === undefined) {\n      // initialise list\n      influences = [];\n\n      for (var _i = 0; _i < length; _i++) {\n        influences[_i] = [_i, 0];\n      }\n\n      influencesList[geometry.id] = influences;\n    } // Collect influences\n\n\n    for (var _i2 = 0; _i2 < length; _i2++) {\n      var influence = influences[_i2];\n      influence[0] = _i2;\n      influence[1] = objectInfluences[_i2];\n    }\n\n    influences.sort(absNumericalSort);\n\n    for (var _i3 = 0; _i3 < 8; _i3++) {\n      if (_i3 < length && influences[_i3][1]) {\n        workInfluences[_i3][0] = influences[_i3][0];\n        workInfluences[_i3][1] = influences[_i3][1];\n      } else {\n        workInfluences[_i3][0] = Number.MAX_SAFE_INTEGER;\n        workInfluences[_i3][1] = 0;\n      }\n    }\n\n    workInfluences.sort(numericalSort);\n    var morphTargets = material.morphTargets && geometry.morphAttributes.position;\n    var morphNormals = material.morphNormals && geometry.morphAttributes.normal;\n    var morphInfluencesSum = 0;\n\n    for (var _i4 = 0; _i4 < 8; _i4++) {\n      var _influence = workInfluences[_i4];\n      var index = _influence[0];\n      var value = _influence[1];\n\n      if (index !== Number.MAX_SAFE_INTEGER && value) {\n        if (morphTargets && geometry.getAttribute('morphTarget' + _i4) !== morphTargets[index]) {\n          geometry.setAttribute('morphTarget' + _i4, morphTargets[index]);\n        }\n\n        if (morphNormals && geometry.getAttribute('morphNormal' + _i4) !== morphNormals[index]) {\n          geometry.setAttribute('morphNormal' + _i4, morphNormals[index]);\n        }\n\n        morphInfluences[_i4] = value;\n        morphInfluencesSum += value;\n      } else {\n        if (morphTargets && geometry.getAttribute('morphTarget' + _i4) !== undefined) {\n          geometry.deleteAttribute('morphTarget' + _i4);\n        }\n\n        if (morphNormals && geometry.getAttribute('morphNormal' + _i4) !== undefined) {\n          geometry.deleteAttribute('morphNormal' + _i4);\n        }\n\n        morphInfluences[_i4] = 0;\n      }\n    } // GLSL shader uses formula baseinfluence * base + sum(target * influence)\n    // This allows us to switch between absolute morphs and relative morphs without changing shader code\n    // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\n\n    var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n    program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n    program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);\n  }\n\n  return {\n    update: update\n  };\n}\n\nexport { WebGLMorphtargets };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/renderers/webgl/WebGLMorphtargets.js"],"names":["numericalSort","a","b","absNumericalSort","Math","abs","WebGLMorphtargets","gl","influencesList","morphInfluences","Float32Array","workInfluences","i","update","object","geometry","material","program","objectInfluences","morphTargetInfluences","length","undefined","influences","id","influence","sort","Number","MAX_SAFE_INTEGER","morphTargets","morphAttributes","position","morphNormals","normal","morphInfluencesSum","index","value","getAttribute","setAttribute","deleteAttribute","morphBaseInfluence","morphTargetsRelative","getUniforms","setValue"],"mappings":"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","sourcesContent":["function numericalSort( a, b ) {\n\n\treturn a[ 0 ] - b[ 0 ];\n\n}\n\nfunction absNumericalSort( a, b ) {\n\n\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\n\n}\n\nfunction WebGLMorphtargets( gl ) {\n\n\tconst influencesList = {};\n\tconst morphInfluences = new Float32Array( 8 );\n\n\tconst workInfluences = [];\n\n\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\tworkInfluences[ i ] = [ i, 0 ];\n\n\t}\n\n\tfunction update( object, geometry, material, program ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\t// When object doesn't have morph target influences defined, we treat it as a 0-length array\n\t\t// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n\n\t\tconst length = objectInfluences === undefined ? 0 : objectInfluences.length;\n\n\t\tlet influences = influencesList[ geometry.id ];\n\n\t\tif ( influences === undefined ) {\n\n\t\t\t// initialise list\n\n\t\t\tinfluences = [];\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tinfluences[ i ] = [ i, 0 ];\n\n\t\t\t}\n\n\t\t\tinfluencesList[ geometry.id ] = influences;\n\n\t\t}\n\n\t\t// Collect influences\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst influence = influences[ i ];\n\n\t\t\tinfluence[ 0 ] = i;\n\t\t\tinfluence[ 1 ] = objectInfluences[ i ];\n\n\t\t}\n\n\t\tinfluences.sort( absNumericalSort );\n\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tif ( i < length && influences[ i ][ 1 ] ) {\n\n\t\t\t\tworkInfluences[ i ][ 0 ] = influences[ i ][ 0 ];\n\t\t\t\tworkInfluences[ i ][ 1 ] = influences[ i ][ 1 ];\n\n\t\t\t} else {\n\n\t\t\t\tworkInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;\n\t\t\t\tworkInfluences[ i ][ 1 ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tworkInfluences.sort( numericalSort );\n\n\t\tconst morphTargets = material.morphTargets && geometry.morphAttributes.position;\n\t\tconst morphNormals = material.morphNormals && geometry.morphAttributes.normal;\n\n\t\tlet morphInfluencesSum = 0;\n\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst influence = workInfluences[ i ];\n\t\t\tconst index = influence[ 0 ];\n\t\t\tconst value = influence[ 1 ];\n\n\t\t\tif ( index !== Number.MAX_SAFE_INTEGER && value ) {\n\n\t\t\t\tif ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );\n\n\t\t\t\t}\n\n\t\t\t\tmorphInfluences[ i ] = value;\n\t\t\t\tmorphInfluencesSum += value;\n\n\t\t\t} else {\n\n\t\t\t\tif ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== undefined ) {\n\n\t\t\t\t\tgeometry.deleteAttribute( 'morphTarget' + i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== undefined ) {\n\n\t\t\t\t\tgeometry.deleteAttribute( 'morphNormal' + i );\n\n\t\t\t\t}\n\n\t\t\t\tmorphInfluences[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// GLSL shader uses formula baseinfluence * base + sum(target * influence)\n\t\t// This allows us to switch between absolute morphs and relative morphs without changing shader code\n\t\t// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );\n\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update\n\n\t};\n\n}\n\n\nexport { WebGLMorphtargets };\n"]},"metadata":{},"sourceType":"module"}