{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass WireframeGeometry extends BufferGeometry {\n  constructor(geometry) {\n    super();\n    this.type = 'WireframeGeometry'; // buffer\n\n    var vertices = []; // helper variables\n\n    var edge = [0, 0],\n        edges = {};\n    var keys = ['a', 'b', 'c']; // different logic for Geometry and BufferGeometry\n\n    if (geometry && geometry.isGeometry) {\n      // create a data structure that contains all edges without duplicates\n      var faces = geometry.faces;\n\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i];\n\n        for (var j = 0; j < 3; j++) {\n          var edge1 = face[keys[j]];\n          var edge2 = face[keys[(j + 1) % 3]];\n          edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates\n\n          edge[1] = Math.max(edge1, edge2);\n          var key = edge[0] + ',' + edge[1];\n\n          if (edges[key] === undefined) {\n            edges[key] = {\n              index1: edge[0],\n              index2: edge[1]\n            };\n          }\n        }\n      } // generate vertices\n\n\n      for (var _key in edges) {\n        var e = edges[_key];\n        var vertex = geometry.vertices[e.index1];\n        vertices.push(vertex.x, vertex.y, vertex.z);\n        vertex = geometry.vertices[e.index2];\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n    } else if (geometry && geometry.isBufferGeometry) {\n      var _vertex = new Vector3();\n\n      if (geometry.index !== null) {\n        // indexed BufferGeometry\n        var position = geometry.attributes.position;\n        var indices = geometry.index;\n        var groups = geometry.groups;\n\n        if (groups.length === 0) {\n          groups = [{\n            start: 0,\n            count: indices.count,\n            materialIndex: 0\n          }];\n        } // create a data structure that contains all eges without duplicates\n\n\n        for (var o = 0, ol = groups.length; o < ol; ++o) {\n          var group = groups[o];\n          var start = group.start;\n          var count = group.count;\n\n          for (var _i = start, _l = start + count; _i < _l; _i += 3) {\n            for (var _j = 0; _j < 3; _j++) {\n              var _edge = indices.getX(_i + _j);\n\n              var _edge2 = indices.getX(_i + (_j + 1) % 3);\n\n              edge[0] = Math.min(_edge, _edge2); // sorting prevents duplicates\n\n              edge[1] = Math.max(_edge, _edge2);\n\n              var _key2 = edge[0] + ',' + edge[1];\n\n              if (edges[_key2] === undefined) {\n                edges[_key2] = {\n                  index1: edge[0],\n                  index2: edge[1]\n                };\n              }\n            }\n          }\n        } // generate vertices\n\n\n        for (var _key3 in edges) {\n          var _e = edges[_key3];\n\n          _vertex.fromBufferAttribute(position, _e.index1);\n\n          vertices.push(_vertex.x, _vertex.y, _vertex.z);\n\n          _vertex.fromBufferAttribute(position, _e.index2);\n\n          vertices.push(_vertex.x, _vertex.y, _vertex.z);\n        }\n      } else {\n        // non-indexed BufferGeometry\n        var _position = geometry.attributes.position;\n\n        for (var _i2 = 0, _l2 = _position.count / 3; _i2 < _l2; _i2++) {\n          for (var _j2 = 0; _j2 < 3; _j2++) {\n            // three edges per triangle, an edge is represented as (index1, index2)\n            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n            var index1 = 3 * _i2 + _j2;\n\n            _vertex.fromBufferAttribute(_position, index1);\n\n            vertices.push(_vertex.x, _vertex.y, _vertex.z);\n            var index2 = 3 * _i2 + (_j2 + 1) % 3;\n\n            _vertex.fromBufferAttribute(_position, index2);\n\n            vertices.push(_vertex.x, _vertex.y, _vertex.z);\n          }\n        }\n      }\n    } // build geometry\n\n\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n  }\n\n}\n\nexport { WireframeGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/WireframeGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","WireframeGeometry","constructor","geometry","type","vertices","edge","edges","keys","isGeometry","faces","i","l","length","face","j","edge1","edge2","Math","min","max","key","undefined","index1","index2","e","vertex","push","x","y","z","isBufferGeometry","index","position","attributes","indices","groups","start","count","materialIndex","o","ol","group","getX","fromBufferAttribute","setAttribute"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass WireframeGeometry extends BufferGeometry {\n\n\tconstructor( geometry ) {\n\n\t\tsuper();\n\t\tthis.type = 'WireframeGeometry';\n\n\t\t// buffer\n\n\t\tconst vertices = [];\n\n\t\t// helper variables\n\n\t\tconst edge = [ 0, 0 ], edges = {};\n\t\tconst keys = [ 'a', 'b', 'c' ];\n\n\t\t// different logic for Geometry and BufferGeometry\n\n\t\tif ( geometry && geometry.isGeometry ) {\n\n\t\t\t// create a data structure that contains all edges without duplicates\n\n\t\t\tconst faces = geometry.faces;\n\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tconst edge1 = face[ keys[ j ] ];\n\t\t\t\t\tconst edge2 = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\n\t\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\t\t\tconst key = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// generate vertices\n\n\t\t\tfor ( const key in edges ) {\n\n\t\t\t\tconst e = edges[ key ];\n\n\t\t\t\tlet vertex = geometry.vertices[ e.index1 ];\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\tvertex = geometry.vertices[ e.index2 ];\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t} else if ( geometry && geometry.isBufferGeometry ) {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst indices = geometry.index;\n\t\t\t\tlet groups = geometry.groups;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n\t\t\t\t}\n\n\t\t\t\t// create a data structure that contains all eges without duplicates\n\n\t\t\t\tfor ( let o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\t\tconst group = groups[ o ];\n\n\t\t\t\t\tconst start = group.start;\n\t\t\t\t\tconst count = group.count;\n\n\t\t\t\t\tfor ( let i = start, l = ( start + count ); i < l; i += 3 ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tconst edge1 = indices.getX( i + j );\n\t\t\t\t\t\t\tconst edge2 = indices.getX( i + ( j + 1 ) % 3 );\n\t\t\t\t\t\t\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\n\t\t\t\t\t\t\tedge[ 1 ] = Math.max( edge1, edge2 );\n\n\t\t\t\t\t\t\tconst key = edge[ 0 ] + ',' + edge[ 1 ];\n\n\t\t\t\t\t\t\tif ( edges[ key ] === undefined ) {\n\n\t\t\t\t\t\t\t\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// generate vertices\n\n\t\t\t\tfor ( const key in edges ) {\n\n\t\t\t\t\tconst e = edges[ key ];\n\n\t\t\t\t\tvertex.fromBufferAttribute( position, e.index1 );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\tvertex.fromBufferAttribute( position, e.index2 );\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\n\t\t\t\tfor ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n\t\t\t\t\t\tconst index1 = 3 * i + j;\n\t\t\t\t\t\tvertex.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t\tconst index2 = 3 * i + ( ( j + 1 ) % 3 );\n\t\t\t\t\t\tvertex.fromBufferAttribute( position, index2 );\n\t\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t}\n\n}\n\n\nexport { WireframeGeometry };\n"]},"metadata":{},"sourceType":"module"}