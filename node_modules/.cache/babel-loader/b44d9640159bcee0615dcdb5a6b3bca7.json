{"ast":null,"code":"import { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { MathUtils } from '../math/MathUtils.js';\n\nclass LatheBufferGeometry extends BufferGeometry {\n  constructor(points, segments, phiStart, phiLength) {\n    super();\n    this.type = 'LatheBufferGeometry';\n    this.parameters = {\n      points: points,\n      segments: segments,\n      phiStart: phiStart,\n      phiLength: phiLength\n    };\n    segments = Math.floor(segments) || 12;\n    phiStart = phiStart || 0;\n    phiLength = phiLength || Math.PI * 2; // clamp phiLength so it's in range of [ 0, 2PI ]\n\n    phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2); // buffers\n\n    var indices = [];\n    var vertices = [];\n    var uvs = []; // helper variables\n\n    var inverseSegments = 1.0 / segments;\n    var vertex = new Vector3();\n    var uv = new Vector2(); // generate vertices and uvs\n\n    for (var i = 0; i <= segments; i++) {\n      var phi = phiStart + i * inverseSegments * phiLength;\n      var sin = Math.sin(phi);\n      var cos = Math.cos(phi);\n\n      for (var j = 0; j <= points.length - 1; j++) {\n        // vertex\n        vertex.x = points[j].x * sin;\n        vertex.y = points[j].y;\n        vertex.z = points[j].x * cos;\n        vertices.push(vertex.x, vertex.y, vertex.z); // uv\n\n        uv.x = i / segments;\n        uv.y = j / (points.length - 1);\n        uvs.push(uv.x, uv.y);\n      }\n    } // indices\n\n\n    for (var _i = 0; _i < segments; _i++) {\n      for (var _j = 0; _j < points.length - 1; _j++) {\n        var base = _j + _i * points.length;\n        var a = base;\n        var b = base + points.length;\n        var c = base + points.length + 1;\n        var d = base + 1; // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals\n\n    this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.\n    // because the corresponding vertices are identical (but still have different UVs).\n\n    if (phiLength === Math.PI * 2) {\n      var normals = this.attributes.normal.array;\n      var n1 = new Vector3();\n      var n2 = new Vector3();\n      var n = new Vector3(); // this is the buffer offset for the last line of vertices\n\n      var _base = segments * points.length * 3;\n\n      for (var _i2 = 0, _j2 = 0; _i2 < points.length; _i2++, _j2 += 3) {\n        // select the normal of the vertex in the first line\n        n1.x = normals[_j2 + 0];\n        n1.y = normals[_j2 + 1];\n        n1.z = normals[_j2 + 2]; // select the normal of the vertex in the last line\n\n        n2.x = normals[_base + _j2 + 0];\n        n2.y = normals[_base + _j2 + 1];\n        n2.z = normals[_base + _j2 + 2]; // average normals\n\n        n.addVectors(n1, n2).normalize(); // assign the new values to both normals\n\n        normals[_j2 + 0] = normals[_base + _j2 + 0] = n.x;\n        normals[_j2 + 1] = normals[_base + _j2 + 1] = n.y;\n        normals[_j2 + 2] = normals[_base + _j2 + 2] = n.z;\n      }\n    }\n  }\n\n}\n\nexport { LatheBufferGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/LatheBufferGeometry.js"],"names":["Float32BufferAttribute","BufferGeometry","Vector3","Vector2","MathUtils","LatheBufferGeometry","constructor","points","segments","phiStart","phiLength","type","parameters","Math","floor","PI","clamp","indices","vertices","uvs","inverseSegments","vertex","uv","i","phi","sin","cos","j","length","x","y","z","push","base","a","b","c","d","setIndex","setAttribute","computeVertexNormals","normals","attributes","normal","array","n1","n2","n","addVectors","normalize"],"mappings":"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","sourcesContent":["import { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { MathUtils } from '../math/MathUtils.js';\n\nclass LatheBufferGeometry extends BufferGeometry {\n\n\tconstructor( points, segments, phiStart, phiLength ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LatheBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments ) || 12;\n\t\tphiStart = phiStart || 0;\n\t\tphiLength = phiLength || Math.PI * 2;\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\tphiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );\n\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst inverseSegments = 1.0 / segments;\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// generate vertices and uvs\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tconst sin = Math.sin( phi );\n\t\t\tconst cos = Math.cos( phi );\n\n\t\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tconst base = j + i * points.length;\n\n\t\t\t\tconst a = base;\n\t\t\t\tconst b = base + points.length;\n\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\tconst d = base + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// generate normals\n\n\t\tthis.computeVertexNormals();\n\n\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t// because the corresponding vertices are identical (but still have different UVs).\n\n\t\tif ( phiLength === Math.PI * 2 ) {\n\n\t\t\tconst normals = this.attributes.normal.array;\n\t\t\tconst n1 = new Vector3();\n\t\t\tconst n2 = new Vector3();\n\t\t\tconst n = new Vector3();\n\n\t\t\t// this is the buffer offset for the last line of vertices\n\n\t\t\tconst base = segments * points.length * 3;\n\n\t\t\tfor ( let i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t\t// select the normal of the vertex in the first line\n\n\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t\t// select the normal of the vertex in the last line\n\n\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t\t// average normals\n\n\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t\t// assign the new values to both normals\n\n\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n\nexport { LatheBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}