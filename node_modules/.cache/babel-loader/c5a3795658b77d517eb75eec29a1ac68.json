{"ast":null,"code":"import { Matrix3 } from '../../math/Matrix3.js';\nimport { Plane } from '../../math/Plane.js';\n\nfunction WebGLClipping(properties) {\n  var scope = this;\n  var globalState = null,\n      numGlobalPlanes = 0,\n      localClippingEnabled = false,\n      renderingShadows = false;\n  var plane = new Plane(),\n      viewNormalMatrix = new Matrix3(),\n      uniform = {\n    value: null,\n    needsUpdate: false\n  };\n  this.uniform = uniform;\n  this.numPlanes = 0;\n  this.numIntersection = 0;\n\n  this.init = function (planes, enableLocalClipping, camera) {\n    var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to\n    // run another frame in order to reset the state:\n    numGlobalPlanes !== 0 || localClippingEnabled;\n    localClippingEnabled = enableLocalClipping;\n    globalState = projectPlanes(planes, camera, 0);\n    numGlobalPlanes = planes.length;\n    return enabled;\n  };\n\n  this.beginShadows = function () {\n    renderingShadows = true;\n    projectPlanes(null);\n  };\n\n  this.endShadows = function () {\n    renderingShadows = false;\n    resetGlobalState();\n  };\n\n  this.setState = function (material, camera, useCache) {\n    var planes = material.clippingPlanes,\n        clipIntersection = material.clipIntersection,\n        clipShadows = material.clipShadows;\n    var materialProperties = properties.get(material);\n\n    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {\n      // there's no local clipping\n      if (renderingShadows) {\n        // there's no global clipping\n        projectPlanes(null);\n      } else {\n        resetGlobalState();\n      }\n    } else {\n      var nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n          lGlobal = nGlobal * 4;\n      var dstArray = materialProperties.clippingState || null;\n      uniform.value = dstArray; // ensure unique state\n\n      dstArray = projectPlanes(planes, camera, lGlobal, useCache);\n\n      for (var i = 0; i !== lGlobal; ++i) {\n        dstArray[i] = globalState[i];\n      }\n\n      materialProperties.clippingState = dstArray;\n      this.numIntersection = clipIntersection ? this.numPlanes : 0;\n      this.numPlanes += nGlobal;\n    }\n  };\n\n  function resetGlobalState() {\n    if (uniform.value !== globalState) {\n      uniform.value = globalState;\n      uniform.needsUpdate = numGlobalPlanes > 0;\n    }\n\n    scope.numPlanes = numGlobalPlanes;\n    scope.numIntersection = 0;\n  }\n\n  function projectPlanes(planes, camera, dstOffset, skipTransform) {\n    var nPlanes = planes !== null ? planes.length : 0;\n    var dstArray = null;\n\n    if (nPlanes !== 0) {\n      dstArray = uniform.value;\n\n      if (skipTransform !== true || dstArray === null) {\n        var flatSize = dstOffset + nPlanes * 4,\n            viewMatrix = camera.matrixWorldInverse;\n        viewNormalMatrix.getNormalMatrix(viewMatrix);\n\n        if (dstArray === null || dstArray.length < flatSize) {\n          dstArray = new Float32Array(flatSize);\n        }\n\n        for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {\n          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);\n          plane.normal.toArray(dstArray, i4);\n          dstArray[i4 + 3] = plane.constant;\n        }\n      }\n\n      uniform.value = dstArray;\n      uniform.needsUpdate = true;\n    }\n\n    scope.numPlanes = nPlanes;\n    scope.numIntersection = 0;\n    return dstArray;\n  }\n}\n\nexport { WebGLClipping };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/renderers/webgl/WebGLClipping.js"],"names":["Matrix3","Plane","WebGLClipping","properties","scope","globalState","numGlobalPlanes","localClippingEnabled","renderingShadows","plane","viewNormalMatrix","uniform","value","needsUpdate","numPlanes","numIntersection","init","planes","enableLocalClipping","camera","enabled","length","projectPlanes","beginShadows","endShadows","resetGlobalState","setState","material","useCache","clippingPlanes","clipIntersection","clipShadows","materialProperties","get","nGlobal","lGlobal","dstArray","clippingState","i","dstOffset","skipTransform","nPlanes","flatSize","viewMatrix","matrixWorldInverse","getNormalMatrix","Float32Array","i4","copy","applyMatrix4","normal","toArray","constant"],"mappings":"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","sourcesContent":["import { Matrix3 } from '../../math/Matrix3.js';\nimport { Plane } from '../../math/Plane.js';\n\nfunction WebGLClipping( properties ) {\n\n\tconst scope = this;\n\n\tlet globalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false;\n\n\tconst plane = new Plane(),\n\t\tviewNormalMatrix = new Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\tthis.numIntersection = 0;\n\n\tthis.init = function ( planes, enableLocalClipping, camera ) {\n\n\t\tconst enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function () {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function () {\n\n\t\trenderingShadows = false;\n\t\tresetGlobalState();\n\n\t};\n\n\tthis.setState = function ( material, camera, useCache ) {\n\n\t\tconst planes = material.clippingPlanes,\n\t\t\tclipIntersection = material.clipIntersection,\n\t\t\tclipShadows = material.clipShadows;\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\n\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4;\n\n\t\t\tlet dstArray = materialProperties.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, useCache );\n\n\t\t\tfor ( let i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tmaterialProperties.clippingState = dstArray;\n\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\t\tscope.numIntersection = 0;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tconst nPlanes = planes !== null ? planes.length : 0;\n\t\tlet dstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tconst flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\t\tscope.numIntersection = 0;\n\n\t\treturn dstArray;\n\n\t}\n\n}\n\n\nexport { WebGLClipping };\n"]},"metadata":{},"sourceType":"module"}