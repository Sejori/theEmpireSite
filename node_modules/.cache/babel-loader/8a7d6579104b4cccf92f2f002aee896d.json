{"ast":null,"code":"import { Box3 } from './Box3.js';\nimport { Vector3 } from './Vector3.js';\n\nvar _box = /*@__PURE__*/new Box3();\n\nclass Sphere {\n  constructor(center, radius) {\n    this.center = center !== undefined ? center : new Vector3();\n    this.radius = radius !== undefined ? radius : -1;\n  }\n\n  set(center, radius) {\n    this.center.copy(center);\n    this.radius = radius;\n    return this;\n  }\n\n  setFromPoints(points, optionalCenter) {\n    var center = this.center;\n\n    if (optionalCenter !== undefined) {\n      center.copy(optionalCenter);\n    } else {\n      _box.setFromPoints(points).getCenter(center);\n    }\n\n    var maxRadiusSq = 0;\n\n    for (var i = 0, il = points.length; i < il; i++) {\n      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n    }\n\n    this.radius = Math.sqrt(maxRadiusSq);\n    return this;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(sphere) {\n    this.center.copy(sphere.center);\n    this.radius = sphere.radius;\n    return this;\n  }\n\n  isEmpty() {\n    return this.radius < 0;\n  }\n\n  makeEmpty() {\n    this.center.set(0, 0, 0);\n    this.radius = -1;\n    return this;\n  }\n\n  containsPoint(point) {\n    return point.distanceToSquared(this.center) <= this.radius * this.radius;\n  }\n\n  distanceToPoint(point) {\n    return point.distanceTo(this.center) - this.radius;\n  }\n\n  intersectsSphere(sphere) {\n    var radiusSum = this.radius + sphere.radius;\n    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n  }\n\n  intersectsBox(box) {\n    return box.intersectsSphere(this);\n  }\n\n  intersectsPlane(plane) {\n    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n  }\n\n  clampPoint(point, target) {\n    var deltaLengthSq = this.center.distanceToSquared(point);\n\n    if (target === undefined) {\n      console.warn('THREE.Sphere: .clampPoint() target is now required');\n      target = new Vector3();\n    }\n\n    target.copy(point);\n\n    if (deltaLengthSq > this.radius * this.radius) {\n      target.sub(this.center).normalize();\n      target.multiplyScalar(this.radius).add(this.center);\n    }\n\n    return target;\n  }\n\n  getBoundingBox(target) {\n    if (target === undefined) {\n      console.warn('THREE.Sphere: .getBoundingBox() target is now required');\n      target = new Box3();\n    }\n\n    if (this.isEmpty()) {\n      // Empty sphere produces empty bounding box\n      target.makeEmpty();\n      return target;\n    }\n\n    target.set(this.center, this.center);\n    target.expandByScalar(this.radius);\n    return target;\n  }\n\n  applyMatrix4(matrix) {\n    this.center.applyMatrix4(matrix);\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\n    return this;\n  }\n\n  translate(offset) {\n    this.center.add(offset);\n    return this;\n  }\n\n  equals(sphere) {\n    return sphere.center.equals(this.center) && sphere.radius === this.radius;\n  }\n\n}\n\nexport { Sphere };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/math/Sphere.js"],"names":["Box3","Vector3","_box","Sphere","constructor","center","radius","undefined","set","copy","setFromPoints","points","optionalCenter","getCenter","maxRadiusSq","i","il","length","Math","max","distanceToSquared","sqrt","clone","sphere","isEmpty","makeEmpty","containsPoint","point","distanceToPoint","distanceTo","intersectsSphere","radiusSum","intersectsBox","box","intersectsPlane","plane","abs","clampPoint","target","deltaLengthSq","console","warn","sub","normalize","multiplyScalar","add","getBoundingBox","expandByScalar","applyMatrix4","matrix","getMaxScaleOnAxis","translate","offset","equals"],"mappings":"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","sourcesContent":["import { Box3 } from './Box3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _box = /*@__PURE__*/ new Box3();\n\nclass Sphere {\n\n\tconstructor( center, radius ) {\n\n\t\tthis.center = ( center !== undefined ) ? center : new Vector3();\n\t\tthis.radius = ( radius !== undefined ) ? radius : - 1;\n\n\t}\n\n\tset( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points, optionalCenter ) {\n\n\t\tconst center = this.center;\n\n\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\tcenter.copy( optionalCenter );\n\n\t\t} else {\n\n\t\t\t_box.setFromPoints( points ).getCenter( center );\n\n\t\t}\n\n\t\tlet maxRadiusSq = 0;\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\treturn ( this.radius < 0 );\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.center.set( 0, 0, 0 );\n\t\tthis.radius = - 1;\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\tconst deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Sphere: .clampPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );\n\t\t\ttarget = new Box3();\n\n\t\t}\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\t// Empty sphere produces empty bounding box\n\t\t\ttarget.makeEmpty();\n\t\t\treturn target;\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n}\n\n\nexport { Sphere };\n"]},"metadata":{},"sourceType":"module"}