{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass TubeBufferGeometry extends BufferGeometry {\n  constructor(path, tubularSegments, radius, radialSegments, closed) {\n    super();\n    this.type = 'TubeBufferGeometry';\n    this.parameters = {\n      path: path,\n      tubularSegments: tubularSegments,\n      radius: radius,\n      radialSegments: radialSegments,\n      closed: closed\n    };\n    tubularSegments = tubularSegments || 64;\n    radius = radius || 1;\n    radialSegments = radialSegments || 8;\n    closed = closed || false;\n    var frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals\n\n    this.tangents = frames.tangents;\n    this.normals = frames.normals;\n    this.binormals = frames.binormals; // helper variables\n\n    var vertex = new Vector3();\n    var normal = new Vector3();\n    var uv = new Vector2();\n    var P = new Vector3(); // buffer\n\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n    var indices = []; // create buffer data\n\n    generateBufferData(); // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions\n\n    function generateBufferData() {\n      for (var i = 0; i < tubularSegments; i++) {\n        generateSegment(i);\n      } // if the geometry is not closed, generate the last row of vertices and normals\n      // at the regular position on the given path\n      //\n      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\n      generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.\n      // this makes it easy compute correct values for closed geometries\n\n      generateUVs(); // finally create faces\n\n      generateIndices();\n    }\n\n    function generateSegment(i) {\n      // we use getPointAt to sample evenly distributed points from the given path\n      P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal\n\n      var N = frames.normals[i];\n      var B = frames.binormals[i]; // generate normals and vertices for the current segment\n\n      for (var j = 0; j <= radialSegments; j++) {\n        var v = j / radialSegments * Math.PI * 2;\n        var sin = Math.sin(v);\n        var cos = -Math.cos(v); // normal\n\n        normal.x = cos * N.x + sin * B.x;\n        normal.y = cos * N.y + sin * B.y;\n        normal.z = cos * N.z + sin * B.z;\n        normal.normalize();\n        normals.push(normal.x, normal.y, normal.z); // vertex\n\n        vertex.x = P.x + radius * normal.x;\n        vertex.y = P.y + radius * normal.y;\n        vertex.z = P.z + radius * normal.z;\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n    }\n\n    function generateIndices() {\n      for (var j = 1; j <= tubularSegments; j++) {\n        for (var i = 1; i <= radialSegments; i++) {\n          var a = (radialSegments + 1) * (j - 1) + (i - 1);\n          var b = (radialSegments + 1) * j + (i - 1);\n          var c = (radialSegments + 1) * j + i;\n          var d = (radialSegments + 1) * (j - 1) + i; // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n        }\n      }\n    }\n\n    function generateUVs() {\n      for (var i = 0; i <= tubularSegments; i++) {\n        for (var j = 0; j <= radialSegments; j++) {\n          uv.x = i / tubularSegments;\n          uv.y = j / radialSegments;\n          uvs.push(uv.x, uv.y);\n        }\n      }\n    }\n  }\n\n  toJSON() {\n    var data = BufferGeometry.prototype.toJSON.call(this);\n    data.path = this.parameters.path.toJSON();\n    return data;\n  }\n\n}\n\nexport { TubeBufferGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/TubeBufferGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector2","Vector3","TubeBufferGeometry","constructor","path","tubularSegments","radius","radialSegments","closed","type","parameters","frames","computeFrenetFrames","tangents","normals","binormals","vertex","normal","uv","P","vertices","uvs","indices","generateBufferData","setIndex","setAttribute","i","generateSegment","generateUVs","generateIndices","getPointAt","N","B","j","v","Math","PI","sin","cos","x","y","z","normalize","push","a","b","c","d","toJSON","data","prototype","call"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass TubeBufferGeometry extends BufferGeometry {\n\n\tconstructor( path, tubularSegments, radius, radialSegments, closed ) {\n\n\t\tsuper();\n\t\tthis.type = 'TubeBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\ttubularSegments = tubularSegments || 64;\n\t\tradius = radius || 1;\n\t\tradialSegments = radialSegments || 8;\n\t\tclosed = closed || false;\n\n\t\tconst frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tlet P = new Vector3();\n\n\t\t// buffer\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( let i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tP = path.getPointAt( i / tubularSegments, P );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tconst N = frames.normals[ i ];\n\t\t\tconst B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tconst sin = Math.sin( v );\n\t\t\t\tconst cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\ttoJSON() {\n\n\t\tconst data = BufferGeometry.prototype.toJSON.call( this );\n\n\t\tdata.path = this.parameters.path.toJSON();\n\n\t\treturn data;\n\n\t}\n\n}\n\n\nexport { TubeBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}