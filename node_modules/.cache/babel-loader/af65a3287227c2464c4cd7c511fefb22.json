{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass TorusKnotBufferGeometry extends BufferGeometry {\n  constructor(radius, tube, tubularSegments, radialSegments, p, q) {\n    super();\n    this.type = 'TorusKnotBufferGeometry';\n    this.parameters = {\n      radius: radius,\n      tube: tube,\n      tubularSegments: tubularSegments,\n      radialSegments: radialSegments,\n      p: p,\n      q: q\n    };\n    radius = radius || 1;\n    tube = tube || 0.4;\n    tubularSegments = Math.floor(tubularSegments) || 64;\n    radialSegments = Math.floor(radialSegments) || 8;\n    p = p || 2;\n    q = q || 3; // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helper variables\n\n    var vertex = new Vector3();\n    var normal = new Vector3();\n    var P1 = new Vector3();\n    var P2 = new Vector3();\n    var B = new Vector3();\n    var T = new Vector3();\n    var N = new Vector3(); // generate vertices, normals and uvs\n\n    for (var i = 0; i <= tubularSegments; ++i) {\n      // the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n      var u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n      // these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n      calculatePositionOnCurve(u, p, q, radius, P1);\n      calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis\n\n      T.subVectors(P2, P1);\n      N.addVectors(P2, P1);\n      B.crossVectors(T, N);\n      N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it\n\n      B.normalize();\n      N.normalize();\n\n      for (var j = 0; j <= radialSegments; ++j) {\n        // now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n        // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n        var v = j / radialSegments * Math.PI * 2;\n        var cx = -tube * Math.cos(v);\n        var cy = tube * Math.sin(v); // now calculate the final vertex position.\n        // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n        vertex.x = P1.x + (cx * N.x + cy * B.x);\n        vertex.y = P1.y + (cx * N.y + cy * B.y);\n        vertex.z = P1.z + (cx * N.z + cy * B.z);\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n        normal.subVectors(vertex, P1).normalize();\n        normals.push(normal.x, normal.y, normal.z); // uv\n\n        uvs.push(i / tubularSegments);\n        uvs.push(j / radialSegments);\n      }\n    } // generate indices\n\n\n    for (var _j = 1; _j <= tubularSegments; _j++) {\n      for (var _i = 1; _i <= radialSegments; _i++) {\n        // indices\n        var a = (radialSegments + 1) * (_j - 1) + (_i - 1);\n        var b = (radialSegments + 1) * _j + (_i - 1);\n        var c = (radialSegments + 1) * _j + _i;\n        var d = (radialSegments + 1) * (_j - 1) + _i; // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve\n\n    function calculatePositionOnCurve(u, p, q, radius, position) {\n      var cu = Math.cos(u);\n      var su = Math.sin(u);\n      var quOverP = q / p * u;\n      var cs = Math.cos(quOverP);\n      position.x = radius * (2 + cs) * 0.5 * cu;\n      position.y = radius * (2 + cs) * su * 0.5;\n      position.z = radius * Math.sin(quOverP) * 0.5;\n    }\n  }\n\n}\n\nexport { TorusKnotBufferGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/TorusKnotBufferGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","TorusKnotBufferGeometry","constructor","radius","tube","tubularSegments","radialSegments","p","q","type","parameters","Math","floor","indices","vertices","normals","uvs","vertex","normal","P1","P2","B","T","N","i","u","PI","calculatePositionOnCurve","subVectors","addVectors","crossVectors","normalize","j","v","cx","cos","cy","sin","x","y","z","push","a","b","c","d","setIndex","setAttribute","position","cu","su","quOverP","cs"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass TorusKnotBufferGeometry extends BufferGeometry {\n\n\tconstructor( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\t\tsuper();\n\t\tthis.type = 'TorusKnotBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\tradius = radius || 1;\n\t\ttube = tube || 0.4;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\tp = p || 2;\n\t\tq = q || 3;\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst P1 = new Vector3();\n\t\tconst P2 = new Vector3();\n\n\t\tconst B = new Vector3();\n\t\tconst T = new Vector3();\n\t\tconst N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\t\tconst u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( let j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\tconst cx = - tube * Math.cos( v );\n\t\t\t\tconst cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tconst cu = Math.cos( u );\n\t\t\tconst su = Math.sin( u );\n\t\t\tconst quOverP = q / p * u;\n\t\t\tconst cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n}\n\nexport { TorusKnotBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}