{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass RingBufferGeometry extends BufferGeometry {\n  constructor(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {\n    super();\n    this.type = 'RingBufferGeometry';\n    this.parameters = {\n      innerRadius: innerRadius,\n      outerRadius: outerRadius,\n      thetaSegments: thetaSegments,\n      phiSegments: phiSegments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    innerRadius = innerRadius || 0.5;\n    outerRadius = outerRadius || 1;\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n    thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;\n    phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1; // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // some helper variables\n\n    var radius = innerRadius;\n    var radiusStep = (outerRadius - innerRadius) / phiSegments;\n    var vertex = new Vector3();\n    var uv = new Vector2(); // generate vertices, normals and uvs\n\n    for (var j = 0; j <= phiSegments; j++) {\n      for (var i = 0; i <= thetaSegments; i++) {\n        // values are generate from the inside of the ring to the outside\n        var segment = thetaStart + i / thetaSegments * thetaLength; // vertex\n\n        vertex.x = radius * Math.cos(segment);\n        vertex.y = radius * Math.sin(segment);\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n        normals.push(0, 0, 1); // uv\n\n        uv.x = (vertex.x / outerRadius + 1) / 2;\n        uv.y = (vertex.y / outerRadius + 1) / 2;\n        uvs.push(uv.x, uv.y);\n      } // increase the radius for next row of vertices\n\n\n      radius += radiusStep;\n    } // indices\n\n\n    for (var _j = 0; _j < phiSegments; _j++) {\n      var thetaSegmentLevel = _j * (thetaSegments + 1);\n\n      for (var _i = 0; _i < thetaSegments; _i++) {\n        var _segment = _i + thetaSegmentLevel;\n\n        var a = _segment;\n        var b = _segment + thetaSegments + 1;\n        var c = _segment + thetaSegments + 2;\n        var d = _segment + 1; // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n\n}\n\nexport { RingBufferGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/RingBufferGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector2","Vector3","RingBufferGeometry","constructor","innerRadius","outerRadius","thetaSegments","phiSegments","thetaStart","thetaLength","type","parameters","undefined","Math","PI","max","indices","vertices","normals","uvs","radius","radiusStep","vertex","uv","j","i","segment","x","cos","y","sin","push","z","thetaSegmentLevel","a","b","c","d","setIndex","setAttribute"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass RingBufferGeometry extends BufferGeometry {\n\n\tconstructor( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'RingBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tinnerRadius = innerRadius || 0.5;\n\t\touterRadius = outerRadius || 1;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// some helper variables\n\n\t\tlet radius = innerRadius;\n\t\tconst radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\t// values are generate from the inside of the ring to the outside\n\n\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tconst thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( let i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tconst segment = i + thetaSegmentLevel;\n\n\t\t\t\tconst a = segment;\n\t\t\t\tconst b = segment + thetaSegments + 1;\n\t\t\t\tconst c = segment + thetaSegments + 2;\n\t\t\t\tconst d = segment + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n}\n\n\nexport { RingBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}