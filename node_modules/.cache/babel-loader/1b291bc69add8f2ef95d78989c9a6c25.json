{"ast":null,"code":"import { Quaternion } from '../math/Quaternion.js';\n\nfunction PropertyMixer(binding, typeName, valueSize) {\n  this.binding = binding;\n  this.valueSize = valueSize;\n  var mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n  //\n  // interpolators can use .buffer as their .result\n  // the data then goes to 'incoming'\n  //\n  // 'accu0' and 'accu1' are used frame-interleaved for\n  // the cumulative result and are compared to detect\n  // changes\n  //\n  // 'orig' stores the original state of the property\n  //\n  // 'add' is used for additive cumulative results\n  //\n  // 'work' is optional and is only present for quaternion types. It is used\n  // to store intermediate quaternion multiplication results\n\n  switch (typeName) {\n    case 'quaternion':\n      mixFunction = this._slerp;\n      mixFunctionAdditive = this._slerpAdditive;\n      setIdentity = this._setAdditiveIdentityQuaternion;\n      this.buffer = new Float64Array(valueSize * 6);\n      this._workIndex = 5;\n      break;\n\n    case 'string':\n    case 'bool':\n      mixFunction = this._select; // Use the regular mix function and for additive on these types,\n      // additive is not relevant for non-numeric types\n\n      mixFunctionAdditive = this._select;\n      setIdentity = this._setAdditiveIdentityOther;\n      this.buffer = new Array(valueSize * 5);\n      break;\n\n    default:\n      mixFunction = this._lerp;\n      mixFunctionAdditive = this._lerpAdditive;\n      setIdentity = this._setAdditiveIdentityNumeric;\n      this.buffer = new Float64Array(valueSize * 5);\n  }\n\n  this._mixBufferRegion = mixFunction;\n  this._mixBufferRegionAdditive = mixFunctionAdditive;\n  this._setIdentity = setIdentity;\n  this._origIndex = 3;\n  this._addIndex = 4;\n  this.cumulativeWeight = 0;\n  this.cumulativeWeightAdditive = 0;\n  this.useCount = 0;\n  this.referenceCount = 0;\n}\n\nObject.assign(PropertyMixer.prototype, {\n  // accumulate data in the 'incoming' region into 'accu<i>'\n  accumulate: function accumulate(accuIndex, weight) {\n    // note: happily accumulating nothing when weight = 0, the caller knows\n    // the weight and shouldn't have made the call in the first place\n    var buffer = this.buffer,\n        stride = this.valueSize,\n        offset = accuIndex * stride + stride;\n    var currentWeight = this.cumulativeWeight;\n\n    if (currentWeight === 0) {\n      // accuN := incoming * weight\n      for (var i = 0; i !== stride; ++i) {\n        buffer[offset + i] = buffer[i];\n      }\n\n      currentWeight = weight;\n    } else {\n      // accuN := accuN + incoming * weight\n      currentWeight += weight;\n      var mix = weight / currentWeight;\n\n      this._mixBufferRegion(buffer, offset, 0, mix, stride);\n    }\n\n    this.cumulativeWeight = currentWeight;\n  },\n  // accumulate data in the 'incoming' region into 'add'\n  accumulateAdditive: function accumulateAdditive(weight) {\n    var buffer = this.buffer,\n        stride = this.valueSize,\n        offset = stride * this._addIndex;\n\n    if (this.cumulativeWeightAdditive === 0) {\n      // add = identity\n      this._setIdentity();\n    } // add := add + incoming * weight\n\n\n    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);\n\n    this.cumulativeWeightAdditive += weight;\n  },\n  // apply the state of 'accu<i>' to the binding when accus differ\n  apply: function apply(accuIndex) {\n    var stride = this.valueSize,\n        buffer = this.buffer,\n        offset = accuIndex * stride + stride,\n        weight = this.cumulativeWeight,\n        weightAdditive = this.cumulativeWeightAdditive,\n        binding = this.binding;\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n\n    if (weight < 1) {\n      // accuN := accuN + original * ( 1 - cumulativeWeight )\n      var originalValueOffset = stride * this._origIndex;\n\n      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);\n    }\n\n    if (weightAdditive > 0) {\n      // accuN := accuN + additive accuN\n      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);\n    }\n\n    for (var i = stride, e = stride + stride; i !== e; ++i) {\n      if (buffer[i] !== buffer[i + stride]) {\n        // value has changed -> update scene graph\n        binding.setValue(buffer, offset);\n        break;\n      }\n    }\n  },\n  // remember the state of the bound property and copy it to both accus\n  saveOriginalState: function saveOriginalState() {\n    var binding = this.binding;\n    var buffer = this.buffer,\n        stride = this.valueSize,\n        originalValueOffset = stride * this._origIndex;\n    binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original\n\n    for (var i = stride, e = originalValueOffset; i !== e; ++i) {\n      buffer[i] = buffer[originalValueOffset + i % stride];\n    } // Add to identity for additive\n\n\n    this._setIdentity();\n\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n  },\n  // apply the state previously taken via 'saveOriginalState' to the binding\n  restoreOriginalState: function restoreOriginalState() {\n    var originalValueOffset = this.valueSize * 3;\n    this.binding.setValue(this.buffer, originalValueOffset);\n  },\n  _setAdditiveIdentityNumeric: function _setAdditiveIdentityNumeric() {\n    var startIndex = this._addIndex * this.valueSize;\n    var endIndex = startIndex + this.valueSize;\n\n    for (var i = startIndex; i < endIndex; i++) {\n      this.buffer[i] = 0;\n    }\n  },\n  _setAdditiveIdentityQuaternion: function _setAdditiveIdentityQuaternion() {\n    this._setAdditiveIdentityNumeric();\n\n    this.buffer[this._addIndex * this.valueSize + 3] = 1;\n  },\n  _setAdditiveIdentityOther: function _setAdditiveIdentityOther() {\n    var startIndex = this._origIndex * this.valueSize;\n    var targetIndex = this._addIndex * this.valueSize;\n\n    for (var i = 0; i < this.valueSize; i++) {\n      this.buffer[targetIndex + i] = this.buffer[startIndex + i];\n    }\n  },\n  // mix functions\n  _select: function _select(buffer, dstOffset, srcOffset, t, stride) {\n    if (t >= 0.5) {\n      for (var i = 0; i !== stride; ++i) {\n        buffer[dstOffset + i] = buffer[srcOffset + i];\n      }\n    }\n  },\n  _slerp: function _slerp(buffer, dstOffset, srcOffset, t) {\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);\n  },\n  _slerpAdditive: function _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n    var workOffset = this._workIndex * stride; // Store result in intermediate buffer offset\n\n    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result\n\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);\n  },\n  _lerp: function _lerp(buffer, dstOffset, srcOffset, t, stride) {\n    var s = 1 - t;\n\n    for (var i = 0; i !== stride; ++i) {\n      var j = dstOffset + i;\n      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;\n    }\n  },\n  _lerpAdditive: function _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n    for (var i = 0; i !== stride; ++i) {\n      var j = dstOffset + i;\n      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;\n    }\n  }\n});\nexport { PropertyMixer };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/animation/PropertyMixer.js"],"names":["Quaternion","PropertyMixer","binding","typeName","valueSize","mixFunction","mixFunctionAdditive","setIdentity","_slerp","_slerpAdditive","_setAdditiveIdentityQuaternion","buffer","Float64Array","_workIndex","_select","_setAdditiveIdentityOther","Array","_lerp","_lerpAdditive","_setAdditiveIdentityNumeric","_mixBufferRegion","_mixBufferRegionAdditive","_setIdentity","_origIndex","_addIndex","cumulativeWeight","cumulativeWeightAdditive","useCount","referenceCount","Object","assign","prototype","accumulate","accuIndex","weight","stride","offset","currentWeight","i","mix","accumulateAdditive","apply","weightAdditive","originalValueOffset","e","setValue","saveOriginalState","getValue","restoreOriginalState","startIndex","endIndex","targetIndex","dstOffset","srcOffset","t","slerpFlat","workOffset","multiplyQuaternionsFlat","s","j"],"mappings":"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","sourcesContent":["import { Quaternion } from '../math/Quaternion.js';\n\nfunction PropertyMixer( binding, typeName, valueSize ) {\n\n\tthis.binding = binding;\n\tthis.valueSize = valueSize;\n\n\tlet mixFunction,\n\t\tmixFunctionAdditive,\n\t\tsetIdentity;\n\n\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t//\n\t// interpolators can use .buffer as their .result\n\t// the data then goes to 'incoming'\n\t//\n\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t// the cumulative result and are compared to detect\n\t// changes\n\t//\n\t// 'orig' stores the original state of the property\n\t//\n\t// 'add' is used for additive cumulative results\n\t//\n\t// 'work' is optional and is only present for quaternion types. It is used\n\t// to store intermediate quaternion multiplication results\n\n\tswitch ( typeName ) {\n\n\t\tcase 'quaternion':\n\t\t\tmixFunction = this._slerp;\n\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\n\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\n\t\t\tthis._workIndex = 5;\n\t\t\tbreak;\n\n\t\tcase 'string':\n\t\tcase 'bool':\n\t\t\tmixFunction = this._select;\n\n\t\t\t// Use the regular mix function and for additive on these types,\n\t\t\t// additive is not relevant for non-numeric types\n\t\t\tmixFunctionAdditive = this._select;\n\n\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\n\t\t\tthis.buffer = new Array( valueSize * 5 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmixFunction = this._lerp;\n\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\n\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\n\n\t}\n\n\tthis._mixBufferRegion = mixFunction;\n\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\tthis._setIdentity = setIdentity;\n\tthis._origIndex = 3;\n\tthis._addIndex = 4;\n\n\tthis.cumulativeWeight = 0;\n\tthis.cumulativeWeightAdditive = 0;\n\n\tthis.useCount = 0;\n\tthis.referenceCount = 0;\n\n}\n\nObject.assign( PropertyMixer.prototype, {\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate: function ( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride;\n\n\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tconst mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t},\n\n\t// accumulate data in the 'incoming' region into 'add'\n\taccumulateAdditive: function ( weight ) {\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = stride * this._addIndex;\n\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\n\n\t\t\t// add = identity\n\n\t\t\tthis._setIdentity();\n\n\t\t}\n\n\t\t// add := add + incoming * weight\n\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\n\t\tthis.cumulativeWeightAdditive += weight;\n\n\t},\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply: function ( accuIndex ) {\n\n\t\tconst stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tif ( weightAdditive > 0 ) {\n\n\t\t\t// accuN := accuN + additive accuN\n\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\n\n\t\t}\n\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState: function () {\n\n\t\tconst binding = this.binding;\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * this._origIndex;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\t// Add to identity for additive\n\t\tthis._setIdentity();\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t},\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState: function () {\n\n\t\tconst originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t},\n\n\t_setAdditiveIdentityNumeric: function () {\n\n\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\n\n\t\t\tthis.buffer[ i ] = 0;\n\n\t\t}\n\n\t},\n\n\t_setAdditiveIdentityQuaternion: function () {\n\n\t\tthis._setAdditiveIdentityNumeric();\n\t\tthis.buffer[ this._addIndex * this.valueSize + 3 ] = 1;\n\n\t},\n\n\t_setAdditiveIdentityOther: function () {\n\n\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\n\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\n\n\t\t}\n\n\t},\n\n\n\t// mix functions\n\n\t_select: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_slerp: function ( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t},\n\n\t_slerpAdditive: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst workOffset = this._workIndex * stride;\n\n\t\t// Store result in intermediate buffer offset\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\n\n\t\t// Slerp to the intermediate result\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\n\n\t},\n\n\t_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst s = 1 - t;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t},\n\n\t_lerpAdditive: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { PropertyMixer };\n"]},"metadata":{},"sourceType":"module"}