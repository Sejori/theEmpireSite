{"ast":null,"code":"import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { LineBasicMaterial } from '../materials/LineBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n\nvar _start = new Vector3();\n\nvar _end = new Vector3();\n\nvar _inverseMatrix = new Matrix4();\n\nvar _ray = new Ray();\n\nvar _sphere = new Sphere();\n\nfunction Line(geometry, material, mode) {\n  if (mode === 1) {\n    console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');\n  }\n\n  Object3D.call(this);\n  this.type = 'Line';\n  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n  this.material = material !== undefined ? material : new LineBasicMaterial();\n  this.updateMorphTargets();\n}\n\nLine.prototype = Object.assign(Object.create(Object3D.prototype), {\n  constructor: Line,\n  isLine: true,\n  copy: function copy(source) {\n    Object3D.prototype.copy.call(this, source);\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  },\n  computeLineDistances: function computeLineDistances() {\n    var geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      // we assume non-indexed geometry\n      if (geometry.index === null) {\n        var positionAttribute = geometry.attributes.position;\n        var lineDistances = [0];\n\n        for (var i = 1, l = positionAttribute.count; i < l; i++) {\n          _start.fromBufferAttribute(positionAttribute, i - 1);\n\n          _end.fromBufferAttribute(positionAttribute, i);\n\n          lineDistances[i] = lineDistances[i - 1];\n          lineDistances[i] += _start.distanceTo(_end);\n        }\n\n        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n      } else {\n        console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n      }\n    } else if (geometry.isGeometry) {\n      var vertices = geometry.vertices;\n      var _lineDistances = geometry.lineDistances;\n      _lineDistances[0] = 0;\n\n      for (var _i = 1, _l = vertices.length; _i < _l; _i++) {\n        _lineDistances[_i] = _lineDistances[_i - 1];\n        _lineDistances[_i] += vertices[_i - 1].distanceTo(vertices[_i]);\n      }\n    }\n\n    return this;\n  },\n  raycast: function raycast(raycaster, intersects) {\n    var geometry = this.geometry;\n    var matrixWorld = this.matrixWorld;\n    var threshold = raycaster.params.Line.threshold; // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere.copy(geometry.boundingSphere);\n\n    _sphere.applyMatrix4(matrixWorld);\n\n    _sphere.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n    _inverseMatrix.getInverse(matrixWorld);\n\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    var localThresholdSq = localThreshold * localThreshold;\n    var vStart = new Vector3();\n    var vEnd = new Vector3();\n    var interSegment = new Vector3();\n    var interRay = new Vector3();\n    var step = this.isLineSegments ? 2 : 1;\n\n    if (geometry.isBufferGeometry) {\n      var index = geometry.index;\n      var attributes = geometry.attributes;\n      var positionAttribute = attributes.position;\n\n      if (index !== null) {\n        var indices = index.array;\n\n        for (var i = 0, l = indices.length - 1; i < l; i += step) {\n          var a = indices[i];\n          var b = indices[i + 1];\n          vStart.fromBufferAttribute(positionAttribute, a);\n          vEnd.fromBufferAttribute(positionAttribute, b);\n\n          var distSq = _ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n          if (distSq > localThresholdSq) continue;\n          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n          var distance = raycaster.ray.origin.distanceTo(interRay);\n          if (distance < raycaster.near || distance > raycaster.far) continue;\n          intersects.push({\n            distance: distance,\n            // What do we want? intersection point on the ray or on the segment??\n            // point: raycaster.ray.at( distance ),\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: i,\n            face: null,\n            faceIndex: null,\n            object: this\n          });\n        }\n      } else {\n        for (var _i2 = 0, _l2 = positionAttribute.count - 1; _i2 < _l2; _i2 += step) {\n          vStart.fromBufferAttribute(positionAttribute, _i2);\n          vEnd.fromBufferAttribute(positionAttribute, _i2 + 1);\n\n          var _distSq = _ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n          if (_distSq > localThresholdSq) continue;\n          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n          var _distance = raycaster.ray.origin.distanceTo(interRay);\n\n          if (_distance < raycaster.near || _distance > raycaster.far) continue;\n          intersects.push({\n            distance: _distance,\n            // What do we want? intersection point on the ray or on the segment??\n            // point: raycaster.ray.at( distance ),\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: _i2,\n            face: null,\n            faceIndex: null,\n            object: this\n          });\n        }\n      }\n    } else if (geometry.isGeometry) {\n      var vertices = geometry.vertices;\n      var nbVertices = vertices.length;\n\n      for (var _i3 = 0; _i3 < nbVertices - 1; _i3 += step) {\n        var _distSq2 = _ray.distanceSqToSegment(vertices[_i3], vertices[_i3 + 1], interRay, interSegment);\n\n        if (_distSq2 > localThresholdSq) continue;\n        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n        var _distance2 = raycaster.ray.origin.distanceTo(interRay);\n\n        if (_distance2 < raycaster.near || _distance2 > raycaster.far) continue;\n        intersects.push({\n          distance: _distance2,\n          // What do we want? intersection point on the ray or on the segment??\n          // point: raycaster.ray.at( distance ),\n          point: interSegment.clone().applyMatrix4(this.matrixWorld),\n          index: _i3,\n          face: null,\n          faceIndex: null,\n          object: this\n        });\n      }\n    }\n  },\n  updateMorphTargets: function updateMorphTargets() {\n    var geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      var morphAttributes = geometry.morphAttributes;\n      var keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        var morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (var m = 0, ml = morphAttribute.length; m < ml; m++) {\n            var name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      var morphTargets = geometry.morphTargets;\n\n      if (morphTargets !== undefined && morphTargets.length > 0) {\n        console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');\n      }\n    }\n  }\n});\nexport { Line };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/objects/Line.js"],"names":["Sphere","Ray","Matrix4","Object3D","Vector3","LineBasicMaterial","BufferGeometry","Float32BufferAttribute","_start","_end","_inverseMatrix","_ray","_sphere","Line","geometry","material","mode","console","error","call","type","undefined","updateMorphTargets","prototype","Object","assign","create","constructor","isLine","copy","source","computeLineDistances","isBufferGeometry","index","positionAttribute","attributes","position","lineDistances","i","l","count","fromBufferAttribute","distanceTo","setAttribute","warn","isGeometry","vertices","length","raycast","raycaster","intersects","matrixWorld","threshold","params","boundingSphere","computeBoundingSphere","applyMatrix4","radius","ray","intersectsSphere","getInverse","localThreshold","scale","x","y","z","localThresholdSq","vStart","vEnd","interSegment","interRay","step","isLineSegments","indices","array","a","b","distSq","distanceSqToSegment","distance","origin","near","far","push","point","clone","face","faceIndex","object","nbVertices","morphAttributes","keys","morphAttribute","morphTargetInfluences","morphTargetDictionary","m","ml","name","String","morphTargets"],"mappings":"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","sourcesContent":["import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { LineBasicMaterial } from '../materials/LineBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n\nconst _start = new Vector3();\nconst _end = new Vector3();\nconst _inverseMatrix = new Matrix4();\nconst _ray = new Ray();\nconst _sphere = new Sphere();\n\nfunction Line( geometry, material, mode ) {\n\n\tif ( mode === 1 ) {\n\n\t\tconsole.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );\n\n\t}\n\n\tObject3D.call( this );\n\n\tthis.type = 'Line';\n\n\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\tthis.material = material !== undefined ? material : new LineBasicMaterial();\n\n\tthis.updateMorphTargets();\n\n}\n\nLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Line,\n\n\tisLine: true,\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t},\n\n\tcomputeLineDistances: function () {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t// we assume non-indexed geometry\n\n\t\t\tif ( geometry.index === null ) {\n\n\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\t\tconst lineDistances = [ 0 ];\n\n\t\t\t\tfor ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t_start.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t\t_end.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\t\tlineDistances[ i ] += _start.distanceTo( _end );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tconst vertices = geometry.vertices;\n\t\t\tconst lineDistances = geometry.lineDistances;\n\n\t\t\tlineDistances[ 0 ] = 0;\n\n\t\t\tfor ( let i = 1, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\traycast: function ( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Line.threshold;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.getInverse( matrixWorld );\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst vStart = new Vector3();\n\t\tconst vEnd = new Vector3();\n\t\tconst interSegment = new Vector3();\n\t\tconst interRay = new Vector3();\n\t\tconst step = this.isLineSegments ? 2 : 1;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst attributes = geometry.attributes;\n\t\t\tconst positionAttribute = attributes.position;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tconst indices = index.array;\n\n\t\t\t\tfor ( let i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\tconst a = indices[ i ];\n\t\t\t\t\tconst b = indices[ i + 1 ];\n\n\t\t\t\t\tvStart.fromBufferAttribute( positionAttribute, a );\n\t\t\t\t\tvEnd.fromBufferAttribute( positionAttribute, b );\n\n\t\t\t\t\tconst distSq = _ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > localThresholdSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tconst distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = positionAttribute.count - 1; i < l; i += step ) {\n\n\t\t\t\t\tvStart.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\tvEnd.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\t\tconst distSq = _ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > localThresholdSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tconst distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( geometry.isGeometry ) {\n\n\t\t\tconst vertices = geometry.vertices;\n\t\t\tconst nbVertices = vertices.length;\n\n\t\t\tfor ( let i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\tconst distSq = _ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\tif ( distSq > localThresholdSq ) continue;\n\n\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\tconst distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\tindex: i,\n\t\t\t\t\tface: null,\n\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\tobject: this\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\tconst keys = Object.keys( morphAttributes );\n\n\t\t\tif ( keys.length > 0 ) {\n\n\t\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { Line };\n"]},"metadata":{},"sourceType":"module"}