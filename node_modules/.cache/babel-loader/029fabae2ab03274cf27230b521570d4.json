{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nvar _v0 = new Vector3();\n\nvar _v1 = new Vector3();\n\nvar _normal = new Vector3();\n\nvar _triangle = new Triangle();\n\nclass EdgesGeometry extends BufferGeometry {\n  constructor(geometry, thresholdAngle) {\n    super();\n    this.type = 'EdgesGeometry';\n    this.parameters = {\n      thresholdAngle: thresholdAngle\n    };\n    thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;\n\n    if (geometry.isGeometry) {\n      geometry = new BufferGeometry().fromGeometry(geometry);\n    }\n\n    var precisionPoints = 4;\n    var precision = Math.pow(10, precisionPoints);\n    var thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);\n    var indexAttr = geometry.getIndex();\n    var positionAttr = geometry.getAttribute('position');\n    var indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n    var indexArr = [0, 0, 0];\n    var vertKeys = ['a', 'b', 'c'];\n    var hashes = new Array(3);\n    var edgeData = {};\n    var vertices = [];\n\n    for (var i = 0; i < indexCount; i += 3) {\n      if (indexAttr) {\n        indexArr[0] = indexAttr.getX(i);\n        indexArr[1] = indexAttr.getX(i + 1);\n        indexArr[2] = indexAttr.getX(i + 2);\n      } else {\n        indexArr[0] = i;\n        indexArr[1] = i + 1;\n        indexArr[2] = i + 2;\n      }\n\n      var a = _triangle.a,\n          b = _triangle.b,\n          c = _triangle.c;\n      a.fromBufferAttribute(positionAttr, indexArr[0]);\n      b.fromBufferAttribute(positionAttr, indexArr[1]);\n      c.fromBufferAttribute(positionAttr, indexArr[2]);\n\n      _triangle.getNormal(_normal); // create hashes for the edge from the vertices\n\n\n      hashes[0] = \"\".concat(Math.round(a.x * precision), \",\").concat(Math.round(a.y * precision), \",\").concat(Math.round(a.z * precision));\n      hashes[1] = \"\".concat(Math.round(b.x * precision), \",\").concat(Math.round(b.y * precision), \",\").concat(Math.round(b.z * precision));\n      hashes[2] = \"\".concat(Math.round(c.x * precision), \",\").concat(Math.round(c.y * precision), \",\").concat(Math.round(c.z * precision)); // skip degenerate triangles\n\n      if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {\n        continue;\n      } // iterate over every edge\n\n\n      for (var j = 0; j < 3; j++) {\n        // get the first and next vertex making up the edge\n        var jNext = (j + 1) % 3;\n        var vecHash0 = hashes[j];\n        var vecHash1 = hashes[jNext];\n        var v0 = _triangle[vertKeys[j]];\n        var v1 = _triangle[vertKeys[jNext]];\n        var hash = \"\".concat(vecHash0, \"_\").concat(vecHash1);\n        var reverseHash = \"\".concat(vecHash1, \"_\").concat(vecHash0);\n\n        if (reverseHash in edgeData && edgeData[reverseHash]) {\n          // if we found a sibling edge add it into the vertex array if\n          // it meets the angle threshold and delete the edge from the map.\n          if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {\n            vertices.push(v0.x, v0.y, v0.z);\n            vertices.push(v1.x, v1.y, v1.z);\n          }\n\n          edgeData[reverseHash] = null;\n        } else if (!(hash in edgeData)) {\n          // if we've already got an edge here then skip adding a new one\n          edgeData[hash] = {\n            index0: indexArr[j],\n            index1: indexArr[jNext],\n            normal: _normal.clone()\n          };\n        }\n      }\n    } // iterate over all remaining, unmatched edges and add them to the vertex array\n\n\n    for (var key in edgeData) {\n      if (edgeData[key]) {\n        var _edgeData$key = edgeData[key],\n            index0 = _edgeData$key.index0,\n            index1 = _edgeData$key.index1;\n\n        _v0.fromBufferAttribute(positionAttr, index0);\n\n        _v1.fromBufferAttribute(positionAttr, index1);\n\n        vertices.push(_v0.x, _v0.y, _v0.z);\n        vertices.push(_v1.x, _v1.y, _v1.z);\n      }\n    }\n\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n  }\n\n}\n\nexport { EdgesGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/EdgesGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","MathUtils","Triangle","Vector3","_v0","_v1","_normal","_triangle","EdgesGeometry","constructor","geometry","thresholdAngle","type","parameters","undefined","isGeometry","fromGeometry","precisionPoints","precision","Math","pow","thresholdDot","cos","DEG2RAD","indexAttr","getIndex","positionAttr","getAttribute","indexCount","count","indexArr","vertKeys","hashes","Array","edgeData","vertices","i","getX","a","b","c","fromBufferAttribute","getNormal","round","x","y","z","j","jNext","vecHash0","vecHash1","v0","v1","hash","reverseHash","dot","normal","push","index0","index1","clone","key","setAttribute"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nconst _v0 = new Vector3();\nconst _v1 = new Vector3();\nconst _normal = new Vector3();\nconst _triangle = new Triangle();\n\nclass EdgesGeometry extends BufferGeometry {\n\n\tconstructor( geometry, thresholdAngle ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'EdgesGeometry';\n\n\t\tthis.parameters = {\n\t\t\tthresholdAngle: thresholdAngle\n\t\t};\n\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\t\tif ( geometry.isGeometry ) {\n\n\t\t\tgeometry = new BufferGeometry().fromGeometry( geometry );\n\n\t\t}\n\n\t\tconst precisionPoints = 4;\n\t\tconst precision = Math.pow( 10, precisionPoints );\n\t\tconst thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );\n\n\t\tconst indexAttr = geometry.getIndex();\n\t\tconst positionAttr = geometry.getAttribute( 'position' );\n\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\n\t\tconst indexArr = [ 0, 0, 0 ];\n\t\tconst vertKeys = [ 'a', 'b', 'c' ];\n\t\tconst hashes = new Array( 3 );\n\n\t\tconst edgeData = {};\n\t\tconst vertices = [];\n\t\tfor ( let i = 0; i < indexCount; i += 3 ) {\n\n\t\t\tif ( indexAttr ) {\n\n\t\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\n\t\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\n\t\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\n\n\t\t\t} else {\n\n\t\t\t\tindexArr[ 0 ] = i;\n\t\t\t\tindexArr[ 1 ] = i + 1;\n\t\t\t\tindexArr[ 2 ] = i + 2;\n\n\t\t\t}\n\n\t\t\tconst { a, b, c } = _triangle;\n\t\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\n\t\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\n\t\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\n\t\t\t_triangle.getNormal( _normal );\n\n\t\t\t// create hashes for the edge from the vertices\n\t\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\n\t\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\n\t\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\n\n\t\t\t// skip degenerate triangles\n\t\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// iterate over every edge\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\tconst jNext = ( j + 1 ) % 3;\n\t\t\t\tconst vecHash0 = hashes[ j ];\n\t\t\t\tconst vecHash1 = hashes[ jNext ];\n\t\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\n\t\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\n\n\t\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\n\t\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\n\n\t\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\n\n\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\tif ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {\n\n\t\t\t\t\t\tvertices.push( v0.x, v0.y, v0.z );\n\t\t\t\t\t\tvertices.push( v1.x, v1.y, v1.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tedgeData[ reverseHash ] = null;\n\n\t\t\t\t} else if ( ! ( hash in edgeData ) ) {\n\n\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\tedgeData[ hash ] = {\n\n\t\t\t\t\t\tindex0: indexArr[ j ],\n\t\t\t\t\t\tindex1: indexArr[ jNext ],\n\t\t\t\t\t\tnormal: _normal.clone(),\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// iterate over all remaining, unmatched edges and add them to the vertex array\n\t\tfor ( const key in edgeData ) {\n\n\t\t\tif ( edgeData[ key ] ) {\n\n\t\t\t\tconst { index0, index1 } = edgeData[ key ];\n\t\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\n\t\t\t\t_v1.fromBufferAttribute( positionAttr, index1 );\n\n\t\t\t\tvertices.push( _v0.x, _v0.y, _v0.z );\n\t\t\t\tvertices.push( _v1.x, _v1.y, _v1.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t}\n\n}\n\nexport { EdgesGeometry };\n"]},"metadata":{},"sourceType":"module"}