{"ast":null,"code":"// Characters [].:/ are reserved for track binding syntax.\nvar _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\n\nvar _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\n\n\nvar _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\n\nvar _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\n\n\nvar _directoryRe = /((?:WC+[\\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\n\n\nvar _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\n\n\nvar _objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\n\n\nvar _propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace('WC', _wordChar);\n\nvar _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');\n\nvar _supportedObjectNames = ['material', 'materials', 'bones'];\n\nfunction Composite(targetGroup, path, optionalParsedPath) {\n  var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);\n  this._targetGroup = targetGroup;\n  this._bindings = targetGroup.subscribe_(path, parsedPath);\n}\n\nObject.assign(Composite.prototype, {\n  getValue: function getValue(array, offset) {\n    this.bind(); // bind all binding\n\n    var firstValidIndex = this._targetGroup.nCachedObjects_,\n        binding = this._bindings[firstValidIndex]; // and only call .getValue on the first\n\n    if (binding !== undefined) binding.getValue(array, offset);\n  },\n  setValue: function setValue(array, offset) {\n    var bindings = this._bindings;\n\n    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].setValue(array, offset);\n    }\n  },\n  bind: function bind() {\n    var bindings = this._bindings;\n\n    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].bind();\n    }\n  },\n  unbind: function unbind() {\n    var bindings = this._bindings;\n\n    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].unbind();\n    }\n  }\n});\n\nfunction PropertyBinding(rootNode, path, parsedPath) {\n  this.path = path;\n  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);\n  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;\n  this.rootNode = rootNode;\n}\n\nObject.assign(PropertyBinding, {\n  Composite: Composite,\n  create: function create(root, path, parsedPath) {\n    if (!(root && root.isAnimationObjectGroup)) {\n      return new PropertyBinding(root, path, parsedPath);\n    } else {\n      return new PropertyBinding.Composite(root, path, parsedPath);\n    }\n  },\n\n  /**\n   * Replaces spaces with underscores and removes unsupported characters from\n   * node names, to ensure compatibility with parseTrackName().\n   *\n   * @param {string} name Node name to be sanitized.\n   * @return {string}\n   */\n  sanitizeNodeName: function sanitizeNodeName(name) {\n    return name.replace(/\\s/g, '_').replace(_reservedRe, '');\n  },\n  parseTrackName: function parseTrackName(trackName) {\n    var matches = _trackRe.exec(trackName);\n\n    if (!matches) {\n      throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);\n    }\n\n    var results = {\n      // directoryName: matches[ 1 ], // (tschw) currently unused\n      nodeName: matches[2],\n      objectName: matches[3],\n      objectIndex: matches[4],\n      propertyName: matches[5],\n      // required\n      propertyIndex: matches[6]\n    };\n    var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');\n\n    if (lastDot !== undefined && lastDot !== -1) {\n      var objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there\n      // is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n      // 'bar' could be the objectName, or part of a nodeName (which can\n      // include '.' characters).\n\n      if (_supportedObjectNames.indexOf(objectName) !== -1) {\n        results.nodeName = results.nodeName.substring(0, lastDot);\n        results.objectName = objectName;\n      }\n    }\n\n    if (results.propertyName === null || results.propertyName.length === 0) {\n      throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);\n    }\n\n    return results;\n  },\n  findNode: function findNode(root, nodeName) {\n    if (!nodeName || nodeName === \"\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {\n      return root;\n    } // search into skeleton bones.\n\n\n    if (root.skeleton) {\n      var bone = root.skeleton.getBoneByName(nodeName);\n\n      if (bone !== undefined) {\n        return bone;\n      }\n    } // search into node subtree.\n\n\n    if (root.children) {\n      var searchNodeSubtree = function searchNodeSubtree(children) {\n        for (var i = 0; i < children.length; i++) {\n          var childNode = children[i];\n\n          if (childNode.name === nodeName || childNode.uuid === nodeName) {\n            return childNode;\n          }\n\n          var result = searchNodeSubtree(childNode.children);\n          if (result) return result;\n        }\n\n        return null;\n      };\n\n      var subTreeNode = searchNodeSubtree(root.children);\n\n      if (subTreeNode) {\n        return subTreeNode;\n      }\n    }\n\n    return null;\n  }\n});\nObject.assign(PropertyBinding.prototype, {\n  // prototype, continued\n  // these are used to \"bind\" a nonexistent property\n  _getValue_unavailable: function _getValue_unavailable() {},\n  _setValue_unavailable: function _setValue_unavailable() {},\n  BindingType: {\n    Direct: 0,\n    EntireArray: 1,\n    ArrayElement: 2,\n    HasFromToArray: 3\n  },\n  Versioning: {\n    None: 0,\n    NeedsUpdate: 1,\n    MatrixWorldNeedsUpdate: 2\n  },\n  GetterByBindingType: [function getValue_direct(buffer, offset) {\n    buffer[offset] = this.node[this.propertyName];\n  }, function getValue_array(buffer, offset) {\n    var source = this.resolvedProperty;\n\n    for (var i = 0, n = source.length; i !== n; ++i) {\n      buffer[offset++] = source[i];\n    }\n  }, function getValue_arrayElement(buffer, offset) {\n    buffer[offset] = this.resolvedProperty[this.propertyIndex];\n  }, function getValue_toArray(buffer, offset) {\n    this.resolvedProperty.toArray(buffer, offset);\n  }],\n  SetterByBindingTypeAndVersioning: [[// Direct\n  function setValue_direct(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n  }, function setValue_direct_setNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }, function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }], [// EntireArray\n  function setValue_array(buffer, offset) {\n    var dest = this.resolvedProperty;\n\n    for (var i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n  }, function setValue_array_setNeedsUpdate(buffer, offset) {\n    var dest = this.resolvedProperty;\n\n    for (var i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n\n    this.targetObject.needsUpdate = true;\n  }, function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {\n    var dest = this.resolvedProperty;\n\n    for (var i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }], [// ArrayElement\n  function setValue_arrayElement(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n  }, function setValue_arrayElement_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }], [// HasToFromArray\n  function setValue_fromArray(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n  }, function setValue_fromArray_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.needsUpdate = true;\n  }, function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }]],\n  getValue: function getValue_unbound(targetArray, offset) {\n    this.bind();\n    this.getValue(targetArray, offset); // Note: This class uses a State pattern on a per-method basis:\n    // 'bind' sets 'this.getValue' / 'setValue' and shadows the\n    // prototype version of these methods with one that represents\n    // the bound state. When the property is not found, the methods\n    // become no-ops.\n  },\n  setValue: function getValue_unbound(sourceArray, offset) {\n    this.bind();\n    this.setValue(sourceArray, offset);\n  },\n  // create getter / setter pair for a property in the scene graph\n  bind: function bind() {\n    var targetObject = this.node;\n    var parsedPath = this.parsedPath;\n    var objectName = parsedPath.objectName;\n    var propertyName = parsedPath.propertyName;\n    var propertyIndex = parsedPath.propertyIndex;\n\n    if (!targetObject) {\n      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;\n      this.node = targetObject;\n    } // set fail state so we can just 'return' on error\n\n\n    this.getValue = this._getValue_unavailable;\n    this.setValue = this._setValue_unavailable; // ensure there is a value node\n\n    if (!targetObject) {\n      console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.');\n      return;\n    }\n\n    if (objectName) {\n      var objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....\n\n      switch (objectName) {\n        case 'materials':\n          if (!targetObject.material) {\n            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);\n            return;\n          }\n\n          if (!targetObject.material.materials) {\n            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);\n            return;\n          }\n\n          targetObject = targetObject.material.materials;\n          break;\n\n        case 'bones':\n          if (!targetObject.skeleton) {\n            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);\n            return;\n          } // potential future optimization: skip this if propertyIndex is already an integer\n          // and convert the integer string to a true integer.\n\n\n          targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.\n\n          for (var i = 0; i < targetObject.length; i++) {\n            if (targetObject[i].name === objectIndex) {\n              objectIndex = i;\n              break;\n            }\n          }\n\n          break;\n\n        default:\n          if (targetObject[objectName] === undefined) {\n            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);\n            return;\n          }\n\n          targetObject = targetObject[objectName];\n      }\n\n      if (objectIndex !== undefined) {\n        if (targetObject[objectIndex] === undefined) {\n          console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);\n          return;\n        }\n\n        targetObject = targetObject[objectIndex];\n      }\n    } // resolve property\n\n\n    var nodeProperty = targetObject[propertyName];\n\n    if (nodeProperty === undefined) {\n      var nodeName = parsedPath.nodeName;\n      console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\\'t found.', targetObject);\n      return;\n    } // determine versioning scheme\n\n\n    var versioning = this.Versioning.None;\n    this.targetObject = targetObject;\n\n    if (targetObject.needsUpdate !== undefined) {\n      // material\n      versioning = this.Versioning.NeedsUpdate;\n    } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {\n      // node transform\n      versioning = this.Versioning.MatrixWorldNeedsUpdate;\n    } // determine how the property gets bound\n\n\n    var bindingType = this.BindingType.Direct;\n\n    if (propertyIndex !== undefined) {\n      // access a sub element of the property array (only primitives are supported right now)\n      if (propertyName === \"morphTargetInfluences\") {\n        // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n        // support resolving morphTarget names into indices.\n        if (!targetObject.geometry) {\n          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);\n          return;\n        }\n\n        if (targetObject.geometry.isBufferGeometry) {\n          if (!targetObject.geometry.morphAttributes) {\n            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);\n            return;\n          }\n\n          if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {\n            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];\n          }\n        } else {\n          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);\n          return;\n        }\n      }\n\n      bindingType = this.BindingType.ArrayElement;\n      this.resolvedProperty = nodeProperty;\n      this.propertyIndex = propertyIndex;\n    } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {\n      // must use copy for Object3D.Euler/Quaternion\n      bindingType = this.BindingType.HasFromToArray;\n      this.resolvedProperty = nodeProperty;\n    } else if (Array.isArray(nodeProperty)) {\n      bindingType = this.BindingType.EntireArray;\n      this.resolvedProperty = nodeProperty;\n    } else {\n      this.propertyName = propertyName;\n    } // select getter / setter\n\n\n    this.getValue = this.GetterByBindingType[bindingType];\n    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n  },\n  unbind: function unbind() {\n    this.node = null; // back to the prototype version of getValue / setValue\n    // note: avoiding to mutate the shape of 'this' via 'delete'\n\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n}); // DECLARE ALIAS AFTER assign prototype\n\nObject.assign(PropertyBinding.prototype, {\n  // initial state of these methods that calls 'bind'\n  _getValue_unbound: PropertyBinding.prototype.getValue,\n  _setValue_unbound: PropertyBinding.prototype.setValue\n});\nexport { PropertyBinding };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/animation/PropertyBinding.js"],"names":["_RESERVED_CHARS_RE","_reservedRe","RegExp","_wordChar","_wordCharOrDot","replace","_directoryRe","source","_nodeRe","_objectRe","_propertyRe","_trackRe","_supportedObjectNames","Composite","targetGroup","path","optionalParsedPath","parsedPath","PropertyBinding","parseTrackName","_targetGroup","_bindings","subscribe_","Object","assign","prototype","getValue","array","offset","bind","firstValidIndex","nCachedObjects_","binding","undefined","setValue","bindings","i","n","length","unbind","rootNode","node","findNode","nodeName","create","root","isAnimationObjectGroup","sanitizeNodeName","name","trackName","matches","exec","Error","results","objectName","objectIndex","propertyName","propertyIndex","lastDot","lastIndexOf","substring","indexOf","uuid","skeleton","bone","getBoneByName","children","searchNodeSubtree","childNode","result","subTreeNode","_getValue_unavailable","_setValue_unavailable","BindingType","Direct","EntireArray","ArrayElement","HasFromToArray","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","GetterByBindingType","getValue_direct","buffer","getValue_array","resolvedProperty","getValue_arrayElement","getValue_toArray","toArray","SetterByBindingTypeAndVersioning","setValue_direct","targetObject","setValue_direct_setNeedsUpdate","needsUpdate","setValue_direct_setMatrixWorldNeedsUpdate","matrixWorldNeedsUpdate","setValue_array","dest","setValue_array_setNeedsUpdate","setValue_array_setMatrixWorldNeedsUpdate","setValue_arrayElement","setValue_arrayElement_setNeedsUpdate","setValue_arrayElement_setMatrixWorldNeedsUpdate","setValue_fromArray","fromArray","setValue_fromArray_setNeedsUpdate","setValue_fromArray_setMatrixWorldNeedsUpdate","getValue_unbound","targetArray","sourceArray","console","error","material","materials","bones","nodeProperty","versioning","bindingType","geometry","isBufferGeometry","morphAttributes","morphTargetDictionary","Array","isArray","_getValue_unbound","_setValue_unbound"],"mappings":"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","sourcesContent":["// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /((?:WC+[\\/:])*)/.source.replace( 'WC', _wordChar );\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', _wordChar );\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', _wordChar );\n\nconst _trackRe = new RegExp( ''\n\t+ '^'\n\t+ _directoryRe\n\t+ _nodeRe\n\t+ _objectRe\n\t+ _propertyRe\n\t+ '$'\n);\n\nconst _supportedObjectNames = [ 'material', 'materials', 'bones' ];\n\nfunction Composite( targetGroup, path, optionalParsedPath ) {\n\n\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\tthis._targetGroup = targetGroup;\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n}\n\nObject.assign( Composite.prototype, {\n\n\tgetValue: function ( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t},\n\n\tsetValue: function ( array, offset ) {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t},\n\n\tbind: function () {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t},\n\n\tunbind: function () {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n} );\n\n\nfunction PropertyBinding( rootNode, path, parsedPath ) {\n\n\tthis.path = path;\n\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\n\n\tthis.rootNode = rootNode;\n\n}\n\nObject.assign( PropertyBinding, {\n\n\tComposite: Composite,\n\n\tcreate: function ( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param {string} name Node name to be sanitized.\n\t * @return {string}\n\t */\n\tsanitizeNodeName: function ( name ) {\n\n\t\treturn name.replace( /\\s/g, '_' ).replace( _reservedRe, '' );\n\n\t},\n\n\tparseTrackName: function ( trackName ) {\n\n\t\tconst matches = _trackRe.exec( trackName );\n\n\t\tif ( ! matches ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t}\n\n\t\tconst results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ],\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\tpropertyIndex: matches[ 6 ]\n\t\t};\n\n\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\tconst objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t// Object names must be checked against an allowlist. Otherwise, there\n\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t// include '.' characters).\n\t\t\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\tresults.objectName = objectName;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t},\n\n\tfindNode: function ( root, nodeName ) {\n\n\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \".\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tconst bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tconst searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tconst childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tconst subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n} );\n\nObject.assign( PropertyBinding.prototype, { // prototype, continued\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable: function () {},\n\t_setValue_unavailable: function () {},\n\n\tBindingType: {\n\t\tDirect: 0,\n\t\tEntireArray: 1,\n\t\tArrayElement: 2,\n\t\tHasFromToArray: 3\n\t},\n\n\tVersioning: {\n\t\tNone: 0,\n\t\tNeedsUpdate: 1,\n\t\tMatrixWorldNeedsUpdate: 2\n\t},\n\n\tGetterByBindingType: [\n\n\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t},\n\n\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\tconst source = this.resolvedProperty;\n\n\t\t\tfor ( let i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t}\n\n\t\t},\n\n\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t},\n\n\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t}\n\n\t],\n\n\tSetterByBindingTypeAndVersioning: [\n\n\t\t[\n\t\t\t// Direct\n\n\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// EntireArray\n\n\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// ArrayElement\n\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// HasToFromArray\n\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t]\n\n\t],\n\n\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t// prototype version of these methods with one that represents\n\t\t// the bound state. When the property is not found, the methods\n\t\t// become no-ops.\n\n\t},\n\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t},\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind: function () {\n\n\t\tlet targetObject = this.node;\n\t\tconst parsedPath = this.parsedPath;\n\n\t\tconst objectName = parsedPath.objectName;\n\t\tconst propertyName = parsedPath.propertyName;\n\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tlet objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( let i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tconst nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tconst nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tlet versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tlet bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.geometry.isBufferGeometry ) {\n\n\t\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\n\n\t\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t},\n\n\tunbind: function () {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n} );\n\n// DECLARE ALIAS AFTER assign prototype\nObject.assign( PropertyBinding.prototype, {\n\n\t// initial state of these methods that calls 'bind'\n\t_getValue_unbound: PropertyBinding.prototype.getValue,\n\t_setValue_unbound: PropertyBinding.prototype.setValue,\n\n} );\n\nexport { PropertyBinding };\n"]},"metadata":{},"sourceType":"module"}