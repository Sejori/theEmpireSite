{"ast":null,"code":"import { PropertyBinding } from './PropertyBinding.js';\nimport { MathUtils } from '../math/MathUtils.js';\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n */\n\nfunction AnimationObjectGroup() {\n  this.uuid = MathUtils.generateUUID(); // cached objects followed by the active ones\n\n  this._objects = Array.prototype.slice.call(arguments);\n  this.nCachedObjects_ = 0; // threshold\n  // note: read by PropertyBinding.Composite\n\n  var indices = {};\n  this._indicesByUUID = indices; // for bookkeeping\n\n  for (var i = 0, n = arguments.length; i !== n; ++i) {\n    indices[arguments[i].uuid] = i;\n  }\n\n  this._paths = []; // inside: string\n\n  this._parsedPaths = []; // inside: { we don't care, here }\n\n  this._bindings = []; // inside: Array< PropertyBinding >\n\n  this._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n  var scope = this;\n  this.stats = {\n    objects: {\n      get total() {\n        return scope._objects.length;\n      },\n\n      get inUse() {\n        return this.total - scope.nCachedObjects_;\n      }\n\n    },\n\n    get bindingsPerObject() {\n      return scope._bindings.length;\n    }\n\n  };\n}\n\nObject.assign(AnimationObjectGroup.prototype, {\n  isAnimationObjectGroup: true,\n  add: function add() {\n    var objects = this._objects,\n        indicesByUUID = this._indicesByUUID,\n        paths = this._paths,\n        parsedPaths = this._parsedPaths,\n        bindings = this._bindings,\n        nBindings = bindings.length;\n    var knownObject = undefined,\n        nObjects = objects.length,\n        nCachedObjects = this.nCachedObjects_;\n\n    for (var i = 0, n = arguments.length; i !== n; ++i) {\n      var object = arguments[i],\n          uuid = object.uuid;\n      var index = indicesByUUID[uuid];\n\n      if (index === undefined) {\n        // unknown object -> add it to the ACTIVE region\n        index = nObjects++;\n        indicesByUUID[uuid] = index;\n        objects.push(object); // accounting is done, now do the same for all bindings\n\n        for (var j = 0, m = nBindings; j !== m; ++j) {\n          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));\n        }\n      } else if (index < nCachedObjects) {\n        knownObject = objects[index]; // move existing object to the ACTIVE region\n\n        var firstActiveIndex = --nCachedObjects,\n            lastCachedObject = objects[firstActiveIndex];\n        indicesByUUID[lastCachedObject.uuid] = index;\n        objects[index] = lastCachedObject;\n        indicesByUUID[uuid] = firstActiveIndex;\n        objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings\n\n        for (var _j = 0, _m = nBindings; _j !== _m; ++_j) {\n          var bindingsForPath = bindings[_j],\n              lastCached = bindingsForPath[firstActiveIndex];\n          var binding = bindingsForPath[index];\n          bindingsForPath[index] = lastCached;\n\n          if (binding === undefined) {\n            // since we do not bother to create new bindings\n            // for objects that are cached, the binding may\n            // or may not exist\n            binding = new PropertyBinding(object, paths[_j], parsedPaths[_j]);\n          }\n\n          bindingsForPath[firstActiveIndex] = binding;\n        }\n      } else if (objects[index] !== knownObject) {\n        console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');\n      } // else the object is already where we want it to be\n\n    } // for arguments\n\n\n    this.nCachedObjects_ = nCachedObjects;\n  },\n  remove: function remove() {\n    var objects = this._objects,\n        indicesByUUID = this._indicesByUUID,\n        bindings = this._bindings,\n        nBindings = bindings.length;\n    var nCachedObjects = this.nCachedObjects_;\n\n    for (var i = 0, n = arguments.length; i !== n; ++i) {\n      var object = arguments[i],\n          uuid = object.uuid,\n          index = indicesByUUID[uuid];\n\n      if (index !== undefined && index >= nCachedObjects) {\n        // move existing object into the CACHED region\n        var lastCachedIndex = nCachedObjects++,\n            firstActiveObject = objects[lastCachedIndex];\n        indicesByUUID[firstActiveObject.uuid] = index;\n        objects[index] = firstActiveObject;\n        indicesByUUID[uuid] = lastCachedIndex;\n        objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings\n\n        for (var j = 0, m = nBindings; j !== m; ++j) {\n          var bindingsForPath = bindings[j],\n              firstActive = bindingsForPath[lastCachedIndex],\n              binding = bindingsForPath[index];\n          bindingsForPath[index] = firstActive;\n          bindingsForPath[lastCachedIndex] = binding;\n        }\n      }\n    } // for arguments\n\n\n    this.nCachedObjects_ = nCachedObjects;\n  },\n  // remove & forget\n  uncache: function uncache() {\n    var objects = this._objects,\n        indicesByUUID = this._indicesByUUID,\n        bindings = this._bindings,\n        nBindings = bindings.length;\n    var nCachedObjects = this.nCachedObjects_,\n        nObjects = objects.length;\n\n    for (var i = 0, n = arguments.length; i !== n; ++i) {\n      var object = arguments[i],\n          uuid = object.uuid,\n          index = indicesByUUID[uuid];\n\n      if (index !== undefined) {\n        delete indicesByUUID[uuid];\n\n        if (index < nCachedObjects) {\n          // object is cached, shrink the CACHED region\n          var firstActiveIndex = --nCachedObjects,\n              lastCachedObject = objects[firstActiveIndex],\n              lastIndex = --nObjects,\n              lastObject = objects[lastIndex]; // last cached object takes this object's place\n\n          indicesByUUID[lastCachedObject.uuid] = index;\n          objects[index] = lastCachedObject; // last object goes to the activated slot and pop\n\n          indicesByUUID[lastObject.uuid] = firstActiveIndex;\n          objects[firstActiveIndex] = lastObject;\n          objects.pop(); // accounting is done, now do the same for all bindings\n\n          for (var j = 0, m = nBindings; j !== m; ++j) {\n            var bindingsForPath = bindings[j],\n                lastCached = bindingsForPath[firstActiveIndex],\n                last = bindingsForPath[lastIndex];\n            bindingsForPath[index] = lastCached;\n            bindingsForPath[firstActiveIndex] = last;\n            bindingsForPath.pop();\n          }\n        } else {\n          // object is active, just swap with the last and pop\n          var _lastIndex = --nObjects,\n              _lastObject = objects[_lastIndex];\n\n          indicesByUUID[_lastObject.uuid] = index;\n          objects[index] = _lastObject;\n          objects.pop(); // accounting is done, now do the same for all bindings\n\n          for (var _j2 = 0, _m2 = nBindings; _j2 !== _m2; ++_j2) {\n            var _bindingsForPath = bindings[_j2];\n            _bindingsForPath[index] = _bindingsForPath[_lastIndex];\n\n            _bindingsForPath.pop();\n          }\n        } // cached or active\n\n      } // if object is known\n\n    } // for arguments\n\n\n    this.nCachedObjects_ = nCachedObjects;\n  },\n  // Internal interface used by befriended PropertyBinding.Composite:\n  subscribe_: function subscribe_(path, parsedPath) {\n    // returns an array of bindings for the given path that is changed\n    // according to the contained objects in the group\n    var indicesByPath = this._bindingsIndicesByPath;\n    var index = indicesByPath[path];\n    var bindings = this._bindings;\n    if (index !== undefined) return bindings[index];\n    var paths = this._paths,\n        parsedPaths = this._parsedPaths,\n        objects = this._objects,\n        nObjects = objects.length,\n        nCachedObjects = this.nCachedObjects_,\n        bindingsForPath = new Array(nObjects);\n    index = bindings.length;\n    indicesByPath[path] = index;\n    paths.push(path);\n    parsedPaths.push(parsedPath);\n    bindings.push(bindingsForPath);\n\n    for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {\n      var object = objects[i];\n      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);\n    }\n\n    return bindingsForPath;\n  },\n  unsubscribe_: function unsubscribe_(path) {\n    // tells the group to forget about a property path and no longer\n    // update the array previously obtained with 'subscribe_'\n    var indicesByPath = this._bindingsIndicesByPath,\n        index = indicesByPath[path];\n\n    if (index !== undefined) {\n      var paths = this._paths,\n          parsedPaths = this._parsedPaths,\n          bindings = this._bindings,\n          lastBindingsIndex = bindings.length - 1,\n          lastBindings = bindings[lastBindingsIndex],\n          lastBindingsPath = path[lastBindingsIndex];\n      indicesByPath[lastBindingsPath] = index;\n      bindings[index] = lastBindings;\n      bindings.pop();\n      parsedPaths[index] = parsedPaths[lastBindingsIndex];\n      parsedPaths.pop();\n      paths[index] = paths[lastBindingsIndex];\n      paths.pop();\n    }\n  }\n});\nexport { AnimationObjectGroup };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/animation/AnimationObjectGroup.js"],"names":["PropertyBinding","MathUtils","AnimationObjectGroup","uuid","generateUUID","_objects","Array","prototype","slice","call","arguments","nCachedObjects_","indices","_indicesByUUID","i","n","length","_paths","_parsedPaths","_bindings","_bindingsIndicesByPath","scope","stats","objects","total","inUse","bindingsPerObject","Object","assign","isAnimationObjectGroup","add","indicesByUUID","paths","parsedPaths","bindings","nBindings","knownObject","undefined","nObjects","nCachedObjects","object","index","push","j","m","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","binding","console","error","remove","lastCachedIndex","firstActiveObject","firstActive","uncache","lastIndex","lastObject","pop","last","subscribe_","path","parsedPath","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath"],"mappings":"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","sourcesContent":["import { PropertyBinding } from './PropertyBinding.js';\nimport { MathUtils } from '../math/MathUtils.js';\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n */\n\nfunction AnimationObjectGroup() {\n\n\tthis.uuid = MathUtils.generateUUID();\n\n\t// cached objects followed by the active ones\n\tthis._objects = Array.prototype.slice.call( arguments );\n\n\tthis.nCachedObjects_ = 0; // threshold\n\t// note: read by PropertyBinding.Composite\n\n\tconst indices = {};\n\tthis._indicesByUUID = indices; // for bookkeeping\n\n\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t}\n\n\tthis._paths = []; // inside: string\n\tthis._parsedPaths = []; // inside: { we don't care, here }\n\tthis._bindings = []; // inside: Array< PropertyBinding >\n\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\tconst scope = this;\n\n\tthis.stats = {\n\n\t\tobjects: {\n\t\t\tget total() {\n\n\t\t\t\treturn scope._objects.length;\n\n\t\t\t},\n\t\t\tget inUse() {\n\n\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t}\n\t\t},\n\t\tget bindingsPerObject() {\n\n\t\t\treturn scope._bindings.length;\n\n\t\t}\n\n\t};\n\n}\n\nObject.assign( AnimationObjectGroup.prototype, {\n\n\tisAnimationObjectGroup: true,\n\n\tadd: function () {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet knownObject = undefined,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid;\n\t\t\tlet index = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ];\n\n\t\t\t\t\tlet binding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\tremove: function () {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tconst lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// remove & forget\n\tuncache: function () {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_,\n\t\t\tnObjects = objects.length;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tconst lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_: function ( path, parsedPath ) {\n\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath;\n\t\tlet index = indicesByPath[ path ];\n\t\tconst bindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tconst paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\tconst object = objects[ i ];\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t},\n\n\tunsubscribe_: function ( path ) {\n\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { AnimationObjectGroup };\n"]},"metadata":{},"sourceType":"module"}