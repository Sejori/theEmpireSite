{"ast":null,"code":"import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { PointsMaterial } from '../materials/PointsMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\nvar _inverseMatrix = new Matrix4();\n\nvar _ray = new Ray();\n\nvar _sphere = new Sphere();\n\nvar _position = new Vector3();\n\nfunction Points(geometry, material) {\n  Object3D.call(this);\n  this.type = 'Points';\n  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n  this.material = material !== undefined ? material : new PointsMaterial();\n  this.updateMorphTargets();\n}\n\nPoints.prototype = Object.assign(Object.create(Object3D.prototype), {\n  constructor: Points,\n  isPoints: true,\n  copy: function copy(source) {\n    Object3D.prototype.copy.call(this, source);\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  },\n  raycast: function raycast(raycaster, intersects) {\n    var geometry = this.geometry;\n    var matrixWorld = this.matrixWorld;\n    var threshold = raycaster.params.Points.threshold; // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere.copy(geometry.boundingSphere);\n\n    _sphere.applyMatrix4(matrixWorld);\n\n    _sphere.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n    _inverseMatrix.getInverse(matrixWorld);\n\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    var localThresholdSq = localThreshold * localThreshold;\n\n    if (geometry.isBufferGeometry) {\n      var index = geometry.index;\n      var attributes = geometry.attributes;\n      var positionAttribute = attributes.position;\n\n      if (index !== null) {\n        var indices = index.array;\n\n        for (var i = 0, il = indices.length; i < il; i++) {\n          var a = indices[i];\n\n          _position.fromBufferAttribute(positionAttribute, a);\n\n          testPoint(_position, a, localThresholdSq, matrixWorld, raycaster, intersects, this);\n        }\n      } else {\n        for (var _i = 0, l = positionAttribute.count; _i < l; _i++) {\n          _position.fromBufferAttribute(positionAttribute, _i);\n\n          testPoint(_position, _i, localThresholdSq, matrixWorld, raycaster, intersects, this);\n        }\n      }\n    } else {\n      var vertices = geometry.vertices;\n\n      for (var _i2 = 0, _l = vertices.length; _i2 < _l; _i2++) {\n        testPoint(vertices[_i2], _i2, localThresholdSq, matrixWorld, raycaster, intersects, this);\n      }\n    }\n  },\n  updateMorphTargets: function updateMorphTargets() {\n    var geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      var morphAttributes = geometry.morphAttributes;\n      var keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        var morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (var m = 0, ml = morphAttribute.length; m < ml; m++) {\n            var name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      var morphTargets = geometry.morphTargets;\n\n      if (morphTargets !== undefined && morphTargets.length > 0) {\n        console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');\n      }\n    }\n  }\n});\n\nfunction testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {\n  var rayPointDistanceSq = _ray.distanceSqToPoint(point);\n\n  if (rayPointDistanceSq < localThresholdSq) {\n    var intersectPoint = new Vector3();\n\n    _ray.closestPointToPoint(point, intersectPoint);\n\n    intersectPoint.applyMatrix4(matrixWorld);\n    var distance = raycaster.ray.origin.distanceTo(intersectPoint);\n    if (distance < raycaster.near || distance > raycaster.far) return;\n    intersects.push({\n      distance: distance,\n      distanceToRay: Math.sqrt(rayPointDistanceSq),\n      point: intersectPoint,\n      index: index,\n      face: null,\n      object: object\n    });\n  }\n}\n\nexport { Points };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/objects/Points.js"],"names":["Sphere","Ray","Matrix4","Object3D","Vector3","PointsMaterial","BufferGeometry","_inverseMatrix","_ray","_sphere","_position","Points","geometry","material","call","type","undefined","updateMorphTargets","prototype","Object","assign","create","constructor","isPoints","copy","source","raycast","raycaster","intersects","matrixWorld","threshold","params","boundingSphere","computeBoundingSphere","applyMatrix4","radius","ray","intersectsSphere","getInverse","localThreshold","scale","x","y","z","localThresholdSq","isBufferGeometry","index","attributes","positionAttribute","position","indices","array","i","il","length","a","fromBufferAttribute","testPoint","l","count","vertices","morphAttributes","keys","morphAttribute","morphTargetInfluences","morphTargetDictionary","m","ml","name","String","push","morphTargets","console","error","point","object","rayPointDistanceSq","distanceSqToPoint","intersectPoint","closestPointToPoint","distance","origin","distanceTo","near","far","distanceToRay","Math","sqrt","face"],"mappings":"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","sourcesContent":["import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { PointsMaterial } from '../materials/PointsMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\nconst _inverseMatrix = new Matrix4();\nconst _ray = new Ray();\nconst _sphere = new Sphere();\nconst _position = new Vector3();\n\nfunction Points( geometry, material ) {\n\n\tObject3D.call( this );\n\n\tthis.type = 'Points';\n\n\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n\tthis.material = material !== undefined ? material : new PointsMaterial();\n\n\tthis.updateMorphTargets();\n\n}\n\nPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n\tconstructor: Points,\n\n\tisPoints: true,\n\n\tcopy: function ( source ) {\n\n\t\tObject3D.prototype.copy.call( this, source );\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t},\n\n\traycast: function ( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Points.threshold;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.getInverse( matrixWorld );\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst attributes = geometry.attributes;\n\t\t\tconst positionAttribute = attributes.position;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tconst indices = index.array;\n\n\t\t\t\tfor ( let i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst a = indices[ i ];\n\n\t\t\t\t\t_position.fromBufferAttribute( positionAttribute, a );\n\n\t\t\t\t\ttestPoint( _position, a, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t_position.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\ttestPoint( _position, i, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst vertices = geometry.vertices;\n\n\t\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\ttestPoint( vertices[ i ], i, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\tconst keys = Object.keys( morphAttributes );\n\n\t\t\tif ( keys.length > 0 ) {\n\n\t\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n\t\t\t\tconsole.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n} );\n\nfunction testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {\n\n\tconst rayPointDistanceSq = _ray.distanceSqToPoint( point );\n\n\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\tconst intersectPoint = new Vector3();\n\n\t\t_ray.closestPointToPoint( point, intersectPoint );\n\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\tpoint: intersectPoint,\n\t\t\tindex: index,\n\t\t\tface: null,\n\t\t\tobject: object\n\n\t\t} );\n\n\t}\n\n}\n\nexport { Points };\n"]},"metadata":{},"sourceType":"module"}