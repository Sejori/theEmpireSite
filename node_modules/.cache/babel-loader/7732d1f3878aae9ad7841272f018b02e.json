{"ast":null,"code":"import { Matrix3 } from './Matrix3.js';\nimport { Vector3 } from './Vector3.js';\n\nvar _vector1 = /*@__PURE__*/new Vector3();\n\nvar _vector2 = /*@__PURE__*/new Vector3();\n\nvar _normalMatrix = /*@__PURE__*/new Matrix3();\n\nclass Plane {\n  constructor(normal, constant) {\n    Object.defineProperty(this, 'isPlane', {\n      value: true\n    }); // normal is assumed to be normalized\n\n    this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);\n    this.constant = constant !== undefined ? constant : 0;\n  }\n\n  set(normal, constant) {\n    this.normal.copy(normal);\n    this.constant = constant;\n    return this;\n  }\n\n  setComponents(x, y, z, w) {\n    this.normal.set(x, y, z);\n    this.constant = w;\n    return this;\n  }\n\n  setFromNormalAndCoplanarPoint(normal, point) {\n    this.normal.copy(normal);\n    this.constant = -point.dot(this.normal);\n    return this;\n  }\n\n  setFromCoplanarPoints(a, b, c) {\n    var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\n    this.setFromNormalAndCoplanarPoint(normal, a);\n    return this;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(plane) {\n    this.normal.copy(plane.normal);\n    this.constant = plane.constant;\n    return this;\n  }\n\n  normalize() {\n    // Note: will lead to a divide by zero if the plane is invalid.\n    var inverseNormalLength = 1.0 / this.normal.length();\n    this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= inverseNormalLength;\n    return this;\n  }\n\n  negate() {\n    this.constant *= -1;\n    this.normal.negate();\n    return this;\n  }\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) + this.constant;\n  }\n\n  distanceToSphere(sphere) {\n    return this.distanceToPoint(sphere.center) - sphere.radius;\n  }\n\n  projectPoint(point, target) {\n    if (target === undefined) {\n      console.warn('THREE.Plane: .projectPoint() target is now required');\n      target = new Vector3();\n    }\n\n    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);\n  }\n\n  intersectLine(line, target) {\n    if (target === undefined) {\n      console.warn('THREE.Plane: .intersectLine() target is now required');\n      target = new Vector3();\n    }\n\n    var direction = line.delta(_vector1);\n    var denominator = this.normal.dot(direction);\n\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (this.distanceToPoint(line.start) === 0) {\n        return target.copy(line.start);\n      } // Unsure if this is the correct method to handle this case.\n\n\n      return undefined;\n    }\n\n    var t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n    if (t < 0 || t > 1) {\n      return undefined;\n    }\n\n    return target.copy(direction).multiplyScalar(t).add(line.start);\n  }\n\n  intersectsLine(line) {\n    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n    var startSign = this.distanceToPoint(line.start);\n    var endSign = this.distanceToPoint(line.end);\n    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n  }\n\n  intersectsBox(box) {\n    return box.intersectsPlane(this);\n  }\n\n  intersectsSphere(sphere) {\n    return sphere.intersectsPlane(this);\n  }\n\n  coplanarPoint(target) {\n    if (target === undefined) {\n      console.warn('THREE.Plane: .coplanarPoint() target is now required');\n      target = new Vector3();\n    }\n\n    return target.copy(this.normal).multiplyScalar(-this.constant);\n  }\n\n  applyMatrix4(matrix, optionalNormalMatrix) {\n    var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n\n    var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n    var normal = this.normal.applyMatrix3(normalMatrix).normalize();\n    this.constant = -referencePoint.dot(normal);\n    return this;\n  }\n\n  translate(offset) {\n    this.constant -= offset.dot(this.normal);\n    return this;\n  }\n\n  equals(plane) {\n    return plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n\n}\n\nexport { Plane };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/math/Plane.js"],"names":["Matrix3","Vector3","_vector1","_vector2","_normalMatrix","Plane","constructor","normal","constant","Object","defineProperty","value","undefined","set","copy","setComponents","x","y","z","w","setFromNormalAndCoplanarPoint","point","dot","setFromCoplanarPoints","a","b","c","subVectors","cross","normalize","clone","plane","inverseNormalLength","length","multiplyScalar","negate","distanceToPoint","distanceToSphere","sphere","center","radius","projectPoint","target","console","warn","add","intersectLine","line","direction","delta","denominator","start","t","intersectsLine","startSign","endSign","end","intersectsBox","box","intersectsPlane","intersectsSphere","coplanarPoint","applyMatrix4","matrix","optionalNormalMatrix","normalMatrix","getNormalMatrix","referencePoint","applyMatrix3","translate","offset","equals"],"mappings":"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","sourcesContent":["import { Matrix3 } from './Matrix3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _vector1 = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector3();\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\nclass Plane {\n\n\tconstructor( normal, constant ) {\n\n\t\tObject.defineProperty( this, 'isPlane', { value: true } );\n\n\t\t// normal is assumed to be normalized\n\n\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n\t}\n\n\tset( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponents( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromNormalAndCoplanarPoint( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCoplanarPoints( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t}\n\n\tnormalize() {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t}\n\n\tdistanceToSphere( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t}\n\n\tprojectPoint( point, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .projectPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\n\n\t}\n\n\tintersectLine( line, target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .intersectLine() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t}\n\n\tintersectsLine( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t}\n\n\tcoplanarPoint( target ) {\n\n\t\tif ( target === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Plane: .coplanarPoint() target is now required' );\n\t\t\ttarget = new Vector3();\n\n\t\t}\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t}\n\n\tapplyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tequals( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n}\n\n\nexport { Plane };\n"]},"metadata":{},"sourceType":"module"}