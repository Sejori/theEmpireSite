{"ast":null,"code":"import { Curve } from './Curve.js';\nimport * as Curves from '../curves/Curves.js';\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nfunction CurvePath() {\n  Curve.call(this);\n  this.type = 'CurvePath';\n  this.curves = [];\n  this.autoClose = false; // Automatically closes the path\n}\n\nCurvePath.prototype = Object.assign(Object.create(Curve.prototype), {\n  constructor: CurvePath,\n  add: function add(curve) {\n    this.curves.push(curve);\n  },\n  closePath: function closePath() {\n    // Add a line curve if start and end of lines are not connected\n    var startPoint = this.curves[0].getPoint(0);\n    var endPoint = this.curves[this.curves.length - 1].getPoint(1);\n\n    if (!startPoint.equals(endPoint)) {\n      this.curves.push(new Curves['LineCurve'](endPoint, startPoint));\n    }\n  },\n  // To get accurate point with reference to\n  // entire path distance at time t,\n  // following has to be done:\n  // 1. Length of each sub path have to be known\n  // 2. Locate and identify type of curve\n  // 3. Get t for the curve\n  // 4. Return curve.getPointAt(t')\n  getPoint: function getPoint(t) {\n    var d = t * this.getLength();\n    var curveLengths = this.getCurveLengths();\n    var i = 0; // To think about boundaries points.\n\n    while (i < curveLengths.length) {\n      if (curveLengths[i] >= d) {\n        var diff = curveLengths[i] - d;\n        var curve = this.curves[i];\n        var segmentLength = curve.getLength();\n        var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n        return curve.getPointAt(u);\n      }\n\n      i++;\n    }\n\n    return null; // loop where sum != 0, sum > d , sum+1 <d\n  },\n  // We cannot use the default THREE.Curve getPoint() with getLength() because in\n  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n  // getPoint() depends on getLength\n  getLength: function getLength() {\n    var lens = this.getCurveLengths();\n    return lens[lens.length - 1];\n  },\n  // cacheLengths must be recalculated.\n  updateArcLengths: function updateArcLengths() {\n    this.needsUpdate = true;\n    this.cacheLengths = null;\n    this.getCurveLengths();\n  },\n  // Compute lengths and cache them\n  // We cannot overwrite getLengths() because UtoT mapping uses it.\n  getCurveLengths: function getCurveLengths() {\n    // We use cache values if curves and cache array are same length\n    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n      return this.cacheLengths;\n    } // Get length of sub-curve\n    // Push sums into cached array\n\n\n    var lengths = [];\n    var sums = 0;\n\n    for (var i = 0, l = this.curves.length; i < l; i++) {\n      sums += this.curves[i].getLength();\n      lengths.push(sums);\n    }\n\n    this.cacheLengths = lengths;\n    return lengths;\n  },\n  getSpacedPoints: function getSpacedPoints(divisions) {\n    if (divisions === undefined) divisions = 40;\n    var points = [];\n\n    for (var i = 0; i <= divisions; i++) {\n      points.push(this.getPoint(i / divisions));\n    }\n\n    if (this.autoClose) {\n      points.push(points[0]);\n    }\n\n    return points;\n  },\n  getPoints: function getPoints(divisions) {\n    divisions = divisions || 12;\n    var points = [];\n    var last;\n\n    for (var i = 0, curves = this.curves; i < curves.length; i++) {\n      var curve = curves[i];\n      var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;\n      var pts = curve.getPoints(resolution);\n\n      for (var j = 0; j < pts.length; j++) {\n        var point = pts[j];\n        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\n\n        points.push(point);\n        last = point;\n      }\n    }\n\n    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\n      points.push(points[0]);\n    }\n\n    return points;\n  },\n  copy: function copy(source) {\n    Curve.prototype.copy.call(this, source);\n    this.curves = [];\n\n    for (var i = 0, l = source.curves.length; i < l; i++) {\n      var curve = source.curves[i];\n      this.curves.push(curve.clone());\n    }\n\n    this.autoClose = source.autoClose;\n    return this;\n  },\n  toJSON: function toJSON() {\n    var data = Curve.prototype.toJSON.call(this);\n    data.autoClose = this.autoClose;\n    data.curves = [];\n\n    for (var i = 0, l = this.curves.length; i < l; i++) {\n      var curve = this.curves[i];\n      data.curves.push(curve.toJSON());\n    }\n\n    return data;\n  },\n  fromJSON: function fromJSON(json) {\n    Curve.prototype.fromJSON.call(this, json);\n    this.autoClose = json.autoClose;\n    this.curves = [];\n\n    for (var i = 0, l = json.curves.length; i < l; i++) {\n      var curve = json.curves[i];\n      this.curves.push(new Curves[curve.type]().fromJSON(curve));\n    }\n\n    return this;\n  }\n});\nexport { CurvePath };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/extras/core/CurvePath.js"],"names":["Curve","Curves","CurvePath","call","type","curves","autoClose","prototype","Object","assign","create","constructor","add","curve","push","closePath","startPoint","getPoint","endPoint","length","equals","t","d","getLength","curveLengths","getCurveLengths","i","diff","segmentLength","u","getPointAt","lens","updateArcLengths","needsUpdate","cacheLengths","lengths","sums","l","getSpacedPoints","divisions","undefined","points","getPoints","last","resolution","isEllipseCurve","isLineCurve","isLineCurve3","isSplineCurve","pts","j","point","copy","source","clone","toJSON","data","fromJSON","json"],"mappings":"AAAA,SAASA,KAAT,QAAsB,YAAtB;AACA,OAAO,KAAKC,MAAZ,MAAwB,qBAAxB;AAEA;AACA;AACA;AACA;;AAEA,SAASC,SAAT,GAAqB;AAEpBF,EAAAA,KAAK,CAACG,IAAN,CAAY,IAAZ;AAEA,OAAKC,IAAL,GAAY,WAAZ;AAEA,OAAKC,MAAL,GAAc,EAAd;AACA,OAAKC,SAAL,GAAiB,KAAjB,CAPoB,CAOI;AAExB;;AAEDJ,SAAS,CAACK,SAAV,GAAsBC,MAAM,CAACC,MAAP,CAAeD,MAAM,CAACE,MAAP,CAAeV,KAAK,CAACO,SAArB,CAAf,EAAiD;AAEtEI,EAAAA,WAAW,EAAET,SAFyD;AAItEU,EAAAA,GAAG,EAAE,aAAWC,KAAX,EAAmB;AAEvB,SAAKR,MAAL,CAAYS,IAAZ,CAAkBD,KAAlB;AAEA,GARqE;AAUtEE,EAAAA,SAAS,EAAE,qBAAY;AAEtB;AACA,QAAMC,UAAU,GAAG,KAAKX,MAAL,CAAa,CAAb,EAAiBY,QAAjB,CAA2B,CAA3B,CAAnB;AACA,QAAMC,QAAQ,GAAG,KAAKb,MAAL,CAAa,KAAKA,MAAL,CAAYc,MAAZ,GAAqB,CAAlC,EAAsCF,QAAtC,CAAgD,CAAhD,CAAjB;;AAEA,QAAK,CAAED,UAAU,CAACI,MAAX,CAAmBF,QAAnB,CAAP,EAAuC;AAEtC,WAAKb,MAAL,CAAYS,IAAZ,CAAkB,IAAIb,MAAM,CAAE,WAAF,CAAV,CAA2BiB,QAA3B,EAAqCF,UAArC,CAAlB;AAEA;AAED,GAtBqE;AAwBtE;AACA;AACA;AAEA;AACA;AACA;AACA;AAEAC,EAAAA,QAAQ,EAAE,kBAAWI,CAAX,EAAe;AAExB,QAAMC,CAAC,GAAGD,CAAC,GAAG,KAAKE,SAAL,EAAd;AACA,QAAMC,YAAY,GAAG,KAAKC,eAAL,EAArB;AACA,QAAIC,CAAC,GAAG,CAAR,CAJwB,CAMxB;;AAEA,WAAQA,CAAC,GAAGF,YAAY,CAACL,MAAzB,EAAkC;AAEjC,UAAKK,YAAY,CAAEE,CAAF,CAAZ,IAAqBJ,CAA1B,EAA8B;AAE7B,YAAMK,IAAI,GAAGH,YAAY,CAAEE,CAAF,CAAZ,GAAoBJ,CAAjC;AACA,YAAMT,KAAK,GAAG,KAAKR,MAAL,CAAaqB,CAAb,CAAd;AAEA,YAAME,aAAa,GAAGf,KAAK,CAACU,SAAN,EAAtB;AACA,YAAMM,CAAC,GAAGD,aAAa,KAAK,CAAlB,GAAsB,CAAtB,GAA0B,IAAID,IAAI,GAAGC,aAA/C;AAEA,eAAOf,KAAK,CAACiB,UAAN,CAAkBD,CAAlB,CAAP;AAEA;;AAEDH,MAAAA,CAAC;AAED;;AAED,WAAO,IAAP,CA1BwB,CA4BxB;AAEA,GA/DqE;AAiEtE;AACA;AACA;AAEAH,EAAAA,SAAS,EAAE,qBAAY;AAEtB,QAAMQ,IAAI,GAAG,KAAKN,eAAL,EAAb;AACA,WAAOM,IAAI,CAAEA,IAAI,CAACZ,MAAL,GAAc,CAAhB,CAAX;AAEA,GA1EqE;AA4EtE;AACAa,EAAAA,gBAAgB,EAAE,4BAAY;AAE7B,SAAKC,WAAL,GAAmB,IAAnB;AACA,SAAKC,YAAL,GAAoB,IAApB;AACA,SAAKT,eAAL;AAEA,GAnFqE;AAqFtE;AACA;AAEAA,EAAAA,eAAe,EAAE,2BAAY;AAE5B;AAEA,QAAK,KAAKS,YAAL,IAAqB,KAAKA,YAAL,CAAkBf,MAAlB,KAA6B,KAAKd,MAAL,CAAYc,MAAnE,EAA4E;AAE3E,aAAO,KAAKe,YAAZ;AAEA,KAR2B,CAU5B;AACA;;;AAEA,QAAMC,OAAO,GAAG,EAAhB;AACA,QAAIC,IAAI,GAAG,CAAX;;AAEA,SAAM,IAAIV,CAAC,GAAG,CAAR,EAAWW,CAAC,GAAG,KAAKhC,MAAL,CAAYc,MAAjC,EAAyCO,CAAC,GAAGW,CAA7C,EAAgDX,CAAC,EAAjD,EAAuD;AAEtDU,MAAAA,IAAI,IAAI,KAAK/B,MAAL,CAAaqB,CAAb,EAAiBH,SAAjB,EAAR;AACAY,MAAAA,OAAO,CAACrB,IAAR,CAAcsB,IAAd;AAEA;;AAED,SAAKF,YAAL,GAAoBC,OAApB;AAEA,WAAOA,OAAP;AAEA,GAnHqE;AAqHtEG,EAAAA,eAAe,EAAE,yBAAWC,SAAX,EAAuB;AAEvC,QAAKA,SAAS,KAAKC,SAAnB,EAA+BD,SAAS,GAAG,EAAZ;AAE/B,QAAME,MAAM,GAAG,EAAf;;AAEA,SAAM,IAAIf,CAAC,GAAG,CAAd,EAAiBA,CAAC,IAAIa,SAAtB,EAAiCb,CAAC,EAAlC,EAAwC;AAEvCe,MAAAA,MAAM,CAAC3B,IAAP,CAAa,KAAKG,QAAL,CAAeS,CAAC,GAAGa,SAAnB,CAAb;AAEA;;AAED,QAAK,KAAKjC,SAAV,EAAsB;AAErBmC,MAAAA,MAAM,CAAC3B,IAAP,CAAa2B,MAAM,CAAE,CAAF,CAAnB;AAEA;;AAED,WAAOA,MAAP;AAEA,GAzIqE;AA2ItEC,EAAAA,SAAS,EAAE,mBAAWH,SAAX,EAAuB;AAEjCA,IAAAA,SAAS,GAAGA,SAAS,IAAI,EAAzB;AAEA,QAAME,MAAM,GAAG,EAAf;AACA,QAAIE,IAAJ;;AAEA,SAAM,IAAIjB,CAAC,GAAG,CAAR,EAAWrB,MAAM,GAAG,KAAKA,MAA/B,EAAuCqB,CAAC,GAAGrB,MAAM,CAACc,MAAlD,EAA0DO,CAAC,EAA3D,EAAiE;AAEhE,UAAMb,KAAK,GAAGR,MAAM,CAAEqB,CAAF,CAApB;AACA,UAAMkB,UAAU,GAAK/B,KAAK,IAAIA,KAAK,CAACgC,cAAjB,GAAoCN,SAAS,GAAG,CAAhD,GACd1B,KAAK,KAAMA,KAAK,CAACiC,WAAN,IAAqBjC,KAAK,CAACkC,YAAjC,CAAP,GAA2D,CAA3D,GACGlC,KAAK,IAAIA,KAAK,CAACmC,aAAjB,GAAmCT,SAAS,GAAG1B,KAAK,CAAC4B,MAAN,CAAatB,MAA5D,GACCoB,SAHL;AAKA,UAAMU,GAAG,GAAGpC,KAAK,CAAC6B,SAAN,CAAiBE,UAAjB,CAAZ;;AAEA,WAAM,IAAIM,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGD,GAAG,CAAC9B,MAAzB,EAAiC+B,CAAC,EAAlC,EAAwC;AAEvC,YAAMC,KAAK,GAAGF,GAAG,CAAEC,CAAF,CAAjB;AAEA,YAAKP,IAAI,IAAIA,IAAI,CAACvB,MAAL,CAAa+B,KAAb,CAAb,EAAoC,SAJG,CAIO;;AAE9CV,QAAAA,MAAM,CAAC3B,IAAP,CAAaqC,KAAb;AACAR,QAAAA,IAAI,GAAGQ,KAAP;AAEA;AAED;;AAED,QAAK,KAAK7C,SAAL,IAAkBmC,MAAM,CAACtB,MAAP,GAAgB,CAAlC,IAAuC,CAAEsB,MAAM,CAAEA,MAAM,CAACtB,MAAP,GAAgB,CAAlB,CAAN,CAA4BC,MAA5B,CAAoCqB,MAAM,CAAE,CAAF,CAA1C,CAA9C,EAAkG;AAEjGA,MAAAA,MAAM,CAAC3B,IAAP,CAAa2B,MAAM,CAAE,CAAF,CAAnB;AAEA;;AAED,WAAOA,MAAP;AAEA,GAjLqE;AAmLtEW,EAAAA,IAAI,EAAE,cAAWC,MAAX,EAAoB;AAEzBrD,IAAAA,KAAK,CAACO,SAAN,CAAgB6C,IAAhB,CAAqBjD,IAArB,CAA2B,IAA3B,EAAiCkD,MAAjC;AAEA,SAAKhD,MAAL,GAAc,EAAd;;AAEA,SAAM,IAAIqB,CAAC,GAAG,CAAR,EAAWW,CAAC,GAAGgB,MAAM,CAAChD,MAAP,CAAcc,MAAnC,EAA2CO,CAAC,GAAGW,CAA/C,EAAkDX,CAAC,EAAnD,EAAyD;AAExD,UAAMb,KAAK,GAAGwC,MAAM,CAAChD,MAAP,CAAeqB,CAAf,CAAd;AAEA,WAAKrB,MAAL,CAAYS,IAAZ,CAAkBD,KAAK,CAACyC,KAAN,EAAlB;AAEA;;AAED,SAAKhD,SAAL,GAAiB+C,MAAM,CAAC/C,SAAxB;AAEA,WAAO,IAAP;AAEA,GArMqE;AAuMtEiD,EAAAA,MAAM,EAAE,kBAAY;AAEnB,QAAMC,IAAI,GAAGxD,KAAK,CAACO,SAAN,CAAgBgD,MAAhB,CAAuBpD,IAAvB,CAA6B,IAA7B,CAAb;AAEAqD,IAAAA,IAAI,CAAClD,SAAL,GAAiB,KAAKA,SAAtB;AACAkD,IAAAA,IAAI,CAACnD,MAAL,GAAc,EAAd;;AAEA,SAAM,IAAIqB,CAAC,GAAG,CAAR,EAAWW,CAAC,GAAG,KAAKhC,MAAL,CAAYc,MAAjC,EAAyCO,CAAC,GAAGW,CAA7C,EAAgDX,CAAC,EAAjD,EAAuD;AAEtD,UAAMb,KAAK,GAAG,KAAKR,MAAL,CAAaqB,CAAb,CAAd;AACA8B,MAAAA,IAAI,CAACnD,MAAL,CAAYS,IAAZ,CAAkBD,KAAK,CAAC0C,MAAN,EAAlB;AAEA;;AAED,WAAOC,IAAP;AAEA,GAvNqE;AAyNtEC,EAAAA,QAAQ,EAAE,kBAAWC,IAAX,EAAkB;AAE3B1D,IAAAA,KAAK,CAACO,SAAN,CAAgBkD,QAAhB,CAAyBtD,IAAzB,CAA+B,IAA/B,EAAqCuD,IAArC;AAEA,SAAKpD,SAAL,GAAiBoD,IAAI,CAACpD,SAAtB;AACA,SAAKD,MAAL,GAAc,EAAd;;AAEA,SAAM,IAAIqB,CAAC,GAAG,CAAR,EAAWW,CAAC,GAAGqB,IAAI,CAACrD,MAAL,CAAYc,MAAjC,EAAyCO,CAAC,GAAGW,CAA7C,EAAgDX,CAAC,EAAjD,EAAuD;AAEtD,UAAMb,KAAK,GAAG6C,IAAI,CAACrD,MAAL,CAAaqB,CAAb,CAAd;AACA,WAAKrB,MAAL,CAAYS,IAAZ,CAAkB,IAAIb,MAAM,CAAEY,KAAK,CAACT,IAAR,CAAV,GAA2BqD,QAA3B,CAAqC5C,KAArC,CAAlB;AAEA;;AAED,WAAO,IAAP;AAEA;AAzOqE,CAAjD,CAAtB;AA8OA,SAASX,SAAT","sourcesContent":["import { Curve } from './Curve.js';\nimport * as Curves from '../curves/Curves.js';\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nfunction CurvePath() {\n\n\tCurve.call( this );\n\n\tthis.type = 'CurvePath';\n\n\tthis.curves = [];\n\tthis.autoClose = false; // Automatically closes the path\n\n}\n\nCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\n\tconstructor: CurvePath,\n\n\tadd: function ( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t},\n\n\tclosePath: function () {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tconst startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tconst endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new Curves[ 'LineCurve' ]( endPoint, startPoint ) );\n\n\t\t}\n\n\t},\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint: function ( t ) {\n\n\t\tconst d = t * this.getLength();\n\t\tconst curveLengths = this.getCurveLengths();\n\t\tlet i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tconst diff = curveLengths[ i ] - d;\n\t\t\t\tconst curve = this.curves[ i ];\n\n\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t},\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength: function () {\n\n\t\tconst lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t},\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t},\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths: function () {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tconst lengths = [];\n\t\tlet sums = 0;\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t},\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( divisions === undefined ) divisions = 40;\n\n\t\tconst points = [];\n\n\t\tfor ( let i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\tgetPoints: function ( divisions ) {\n\n\t\tdivisions = divisions || 12;\n\n\t\tconst points = [];\n\t\tlet last;\n\n\t\tfor ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tconst curve = curves[ i ];\n\t\t\tconst resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\n\t\t\t\t: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1\n\t\t\t\t\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tconst pts = curve.getPoints( resolution );\n\n\t\t\tfor ( let j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tconst point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tCurve.prototype.copy.call( this, source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tconst data = Curve.prototype.toJSON.call( this );\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tfromJSON: function ( json ) {\n\n\t\tCurve.prototype.fromJSON.call( this, json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\n\nexport { CurvePath };\n"]},"metadata":{},"sourceType":"module"}