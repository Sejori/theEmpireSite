{"ast":null,"code":"/**\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html\n */\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nfunction ParametricBufferGeometry(func, slices, stacks) {\n  BufferGeometry.call(this);\n  this.type = 'ParametricBufferGeometry';\n  this.parameters = {\n    func: func,\n    slices: slices,\n    stacks: stacks\n  }; // buffers\n\n  var indices = [];\n  var vertices = [];\n  var normals = [];\n  var uvs = [];\n  var EPS = 0.00001;\n  var normal = new Vector3();\n  var p0 = new Vector3(),\n      p1 = new Vector3();\n  var pu = new Vector3(),\n      pv = new Vector3();\n\n  if (func.length < 3) {\n    console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');\n  } // generate vertices, normals and uvs\n\n\n  var sliceCount = slices + 1;\n\n  for (var i = 0; i <= stacks; i++) {\n    var v = i / stacks;\n\n    for (var j = 0; j <= slices; j++) {\n      var u = j / slices; // vertex\n\n      func(u, v, p0);\n      vertices.push(p0.x, p0.y, p0.z); // normal\n      // approximate tangent vectors via finite differences\n\n      if (u - EPS >= 0) {\n        func(u - EPS, v, p1);\n        pu.subVectors(p0, p1);\n      } else {\n        func(u + EPS, v, p1);\n        pu.subVectors(p1, p0);\n      }\n\n      if (v - EPS >= 0) {\n        func(u, v - EPS, p1);\n        pv.subVectors(p0, p1);\n      } else {\n        func(u, v + EPS, p1);\n        pv.subVectors(p1, p0);\n      } // cross product of tangent vectors returns surface normal\n\n\n      normal.crossVectors(pu, pv).normalize();\n      normals.push(normal.x, normal.y, normal.z); // uv\n\n      uvs.push(u, v);\n    }\n  } // generate indices\n\n\n  for (var _i = 0; _i < stacks; _i++) {\n    for (var _j = 0; _j < slices; _j++) {\n      var a = _i * sliceCount + _j;\n      var b = _i * sliceCount + _j + 1;\n      var c = (_i + 1) * sliceCount + _j + 1;\n      var d = (_i + 1) * sliceCount + _j; // faces one and two\n\n      indices.push(a, b, d);\n      indices.push(b, c, d);\n    }\n  } // build geometry\n\n\n  this.setIndex(indices);\n  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n}\n\nParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\nParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\nexport { ParametricBufferGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/ParametricBufferGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","ParametricBufferGeometry","func","slices","stacks","call","type","parameters","indices","vertices","normals","uvs","EPS","normal","p0","p1","pu","pv","length","console","error","sliceCount","i","v","j","u","push","x","y","z","subVectors","crossVectors","normalize","a","b","c","d","setIndex","setAttribute","prototype","Object","create","constructor"],"mappings":"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","sourcesContent":["/**\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html\n */\n\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nfunction ParametricBufferGeometry( func, slices, stacks ) {\n\n\tBufferGeometry.call( this );\n\n\tthis.type = 'ParametricBufferGeometry';\n\n\tthis.parameters = {\n\t\tfunc: func,\n\t\tslices: slices,\n\t\tstacks: stacks\n\t};\n\n\t// buffers\n\n\tconst indices = [];\n\tconst vertices = [];\n\tconst normals = [];\n\tconst uvs = [];\n\n\tconst EPS = 0.00001;\n\n\tconst normal = new Vector3();\n\n\tconst p0 = new Vector3(), p1 = new Vector3();\n\tconst pu = new Vector3(), pv = new Vector3();\n\n\tif ( func.length < 3 ) {\n\n\t\tconsole.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );\n\n\t}\n\n\t// generate vertices, normals and uvs\n\n\tconst sliceCount = slices + 1;\n\n\tfor ( let i = 0; i <= stacks; i ++ ) {\n\n\t\tconst v = i / stacks;\n\n\t\tfor ( let j = 0; j <= slices; j ++ ) {\n\n\t\t\tconst u = j / slices;\n\n\t\t\t// vertex\n\n\t\t\tfunc( u, v, p0 );\n\t\t\tvertices.push( p0.x, p0.y, p0.z );\n\n\t\t\t// normal\n\n\t\t\t// approximate tangent vectors via finite differences\n\n\t\t\tif ( u - EPS >= 0 ) {\n\n\t\t\t\tfunc( u - EPS, v, p1 );\n\t\t\t\tpu.subVectors( p0, p1 );\n\n\t\t\t} else {\n\n\t\t\t\tfunc( u + EPS, v, p1 );\n\t\t\t\tpu.subVectors( p1, p0 );\n\n\t\t\t}\n\n\t\t\tif ( v - EPS >= 0 ) {\n\n\t\t\t\tfunc( u, v - EPS, p1 );\n\t\t\t\tpv.subVectors( p0, p1 );\n\n\t\t\t} else {\n\n\t\t\t\tfunc( u, v + EPS, p1 );\n\t\t\t\tpv.subVectors( p1, p0 );\n\n\t\t\t}\n\n\t\t\t// cross product of tangent vectors returns surface normal\n\n\t\t\tnormal.crossVectors( pu, pv ).normalize();\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\n\t\t\tuvs.push( u, v );\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( let i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( let j = 0; j < slices; j ++ ) {\n\n\t\t\tconst a = i * sliceCount + j;\n\t\t\tconst b = i * sliceCount + j + 1;\n\t\t\tconst c = ( i + 1 ) * sliceCount + j + 1;\n\t\t\tconst d = ( i + 1 ) * sliceCount + j;\n\n\t\t\t// faces one and two\n\n\t\t\tindices.push( a, b, d );\n\t\t\tindices.push( b, c, d );\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n}\n\nParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\nParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\n\nexport { ParametricBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}