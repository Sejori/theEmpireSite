{"ast":null,"code":"import _construct from \"/Users/sebringrose/Projects/theEmpire/website/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/construct\";\nimport _defineProperty from \"/Users/sebringrose/Projects/theEmpire/website/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/sebringrose/Projects/theEmpire/website/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport * as THREE from 'three';\nimport { Raycaster, Vector2, PerspectiveCamera, WebGLRenderer, Scene, Vector3, Math as Math$1 } from 'three';\nimport React, { useRef, useState, useEffect, useCallback, useContext, useMemo } from 'react';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport Reconciler from 'react-reconciler';\nimport { unstable_now, unstable_scheduleCallback, unstable_cancelCallback, unstable_runWithPriority, unstable_IdlePriority } from 'scheduler';\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nvar roots = new Map();\nvar emptyObject = {};\nvar is = {\n  obj: function obj(a) {\n    return Object.prototype.toString.call(a) === '[object Object]';\n  },\n  str: function str(a) {\n    return typeof a === 'string';\n  },\n  num: function num(a) {\n    return typeof a === 'number';\n  },\n  und: function und(a) {\n    return a === void 0;\n  },\n  arr: function arr(a) {\n    return Array.isArray(a);\n  },\n  equ: function equ(a, b) {\n    // Wrong type, doesn't match\n    if (typeof a !== typeof b) return false; // Atomic, just compare a against b\n\n    if (is.str(a) || is.num(a) || is.obj(a)) return a === b; // Array, shallow compare first to see if it's a match\n\n    if (is.arr(a) && a == b) return true; // Last resort, go through keys\n\n    var i;\n\n    for (i in a) {\n      if (!(i in b)) return false;\n    }\n\n    for (i in b) {\n      if (a[i] !== b[i]) return false;\n    }\n\n    return is.und(i) ? a === b : true;\n  }\n};\nvar globalEffects = [];\n\nfunction addEffect(callback) {\n  globalEffects.push(callback);\n}\n\nvar running = false;\n\nfunction renderLoop() {\n  running = true;\n  var repeat = 0; // Run global effects\n\n  globalEffects.forEach(function (effect) {\n    return effect() && repeat++;\n  });\n  roots.forEach(function (root) {\n    var state = root.containerInfo.__state;\n    var _state$current = state.current,\n        invalidateFrameloop = _state$current.invalidateFrameloop,\n        frames = _state$current.frames,\n        active = _state$current.active,\n        ready = _state$current.ready,\n        subscribers = _state$current.subscribers,\n        manual = _state$current.manual,\n        scene = _state$current.scene,\n        gl = _state$current.gl,\n        camera = _state$current.camera; // If the frameloop is invalidated, do not run another frame\n\n    if (active && ready && (!invalidateFrameloop || frames > 0)) {\n      // Decrease frame count\n      state.current.frames = Math.max(0, state.current.frames - 1);\n      repeat += !invalidateFrameloop ? 1 : state.current.frames; // Run local effects\n\n      subscribers.forEach(function (fn) {\n        return fn(state.current);\n      }); // Render content\n\n      if (!manual) gl.render(scene, camera);\n    }\n  });\n  if (repeat !== 0) return requestAnimationFrame(renderLoop); // Flag end of operation\n\n  running = false;\n}\n\nfunction _invalidate(state, frames) {\n  if (frames === void 0) {\n    frames = 1;\n  }\n\n  if (state && state.current) state.current.frames = frames;else if (state === true) roots.forEach(function (root) {\n    return root.containerInfo.__state.current.frames = frames;\n  });\n\n  if (!running) {\n    running = true;\n    requestAnimationFrame(renderLoop);\n  }\n}\n\nvar catalogue = {};\n\nvar apply = function apply(objects) {\n  return catalogue = _extends({}, catalogue, objects);\n};\n\nfunction applyProps(instance, newProps, oldProps, interpolateArray, container) {\n  if (oldProps === void 0) {\n    oldProps = {};\n  }\n\n  if (interpolateArray === void 0) {\n    interpolateArray = false;\n  } // Filter equals, events and reserved props\n\n\n  var sameProps = Object.keys(newProps).filter(function (key) {\n    return is.equ(newProps[key], oldProps[key]);\n  });\n  var handlers = Object.keys(newProps).filter(function (key) {\n    return typeof newProps[key] === 'function' && key.startsWith('on');\n  });\n  var filteredProps = [].concat(_toConsumableArray(sameProps), ['children', 'key', 'ref']).reduce(function (acc, prop) {\n    var _ = acc[prop],\n        rest = _objectWithoutPropertiesLoose(acc, [prop].map(_toPropertyKey));\n\n    return rest;\n  }, newProps);\n\n  if (Object.keys(filteredProps).length > 0) {\n    Object.entries(filteredProps).forEach(function (_ref) {\n      var key = _ref[0],\n          value = _ref[1];\n\n      if (!handlers.includes(key)) {\n        var root = instance;\n        var _target = root[key];\n\n        if (key.includes('-')) {\n          var entries = key.split('-');\n          _target = entries.reduce(function (acc, key) {\n            return acc[key];\n          }, instance); // If the target is atomic, it forces us to switch the root\n\n          if (!(_target && _target.set)) {\n            var _entries$reverse = entries.reverse(),\n                name = _entries$reverse[0],\n                reverseEntries = _entries$reverse.slice(1);\n\n            root = reverseEntries.reverse().reduce(function (acc, key) {\n              return acc[key];\n            }, instance);\n            key = name;\n          }\n        } // Special treatment for objects with support for set/copy\n\n\n        if (_target && _target.set && _target.copy) {\n          var _target2;\n\n          if (_target.constructor.name === value.constructor.name) _target.copy(value);else if (Array.isArray(value)) (_target2 = _target).set.apply(_target2, _toConsumableArray(value));else _target.set(value); // Else, just overwrite the value\n        } else root[key] = value;\n\n        invalidateInstance(instance);\n      }\n    }); // Prep interaction handlers\n\n    if (handlers.length) {\n      // Add interactive object to central container\n      if (container && instance.raycast && !(handlers.length === 1 && handlers[0] === 'onUpdate')) container.__interaction.push(instance);\n      instance.__handlers = handlers.reduce(function (acc, key) {\n        return _extends({}, acc, _defineProperty({}, key.charAt(2).toLowerCase() + key.substr(3), newProps[key]));\n      }, {});\n    } // Call the update lifecycle when it is being updated\n\n\n    if (!container) updateInstance(instance);\n  }\n}\n\nfunction invalidateInstance(instance) {\n  if (instance.__container && instance.__container.__state) _invalidate(instance.__container.__state);\n}\n\nfunction updateInstance(instance) {\n  if (instance.__handlers && instance.__handlers.update) instance.__handlers.update(instance);\n}\n\nfunction createInstance(type, _ref2, container) {\n  var _ref2$args = _ref2.args,\n      args = _ref2$args === void 0 ? [] : _ref2$args,\n      props = _objectWithoutPropertiesLoose(_ref2, [\"args\"]);\n\n  var name = \"\".concat(type[0].toUpperCase()).concat(type.slice(1));\n  var instance;\n  if (type === 'primitive') instance = props.object;else {\n    var _target3 = catalogue[name] || THREE[name];\n\n    instance = Array.isArray(args) ? _construct(_target3, _toConsumableArray(args)) : new _target3(args);\n  } // Apply initial props\n\n  instance.__objects = [];\n  instance.__container = container;\n  applyProps(instance, props, {}, false, container);\n  return instance;\n}\n\nfunction appendChild(parentInstance, child) {\n  if (child) {\n    if (child.isObject3D) parentInstance.add(child);else {\n      parentInstance.__objects.push(child);\n\n      child.parent = parentInstance; // The attach attribute implies that the object attaches itself on the parent\n\n      if (child.attach) parentInstance[child.attach] = child;else if (child.attachArray) parentInstance[child.attachArray].push(child);else if (child.attachObject) parentInstance[child.attachObject[0]][child.attachObject[1]] = child;\n    }\n    updateInstance(child);\n    invalidateInstance(child);\n  }\n}\n\nfunction insertBefore(parentInstance, child, beforeChild) {\n  if (child) {\n    if (child.isObject3D) {\n      child.parent = parentInstance;\n      child.dispatchEvent({\n        type: 'added'\n      }); // TODO: the order is out of whack if data objects are present, has to be recalculated\n\n      var index = parentInstance.children.indexOf(beforeChild);\n      parentInstance.children = [].concat(_toConsumableArray(parentInstance.children.slice(0, index)), [child], _toConsumableArray(parentInstance.children.slice(index)));\n      updateInstance(child);\n    } else appendChild(parentInstance, child); // TODO: order!!!\n\n\n    invalidateInstance(child);\n  }\n}\n\nfunction removeChild(parentInstance, child) {\n  if (child) {\n    if (child.isObject3D) {\n      parentInstance.remove(child);\n    } else {\n      child.parent = undefined;\n      parentInstance.__objects = parentInstance.__objects.filter(function (x) {\n        return x !== child;\n      }); // Remove attachment\n\n      if (child.attach) parentInstance[child.attach] = undefined;else if (child.attachArray) parentInstance[child.attachArray] = target.filter(function (x) {\n        return x !== child;\n      });else if (child.attachObject) parentInstance[child.attachObject[0]][child.attachObject[1]] = undefined;\n    }\n\n    invalidateInstance(child);\n    unstable_runWithPriority(unstable_IdlePriority, function () {\n      // Remove child objects\n      child.__objects.forEach(function (nestedChild) {\n        return removeChild(child, nestedChild);\n      }); // Dispose item\n\n\n      if (child.dispose) child.dispose(); // TODO: remove events\n\n      delete child.__container;\n      delete child.__objects;\n    });\n  }\n}\n\nvar Renderer = Reconciler({\n  now: unstable_now,\n  createInstance: createInstance,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  insertBefore: insertBefore,\n  supportsMutation: true,\n  isPrimaryRenderer: false,\n  schedulePassiveEffects: unstable_scheduleCallback,\n  cancelPassiveEffects: unstable_cancelCallback,\n  appendInitialChild: appendChild,\n  appendChildToContainer: appendChild,\n  removeChildFromContainer: removeChild,\n  insertInContainerBefore: insertBefore,\n  commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps, fiber) {\n    if (instance.isObject3D) {\n      applyProps(instance, newProps, oldProps);\n    } else {\n      // This is a data object, let's extract critical information about it\n      var parent = instance.parent;\n\n      var _newProps$args = newProps.args,\n          argsNew = _newProps$args === void 0 ? [] : _newProps$args,\n          restNew = _objectWithoutPropertiesLoose(newProps, [\"args\"]);\n\n      var _oldProps$args = oldProps.args,\n          argsOld = _oldProps$args === void 0 ? [] : _oldProps$args,\n          restOld = _objectWithoutPropertiesLoose(oldProps, [\"args\"]); // If it has new props or arguments, then it needs to be re-instanciated\n      // TODO, are colors falsely detected here?\n\n\n      if (argsNew.some(function (value, index) {\n        return value !== argsOld[index];\n      })) {\n        // Next we create a new instance and append it again\n        var newInstance = createInstance(type, newProps, instance.__container);\n        removeChild(parent, instance);\n        appendChild(parent, newInstance) // This evil hack switches the react-internal fiber node\n        // https://github.com/facebook/react/issues/14983\n        // https://github.com/facebook/react/pull/15021\n        ;\n        [fiber, fiber.alternate].forEach(function (fiber) {\n          if (fiber !== null) {\n            fiber.stateNode = newInstance;\n\n            if (fiber.ref) {\n              if (typeof fiber.ref === 'function') fiber.ref(newInstance);else fiber.ref.current = newInstance;\n            }\n          }\n        });\n      } else {\n        // Otherwise just overwrite props\n        applyProps(instance, restNew, restOld);\n      }\n    }\n  },\n  getPublicInstance: function getPublicInstance(instance) {\n    return instance;\n  },\n  getRootHostContext: function getRootHostContext(rootContainerInstance) {\n    return emptyObject;\n  },\n  getChildHostContext: function getChildHostContext(parentHostContext, type) {\n    return emptyObject;\n  },\n  createTextInstance: function createTextInstance() {},\n  finalizeInitialChildren: function finalizeInitialChildren(instance, type, props, rootContainerInstance) {\n    return false;\n  },\n  prepareUpdate: function prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, hostContext) {\n    return emptyObject;\n  },\n  shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree(type, props) {\n    return false;\n  },\n  prepareForCommit: function prepareForCommit() {},\n  resetAfterCommit: function resetAfterCommit() {},\n  shouldSetTextContent: function shouldSetTextContent(props) {\n    return false;\n  }\n});\n\nfunction render(element, container, state) {\n  var root = roots.get(container);\n\n  if (!root) {\n    root = Renderer.createContainer(container);\n    container.__state = state;\n    roots.set(container, root);\n  }\n\n  Renderer.updateContainer(element, root, null, undefined);\n  return Renderer.getPublicRootInstance(root);\n}\n\nfunction unmountComponentAtNode(container) {\n  var root = roots.get(container);\n  if (root) Renderer.updateContainer(null, root, null, function () {\n    return roots.delete(container);\n  });\n}\n\nvar stateContext = React.createContext();\n\nfunction useMeasure() {\n  var ref = useRef();\n\n  var _useState = useState({\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0\n  }),\n      bounds = _useState[0],\n      set = _useState[1];\n\n  var _useState2 = useState(function () {\n    return new ResizeObserver(function (_ref) {\n      var entry = _ref[0];\n      return set(entry.contentRect);\n    });\n  }),\n      ro = _useState2[0];\n\n  useEffect(function () {\n    if (ref.current) ro.observe(ref.current);\n    return function () {\n      return ro.disconnect();\n    };\n  }, [ref.current]);\n  return [{\n    ref: ref\n  }, bounds];\n}\n\nvar Canvas = React.memo(function (_ref2) {\n  var children = _ref2.children,\n      gl = _ref2.gl,\n      camera = _ref2.camera,\n      style = _ref2.style,\n      pixelRatio = _ref2.pixelRatio,\n      _ref2$invalidateFrame = _ref2.invalidateFrameloop,\n      invalidateFrameloop = _ref2$invalidateFrame === void 0 ? false : _ref2$invalidateFrame,\n      onCreated = _ref2.onCreated,\n      rest = _objectWithoutPropertiesLoose(_ref2, [\"children\", \"gl\", \"camera\", \"style\", \"pixelRatio\", \"invalidateFrameloop\", \"onCreated\"]); // Local, reactive state\n\n\n  var canvas = useRef();\n\n  var _useState3 = useState(false),\n      ready = _useState3[0],\n      setReady = _useState3[1];\n\n  var _useMeasure = useMeasure(),\n      bind = _useMeasure[0],\n      size = _useMeasure[1];\n\n  var _useState4 = useState([]),\n      intersects = _useState4[0],\n      setIntersects = _useState4[1];\n\n  var _useState5 = useState(function () {\n    return new Raycaster();\n  }),\n      raycaster = _useState5[0];\n\n  var _useState6 = useState(function () {\n    return new Vector2();\n  }),\n      mouse = _useState6[0];\n\n  var _useState7 = useState(function () {\n    var cam = new PerspectiveCamera(75, 0, 0.1, 1000);\n    cam.position.z = 5;\n    if (camera) applyProps(cam, camera, {});\n    return cam;\n  }),\n      defaultCam = _useState7[0],\n      _setDefaultCamera = _useState7[1]; // Public state\n\n\n  var state = useRef({\n    ready: false,\n    subscribers: [],\n    manual: false,\n    active: true,\n    canvas: undefined,\n    gl: undefined,\n    camera: undefined,\n    scene: undefined,\n    size: undefined,\n    canvasRect: undefined,\n    frames: 0,\n    viewport: undefined,\n    captured: undefined,\n    subscribe: function subscribe(fn, main) {\n      state.current.subscribers.push(fn);\n      return function () {\n        return state.current.subscribers = state.current.subscribers.filter(function (s) {\n          return s !== fn;\n        });\n      };\n    },\n    setManual: function setManual(takeOverRenderloop) {\n      state.current.manual = takeOverRenderloop;\n\n      if (takeOverRenderloop) {\n        // In manual mode items shouldn't really be part of the internal scene which has adverse effects\n        // on the camera being unable to update without explicit calls to updateMatrixWorl()\n        state.current.scene.children.forEach(function (child) {\n          return state.current.scene.remove(child);\n        });\n      }\n    },\n    setDefaultCamera: function setDefaultCamera(cam) {\n      state.current.camera = cam;\n\n      _setDefaultCamera(cam);\n    },\n    invalidate: function invalidate() {\n      return _invalidate(state);\n    }\n  }); // Writes locals into public state for distribution among subscribers, context, etc\n\n  useEffect(function () {\n    state.current.ready = ready;\n    state.current.size = size;\n    state.current.camera = defaultCam;\n    state.current.invalidateFrameloop = invalidateFrameloop;\n  }, [invalidateFrameloop, ready, size, defaultCam]); // Component mount effect, creates the webGL render context\n\n  useEffect(function () {\n    state.current.gl = new WebGLRenderer(_extends({\n      canvas: canvas.current,\n      antialias: true,\n      alpha: true\n    }, gl));\n    if (pixelRatio) state.current.gl.setPixelRatio(pixelRatio);\n    state.current.gl.setClearAlpha(0);\n    state.current.canvas = canvas.current;\n    state.current.scene = new Scene();\n    state.current.scene.__interaction = [];\n    state.current.scene.__objects = []; // Start render-loop\n\n    _invalidate(state); // Clean-up\n\n\n    return function () {\n      state.current.active = false;\n      unmountComponentAtNode(state.current.scene);\n    };\n  }, []); // Adjusts default camera\n\n  useEffect(function () {\n    state.current.aspect = size.width / size.height || 0;\n    var target = new Vector3(0, 0, 0);\n    var distance = state.current.camera.position.distanceTo(target);\n    var fov = Math$1.degToRad(state.current.camera.fov); // convert vertical fov to radians\n\n    var height = 2 * Math.tan(fov / 2) * distance; // visible height\n\n    var width = height * state.current.aspect;\n    state.current.viewport = {\n      width: width,\n      height: height\n    };\n    state.current.canvasRect = bind.ref.current.getBoundingClientRect();\n\n    if (ready) {\n      state.current.gl.setSize(size.width, size.height);\n      state.current.camera.aspect = state.current.aspect;\n      state.current.camera.radius = (size.width + size.height) / 4;\n      state.current.camera.updateProjectionMatrix();\n\n      _invalidate(state);\n    }\n  }, [ready, size, defaultCam]); // This component is a bridge into the three render context, when it gets rendererd\n  // we know we are ready to compile shaders, call subscribers, etc\n\n  var IsReady = useCallback(function () {\n    var activate = useCallback(function () {\n      return void (setReady(true), _invalidate(state));\n    }, []);\n    useEffect(function () {\n      if (onCreated) {\n        var result = onCreated(state.current);\n        if (result.then) return void result.then(activate);\n      }\n\n      activate();\n    }, []);\n    return null;\n  }, []); // Render v-dom into scene\n\n  useEffect(function () {\n    if (size.width > 0 && size.height > 0) {\n      render(React.createElement(stateContext.Provider, {\n        value: _extends({}, state.current)\n      }, React.createElement(IsReady, null), typeof children === 'function' ? children(state.current) : children), state.current.scene, state);\n    }\n  });\n  /** Sets up raycaster */\n\n  var prepareRay = useCallback(function (event) {\n    var canvasRect = state.current.canvasRect;\n    var x = (event.clientX - canvasRect.left) / (canvasRect.right - canvasRect.left) * 2 - 1;\n    var y = -((event.clientY - canvasRect.top) / (canvasRect.bottom - canvasRect.top)) * 2 + 1;\n    mouse.set(x, y, 0.5);\n    raycaster.setFromCamera(mouse, state.current.camera);\n  }, []);\n  /** Intersects interaction objects using the event input */\n\n  var intersect = useCallback(function (event, prepare) {\n    if (prepare === void 0) {\n      prepare = true;\n    }\n\n    if (prepare) prepareRay(event);\n    return raycaster.intersectObjects(state.current.scene.__interaction, true).filter(function (h) {\n      return h.object.__handlers;\n    });\n  });\n  /**  Handles intersections by forwarding them to handlers */\n\n  var handleIntersects = useCallback(function (event, fn) {\n    prepareRay(event); // If the interaction is captured, take the last known hit instead of raycasting again\n\n    var hits = state.current.captured && event.type !== 'click' && event.type !== 'wheel' ? state.current.captured : intersect(event, false);\n\n    var _iterator = _createForOfIteratorHelper(hits),\n        _step;\n\n    try {\n      var _loop = function _loop() {\n        var hit = _step.value;\n        var stopped = {\n          current: false\n        };\n        fn(_extends({}, Object.assign({}, event), hit, {\n          stopped: stopped,\n          ray: raycaster.ray,\n          // Hijack stopPropagation, which just sets a flag\n          stopPropagation: function stopPropagation() {\n            return stopped.current = true;\n          },\n          // react-use-gesture transforms ...\n          transform: {\n            x: function x(_x) {\n              return _x / (state.current.size.width / state.current.viewport.width);\n            },\n            y: function y(_y) {\n              return -_y / (state.current.size.height / state.current.viewport.height);\n            }\n          }\n        }));\n        if (stopped.current === true) return \"break\";\n      };\n\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _ret = _loop();\n\n        if (_ret === \"break\") break;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return hits;\n  }, []);\n  var handlePointer = useCallback(function (name) {\n    return function (event) {\n      if (!state.current.ready) return;\n      handleIntersects(event, function (data) {\n        var object = data.object;\n        var handlers = object.__handlers;\n        if (handlers[name]) handlers[name](data);\n      });\n    };\n  }, []);\n  var hovered = useRef({});\n  var handlePointerMove = useCallback(function (event) {\n    if (!state.current.ready) return;\n    var hits = handleIntersects(event, function (data) {\n      var object = data.object;\n      var handlers = object.__handlers; // Call mouse move\n\n      if (handlers.pointerMove) handlers.pointerMove(data); // Check if mouse enter is present\n\n      if (handlers.pointerOver) {\n        if (!hovered.current[object.uuid]) {\n          // If the object wasn't previously hovered, book it and call its handler\n          hovered.current[object.uuid] = data;\n          handlers.pointerOver(_extends({}, data, {\n            type: 'pointerover'\n          }));\n        } else if (hovered.current[object.uuid].stopped.current) {\n          // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n          data.stopPropagation(); // In fact, wwe can safely remove them from the cache\n\n          Object.values(hovered.current).forEach(function (data) {\n            if (data.object.uuid !== object.uuid) {\n              if (data.object.__handlers.pointerOut) data.object.__handlers.pointerOut(_extends({}, data, {\n                type: 'pointerout'\n              }));\n              delete hovered.current[data.object.uuid];\n            }\n          });\n        }\n      }\n    }); // Take care of unhover\n\n    handlePointerCancel(event, hits);\n  }, []);\n  var handlePointerCancel = useCallback(function (event, hits) {\n    if (!hits) hits = handleIntersects(event, function () {\n      return null;\n    });\n    Object.values(hovered.current).forEach(function (data) {\n      if (!hits.length || !hits.find(function (i) {\n        return i.object === data.object;\n      })) {\n        if (data.object.__handlers.pointerOut) data.object.__handlers.pointerOut(_extends({}, data, {\n          type: 'pointerout'\n        }));\n        delete hovered.current[data.object.uuid];\n      }\n    });\n  }, []); // Render the canvas into the dom\n\n  return React.createElement(\"div\", _extends({}, bind, {\n    onClick: handlePointer('click'),\n    onWheel: handlePointer('wheel'),\n    onPointerDown: handlePointer('pointerDown'),\n    onPointerUp: handlePointer('pointerUp'),\n    onPointerLeave: function onPointerLeave(event) {\n      return handlePointerCancel(event, []);\n    },\n    onPointerMove: handlePointerMove // On capture intersect and remember the last known position\n    ,\n    onGotPointerCapture: function onGotPointerCapture(event) {\n      return state.current.captured = intersect(event, false);\n    } // On lost capture remove the captured hit\n    ,\n    onLostPointerCapture: function onLostPointerCapture(event) {\n      return state.current.captured = undefined, handlePointerCancel(event);\n    }\n  }, rest, {\n    style: _extends({\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden'\n    }, style)\n  }), React.createElement(\"canvas\", {\n    ref: canvas,\n    style: {\n      display: 'block'\n    }\n  }));\n});\n\nfunction useRender(fn, takeOverRenderloop) {\n  var _useContext = useContext(stateContext),\n      subscribe = _useContext.subscribe,\n      setManual = _useContext.setManual; // This calls into the host to inform it whether the render-loop is manual or not\n\n\n  useMemo(function () {\n    return takeOverRenderloop && setManual(true);\n  }, [takeOverRenderloop]);\n  useEffect(function () {\n    // Subscribe to the render-loop\n    var unsubscribe = subscribe(fn, takeOverRenderloop);\n    return function () {\n      // Call subscription off on unmount\n      unsubscribe();\n      if (takeOverRenderloop) setManual(false);\n    };\n  }, []);\n}\n\nfunction useThree() {\n  var _useContext2 = useContext(stateContext),\n      subscribe = _useContext2.subscribe,\n      props = _objectWithoutPropertiesLoose(_useContext2, [\"subscribe\"]);\n\n  return props;\n}\n\nexport { Canvas, addEffect, _invalidate as invalidate, render, unmountComponentAtNode, apply, applyProps, useRender, useThree };","map":null,"metadata":{},"sourceType":"module"}