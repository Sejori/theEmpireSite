{"ast":null,"code":"import { Cache } from './Cache.js';\nimport { Loader } from './Loader.js';\nvar loading = {};\n\nfunction FileLoader(manager) {\n  Loader.call(this, manager);\n}\n\nFileLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: FileLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    if (url === undefined) url = '';\n    if (this.path !== undefined) url = this.path + url;\n    url = this.manager.resolveURL(url);\n    var scope = this;\n    var cached = Cache.get(url);\n\n    if (cached !== undefined) {\n      scope.manager.itemStart(url);\n      setTimeout(function () {\n        if (onLoad) onLoad(cached);\n        scope.manager.itemEnd(url);\n      }, 0);\n      return cached;\n    } // Check if request is duplicate\n\n\n    if (loading[url] !== undefined) {\n      loading[url].push({\n        onLoad: onLoad,\n        onProgress: onProgress,\n        onError: onError\n      });\n      return;\n    } // Check for data: URI\n\n\n    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n    var dataUriRegexResult = url.match(dataUriRegex);\n    var request; // Safari can not handle Data URIs through XMLHttpRequest so process manually\n\n    if (dataUriRegexResult) {\n      var mimeType = dataUriRegexResult[1];\n      var isBase64 = !!dataUriRegexResult[2];\n      var data = dataUriRegexResult[3];\n      data = decodeURIComponent(data);\n      if (isBase64) data = atob(data);\n\n      try {\n        var response;\n        var responseType = (this.responseType || '').toLowerCase();\n\n        switch (responseType) {\n          case 'arraybuffer':\n          case 'blob':\n            var view = new Uint8Array(data.length);\n\n            for (var i = 0; i < data.length; i++) {\n              view[i] = data.charCodeAt(i);\n            }\n\n            if (responseType === 'blob') {\n              response = new Blob([view.buffer], {\n                type: mimeType\n              });\n            } else {\n              response = view.buffer;\n            }\n\n            break;\n\n          case 'document':\n            var parser = new DOMParser();\n            response = parser.parseFromString(data, mimeType);\n            break;\n\n          case 'json':\n            response = JSON.parse(data);\n            break;\n\n          default:\n            // 'text' or other\n            response = data;\n            break;\n        } // Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\n\n        setTimeout(function () {\n          if (onLoad) onLoad(response);\n          scope.manager.itemEnd(url);\n        }, 0);\n      } catch (error) {\n        // Wait for next browser tick like standard XMLHttpRequest event dispatching does\n        setTimeout(function () {\n          if (onError) onError(error);\n          scope.manager.itemError(url);\n          scope.manager.itemEnd(url);\n        }, 0);\n      }\n    } else {\n      // Initialise array for duplicate requests\n      loading[url] = [];\n      loading[url].push({\n        onLoad: onLoad,\n        onProgress: onProgress,\n        onError: onError\n      });\n      request = new XMLHttpRequest();\n      request.open('GET', url, true);\n      request.addEventListener('load', function (event) {\n        var response = this.response;\n        var callbacks = loading[url];\n        delete loading[url];\n\n        if (this.status === 200 || this.status === 0) {\n          // Some browsers return HTTP Status 0 when using non-http protocol\n          // e.g. 'file://' or 'data://'. Handle as success.\n          if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.'); // Add to cache only on HTTP success, so that we do not cache\n          // error response bodies as proper responses to requests.\n\n          Cache.add(url, response);\n\n          for (var _i = 0, il = callbacks.length; _i < il; _i++) {\n            var callback = callbacks[_i];\n            if (callback.onLoad) callback.onLoad(response);\n          }\n\n          scope.manager.itemEnd(url);\n        } else {\n          for (var _i2 = 0, _il = callbacks.length; _i2 < _il; _i2++) {\n            var _callback = callbacks[_i2];\n            if (_callback.onError) _callback.onError(event);\n          }\n\n          scope.manager.itemError(url);\n          scope.manager.itemEnd(url);\n        }\n      }, false);\n      request.addEventListener('progress', function (event) {\n        var callbacks = loading[url];\n\n        for (var _i3 = 0, il = callbacks.length; _i3 < il; _i3++) {\n          var callback = callbacks[_i3];\n          if (callback.onProgress) callback.onProgress(event);\n        }\n      }, false);\n      request.addEventListener('error', function (event) {\n        var callbacks = loading[url];\n        delete loading[url];\n\n        for (var _i4 = 0, il = callbacks.length; _i4 < il; _i4++) {\n          var callback = callbacks[_i4];\n          if (callback.onError) callback.onError(event);\n        }\n\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      }, false);\n      request.addEventListener('abort', function (event) {\n        var callbacks = loading[url];\n        delete loading[url];\n\n        for (var _i5 = 0, il = callbacks.length; _i5 < il; _i5++) {\n          var callback = callbacks[_i5];\n          if (callback.onError) callback.onError(event);\n        }\n\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      }, false);\n      if (this.responseType !== undefined) request.responseType = this.responseType;\n      if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;\n      if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');\n\n      for (var header in this.requestHeader) {\n        request.setRequestHeader(header, this.requestHeader[header]);\n      }\n\n      request.send(null);\n    }\n\n    scope.manager.itemStart(url);\n    return request;\n  },\n  setResponseType: function setResponseType(value) {\n    this.responseType = value;\n    return this;\n  },\n  setMimeType: function setMimeType(value) {\n    this.mimeType = value;\n    return this;\n  }\n});\nexport { FileLoader };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/loaders/FileLoader.js"],"names":["Cache","Loader","loading","FileLoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","undefined","path","resolveURL","scope","cached","get","itemStart","setTimeout","itemEnd","push","dataUriRegex","dataUriRegexResult","match","request","mimeType","isBase64","data","decodeURIComponent","atob","response","responseType","toLowerCase","view","Uint8Array","length","i","charCodeAt","Blob","buffer","type","parser","DOMParser","parseFromString","JSON","parse","error","itemError","XMLHttpRequest","open","addEventListener","event","callbacks","status","console","warn","add","il","callback","withCredentials","overrideMimeType","header","requestHeader","setRequestHeader","send","setResponseType","value","setMimeType"],"mappings":"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","sourcesContent":["import { Cache } from './Cache.js';\nimport { Loader } from './Loader.js';\n\nconst loading = {};\n\nfunction FileLoader( manager ) {\n\n\tLoader.call( this, manager );\n\n}\n\nFileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: FileLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\t// Check if request is duplicate\n\n\t\tif ( loading[ url ] !== undefined ) {\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Check for data: URI\n\t\tconst dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\tconst dataUriRegexResult = url.match( dataUriRegex );\n\t\tlet request;\n\n\t\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\n\t\tif ( dataUriRegexResult ) {\n\n\t\t\tconst mimeType = dataUriRegexResult[ 1 ];\n\t\t\tconst isBase64 = !! dataUriRegexResult[ 2 ];\n\n\t\t\tlet data = dataUriRegexResult[ 3 ];\n\t\t\tdata = decodeURIComponent( data );\n\n\t\t\tif ( isBase64 ) data = atob( data );\n\n\t\t\ttry {\n\n\t\t\t\tlet response;\n\t\t\t\tconst responseType = ( this.responseType || '' ).toLowerCase();\n\n\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\tconst view = new Uint8Array( data.length );\n\n\t\t\t\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\t\tview[ i ] = data.charCodeAt( i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( responseType === 'blob' ) {\n\n\t\t\t\t\t\t\tresponse = new Blob( [ view.buffer ], { type: mimeType } );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tresponse = view.buffer;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\tresponse = parser.parseFromString( data, mimeType );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\tresponse = JSON.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault: // 'text' or other\n\n\t\t\t\t\t\tresponse = data;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\tscope.manager.itemError( url );\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, 0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Initialise array for duplicate requests\n\n\t\t\tloading[ url ] = [];\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\trequest = new XMLHttpRequest();\n\n\t\t\trequest.open( 'GET', url, true );\n\n\t\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\t\tconst response = this.response;\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tif ( this.status === 200 || this.status === 0 ) {\n\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\tif ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t// Add to cache only on HTTP success, so that we do not cache\n\t\t\t\t\t// error response bodies as proper responses to requests.\n\t\t\t\t\tCache.add( url, response );\n\n\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( response );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\n\t\t\t\t}\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, false );\n\n\t\t\trequest.addEventListener( 'abort', function ( event ) {\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( event );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, false );\n\n\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\t\tif ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );\n\n\t\t\tfor ( const header in this.requestHeader ) {\n\n\t\t\t\trequest.setRequestHeader( header, this.requestHeader[ header ] );\n\n\t\t\t}\n\n\t\t\trequest.send( null );\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\treturn request;\n\n\t},\n\n\tsetResponseType: function ( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t},\n\n\tsetMimeType: function ( value ) {\n\n\t\tthis.mimeType = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n\nexport { FileLoader };\n"]},"metadata":{},"sourceType":"module"}