{"ast":null,"code":"import { BackSide, LinearFilter, LinearMipmapLinearFilter, NoBlending, RGBAFormat } from '../constants.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { BoxBufferGeometry } from '../geometries/BoxBufferGeometry.js';\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\nimport { cloneUniforms } from './shaders/UniformsUtils.js';\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\nimport { CubeCamera } from '../cameras/CubeCamera.js';\nimport { CubeTexture } from '../textures/CubeTexture.js';\n\nfunction WebGLCubeRenderTarget(size, options, dummy) {\n  if (Number.isInteger(options)) {\n    console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');\n    options = dummy;\n  }\n\n  WebGLRenderTarget.call(this, size, size, options);\n  options = options || {};\n  this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);\n  this.texture._needsFlipEnvMap = false;\n}\n\nWebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget.prototype);\nWebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;\nWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\n\nWebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function (renderer, texture) {\n  this.texture.type = texture.type;\n  this.texture.format = RGBAFormat; // see #18859\n\n  this.texture.encoding = texture.encoding;\n  this.texture.generateMipmaps = texture.generateMipmaps;\n  this.texture.minFilter = texture.minFilter;\n  this.texture.magFilter = texture.magFilter;\n  var shader = {\n    uniforms: {\n      tEquirect: {\n        value: null\n      }\n    },\n    vertexShader:\n    /* glsl */\n    \"\\n\\n\\t\\t\\tvarying vec3 vWorldDirection;\\n\\n\\t\\t\\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\n\\t\\t\\t\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\n\\t\\t\\t\\t#include <begin_vertex>\\n\\t\\t\\t\\t#include <project_vertex>\\n\\n\\t\\t\\t}\\n\\t\\t\",\n    fragmentShader:\n    /* glsl */\n    \"\\n\\n\\t\\t\\tuniform sampler2D tEquirect;\\n\\n\\t\\t\\tvarying vec3 vWorldDirection;\\n\\n\\t\\t\\t#include <common>\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tvec3 direction = normalize( vWorldDirection );\\n\\n\\t\\t\\t\\tvec2 sampleUV = equirectUv( direction );\\n\\n\\t\\t\\t\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\\n\\t\\t\\t}\\n\\t\\t\"\n  };\n  var geometry = new BoxBufferGeometry(5, 5, 5);\n  var material = new ShaderMaterial({\n    name: 'CubemapFromEquirect',\n    uniforms: cloneUniforms(shader.uniforms),\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader,\n    side: BackSide,\n    blending: NoBlending\n  });\n  material.uniforms.tEquirect.value = texture;\n  var mesh = new Mesh(geometry, material);\n  var currentMinFilter = texture.minFilter; // Avoid blurred poles\n\n  if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;\n  var camera = new CubeCamera(1, 10, this);\n  camera.update(renderer, mesh);\n  texture.minFilter = currentMinFilter;\n  mesh.geometry.dispose();\n  mesh.material.dispose();\n  return this;\n};\n\nexport { WebGLCubeRenderTarget };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/renderers/WebGLCubeRenderTarget.js"],"names":["BackSide","LinearFilter","LinearMipmapLinearFilter","NoBlending","RGBAFormat","Mesh","BoxBufferGeometry","ShaderMaterial","cloneUniforms","WebGLRenderTarget","CubeCamera","CubeTexture","WebGLCubeRenderTarget","size","options","dummy","Number","isInteger","console","warn","call","texture","undefined","mapping","wrapS","wrapT","magFilter","minFilter","format","type","anisotropy","encoding","_needsFlipEnvMap","prototype","Object","create","constructor","isWebGLCubeRenderTarget","fromEquirectangularTexture","renderer","generateMipmaps","shader","uniforms","tEquirect","value","vertexShader","fragmentShader","geometry","material","name","side","blending","mesh","currentMinFilter","camera","update","dispose"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,YAAnB,EAAiCC,wBAAjC,EAA2DC,UAA3D,EAAuEC,UAAvE,QAAyF,iBAAzF;AACA,SAASC,IAAT,QAAqB,oBAArB;AACA,SAASC,iBAAT,QAAkC,oCAAlC;AACA,SAASC,cAAT,QAA+B,gCAA/B;AACA,SAASC,aAAT,QAA8B,4BAA9B;AACA,SAASC,iBAAT,QAAkC,wBAAlC;AACA,SAASC,UAAT,QAA2B,0BAA3B;AACA,SAASC,WAAT,QAA4B,4BAA5B;;AAEA,SAASC,qBAAT,CAAgCC,IAAhC,EAAsCC,OAAtC,EAA+CC,KAA/C,EAAuD;AAEtD,MAAKC,MAAM,CAACC,SAAP,CAAkBH,OAAlB,CAAL,EAAmC;AAElCI,IAAAA,OAAO,CAACC,IAAR,CAAc,kGAAd;AAEAL,IAAAA,OAAO,GAAGC,KAAV;AAEA;;AAEDN,EAAAA,iBAAiB,CAACW,IAAlB,CAAwB,IAAxB,EAA8BP,IAA9B,EAAoCA,IAApC,EAA0CC,OAA1C;AAEAA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,OAAKO,OAAL,GAAe,IAAIV,WAAJ,CAAiBW,SAAjB,EAA4BR,OAAO,CAACS,OAApC,EAA6CT,OAAO,CAACU,KAArD,EAA4DV,OAAO,CAACW,KAApE,EAA2EX,OAAO,CAACY,SAAnF,EAA8FZ,OAAO,CAACa,SAAtG,EAAiHb,OAAO,CAACc,MAAzH,EAAiId,OAAO,CAACe,IAAzI,EAA+If,OAAO,CAACgB,UAAvJ,EAAmKhB,OAAO,CAACiB,QAA3K,CAAf;AAEA,OAAKV,OAAL,CAAaW,gBAAb,GAAgC,KAAhC;AAEA;;AAEDpB,qBAAqB,CAACqB,SAAtB,GAAkCC,MAAM,CAACC,MAAP,CAAe1B,iBAAiB,CAACwB,SAAjC,CAAlC;AACArB,qBAAqB,CAACqB,SAAtB,CAAgCG,WAAhC,GAA8CxB,qBAA9C;AAEAA,qBAAqB,CAACqB,SAAtB,CAAgCI,uBAAhC,GAA0D,IAA1D;;AAEAzB,qBAAqB,CAACqB,SAAtB,CAAgCK,0BAAhC,GAA6D,UAAWC,QAAX,EAAqBlB,OAArB,EAA+B;AAE3F,OAAKA,OAAL,CAAaQ,IAAb,GAAoBR,OAAO,CAACQ,IAA5B;AACA,OAAKR,OAAL,CAAaO,MAAb,GAAsBxB,UAAtB,CAH2F,CAGzD;;AAClC,OAAKiB,OAAL,CAAaU,QAAb,GAAwBV,OAAO,CAACU,QAAhC;AAEA,OAAKV,OAAL,CAAamB,eAAb,GAA+BnB,OAAO,CAACmB,eAAvC;AACA,OAAKnB,OAAL,CAAaM,SAAb,GAAyBN,OAAO,CAACM,SAAjC;AACA,OAAKN,OAAL,CAAaK,SAAb,GAAyBL,OAAO,CAACK,SAAjC;AAEA,MAAMe,MAAM,GAAG;AAEdC,IAAAA,QAAQ,EAAE;AACTC,MAAAA,SAAS,EAAE;AAAEC,QAAAA,KAAK,EAAE;AAAT;AADF,KAFI;AAMdC,IAAAA,YAAY;AAAE;AAAF,oXANE;AA0BdC,IAAAA,cAAc;AAAE;AAAF;AA1BA,GAAf;AA8CA,MAAMC,QAAQ,GAAG,IAAIzC,iBAAJ,CAAuB,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B,CAAjB;AAEA,MAAM0C,QAAQ,GAAG,IAAIzC,cAAJ,CAAoB;AAEpC0C,IAAAA,IAAI,EAAE,qBAF8B;AAIpCP,IAAAA,QAAQ,EAAElC,aAAa,CAAEiC,MAAM,CAACC,QAAT,CAJa;AAKpCG,IAAAA,YAAY,EAAEJ,MAAM,CAACI,YALe;AAMpCC,IAAAA,cAAc,EAAEL,MAAM,CAACK,cANa;AAOpCI,IAAAA,IAAI,EAAElD,QAP8B;AAQpCmD,IAAAA,QAAQ,EAAEhD;AAR0B,GAApB,CAAjB;AAYA6C,EAAAA,QAAQ,CAACN,QAAT,CAAkBC,SAAlB,CAA4BC,KAA5B,GAAoCvB,OAApC;AAEA,MAAM+B,IAAI,GAAG,IAAI/C,IAAJ,CAAU0C,QAAV,EAAoBC,QAApB,CAAb;AAEA,MAAMK,gBAAgB,GAAGhC,OAAO,CAACM,SAAjC,CA1E2F,CA4E3F;;AACA,MAAKN,OAAO,CAACM,SAAR,KAAsBzB,wBAA3B,EAAsDmB,OAAO,CAACM,SAAR,GAAoB1B,YAApB;AAEtD,MAAMqD,MAAM,GAAG,IAAI5C,UAAJ,CAAgB,CAAhB,EAAmB,EAAnB,EAAuB,IAAvB,CAAf;AACA4C,EAAAA,MAAM,CAACC,MAAP,CAAehB,QAAf,EAAyBa,IAAzB;AAEA/B,EAAAA,OAAO,CAACM,SAAR,GAAoB0B,gBAApB;AAEAD,EAAAA,IAAI,CAACL,QAAL,CAAcS,OAAd;AACAJ,EAAAA,IAAI,CAACJ,QAAL,CAAcQ,OAAd;AAEA,SAAO,IAAP;AAEA,CAzFD;;AA2FA,SAAS5C,qBAAT","sourcesContent":["import { BackSide, LinearFilter, LinearMipmapLinearFilter, NoBlending, RGBAFormat } from '../constants.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { BoxBufferGeometry } from '../geometries/BoxBufferGeometry.js';\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\nimport { cloneUniforms } from './shaders/UniformsUtils.js';\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\nimport { CubeCamera } from '../cameras/CubeCamera.js';\nimport { CubeTexture } from '../textures/CubeTexture.js';\n\nfunction WebGLCubeRenderTarget( size, options, dummy ) {\n\n\tif ( Number.isInteger( options ) ) {\n\n\t\tconsole.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );\n\n\t\toptions = dummy;\n\n\t}\n\n\tWebGLRenderTarget.call( this, size, size, options );\n\n\toptions = options || {};\n\n\tthis.texture = new CubeTexture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\tthis.texture._needsFlipEnvMap = false;\n\n}\n\nWebGLCubeRenderTarget.prototype = Object.create( WebGLRenderTarget.prototype );\nWebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;\n\nWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\n\nWebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function ( renderer, texture ) {\n\n\tthis.texture.type = texture.type;\n\tthis.texture.format = RGBAFormat; // see #18859\n\tthis.texture.encoding = texture.encoding;\n\n\tthis.texture.generateMipmaps = texture.generateMipmaps;\n\tthis.texture.minFilter = texture.minFilter;\n\tthis.texture.magFilter = texture.magFilter;\n\n\tconst shader = {\n\n\t\tuniforms: {\n\t\t\ttEquirect: { value: null },\n\t\t},\n\n\t\tvertexShader: /* glsl */`\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t`,\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t`\n\t};\n\n\tconst geometry = new BoxBufferGeometry( 5, 5, 5 );\n\n\tconst material = new ShaderMaterial( {\n\n\t\tname: 'CubemapFromEquirect',\n\n\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\tside: BackSide,\n\t\tblending: NoBlending\n\n\t} );\n\n\tmaterial.uniforms.tEquirect.value = texture;\n\n\tconst mesh = new Mesh( geometry, material );\n\n\tconst currentMinFilter = texture.minFilter;\n\n\t// Avoid blurred poles\n\tif ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;\n\n\tconst camera = new CubeCamera( 1, 10, this );\n\tcamera.update( renderer, mesh );\n\n\ttexture.minFilter = currentMinFilter;\n\n\tmesh.geometry.dispose();\n\tmesh.material.dispose();\n\n\treturn this;\n\n};\n\nexport { WebGLCubeRenderTarget };\n"]},"metadata":{},"sourceType":"module"}