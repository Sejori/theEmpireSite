{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass SphereBufferGeometry extends BufferGeometry {\n  constructor(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {\n    super();\n    this.type = 'SphereBufferGeometry';\n    this.parameters = {\n      radius: radius,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      phiStart: phiStart,\n      phiLength: phiLength,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    radius = radius || 1;\n    widthSegments = Math.max(3, Math.floor(widthSegments) || 8);\n    heightSegments = Math.max(2, Math.floor(heightSegments) || 6);\n    phiStart = phiStart !== undefined ? phiStart : 0;\n    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n    var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    var index = 0;\n    var grid = [];\n    var vertex = new Vector3();\n    var normal = new Vector3(); // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // generate vertices, normals and uvs\n\n    for (var iy = 0; iy <= heightSegments; iy++) {\n      var verticesRow = [];\n      var v = iy / heightSegments; // special case for the poles\n\n      var uOffset = 0;\n\n      if (iy == 0 && thetaStart == 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy == heightSegments && thetaEnd == Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n\n      for (var ix = 0; ix <= widthSegments; ix++) {\n        var u = ix / widthSegments; // vertex\n\n        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n        normal.copy(vertex).normalize();\n        normals.push(normal.x, normal.y, normal.z); // uv\n\n        uvs.push(u + uOffset, 1 - v);\n        verticesRow.push(index++);\n      }\n\n      grid.push(verticesRow);\n    } // indices\n\n\n    for (var _iy = 0; _iy < heightSegments; _iy++) {\n      for (var _ix = 0; _ix < widthSegments; _ix++) {\n        var a = grid[_iy][_ix + 1];\n        var b = grid[_iy][_ix];\n        var c = grid[_iy + 1][_ix];\n        var d = grid[_iy + 1][_ix + 1];\n        if (_iy !== 0 || thetaStart > 0) indices.push(a, b, d);\n        if (_iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n\n}\n\nexport { SphereBufferGeometry };","map":{"version":3,"sources":["/Users/sebringrose/Projects/theEmpire/website/client/node_modules/three/src/geometries/SphereBufferGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","SphereBufferGeometry","constructor","radius","widthSegments","heightSegments","phiStart","phiLength","thetaStart","thetaLength","type","parameters","Math","max","floor","undefined","PI","thetaEnd","min","index","grid","vertex","normal","indices","vertices","normals","uvs","iy","verticesRow","v","uOffset","ix","u","x","cos","sin","y","z","push","copy","normalize","a","b","c","d","setIndex","setAttribute"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass SphereBufferGeometry extends BufferGeometry {\n\n\tconstructor( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\t\tsuper();\n\t\tthis.type = 'SphereBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tradius = radius || 1;\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\t\tphiStart = phiStart !== undefined ? phiStart : 0;\n\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\t\tconst thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\n\n\t\tlet index = 0;\n\t\tconst grid = [];\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\t\tconst verticesRow = [];\n\n\t\t\tconst v = iy / heightSegments;\n\n\t\t\t// special case for the poles\n\n\t\t\tlet uOffset = 0;\n\n\t\t\tif ( iy == 0 && thetaStart == 0 ) {\n\n\t\t\t\tuOffset = 0.5 / widthSegments;\n\n\t\t\t} else if ( iy == heightSegments && thetaEnd == Math.PI ) {\n\n\t\t\t\tuOffset = - 0.5 / widthSegments;\n\n\t\t\t}\n\n\t\t\tfor ( let ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\t\tconst u = ix / widthSegments;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.copy( vertex ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u + uOffset, 1 - v );\n\n\t\t\t\tverticesRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\tgrid.push( verticesRow );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\t\tconst a = grid[ iy ][ ix + 1 ];\n\t\t\t\tconst b = grid[ iy ][ ix ];\n\t\t\t\tconst c = grid[ iy + 1 ][ ix ];\n\t\t\t\tconst d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n}\n\nexport { SphereBufferGeometry };\n"]},"metadata":{},"sourceType":"module"}